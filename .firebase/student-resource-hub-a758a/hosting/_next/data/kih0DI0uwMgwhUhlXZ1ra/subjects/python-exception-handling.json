{"pageProps":{"tutorial":{"title":"Python Exception Handling - Complete Guide","slug":"python-exception-handling","subject":"Python","category":"python","level":"Intermediate","estimated_read_time":"16 minutes","prerequisites":["Python functions","Python data types","Understanding of program flow","Basic file handling (helpful)"],"learning_objectives":["Understand what exceptions are and why they occur","Use try-except blocks to handle errors gracefully","Distinguish between different exception types","Use else and finally clauses effectively","Raise exceptions intentionally","Create and use custom exceptions","Debug programs using exception information","Write robust, error-resistant code"],"theory":"## What are Exceptions?\n\n**Exceptions** are errors that occur during program execution. They disrupt normal flow unless handled.\n\n### Real-Life Analogy\n\nThink of driving a car:\n- **Plan**: Drive from A to B\n- **Exception**: Flat tire (unexpected problem)\n- **Handling**: Pull over, change tire, continue\n- **No handling**: Crash (program terminates)\n\nException handling is like having a backup plan for when things go wrong.\n\n### Common Exceptions\n\n| Exception | Cause | Example |\n|-----------|-------|----------|\n| `ZeroDivisionError` | Division by zero | `10 / 0` |\n| `ValueError` | Invalid value | `int('abc')` |\n| `TypeError` | Wrong type | `'5' + 5` |\n| `IndexError` | Invalid index | `list[100]` |\n| `KeyError` | Missing dict key | `dict['missing']` |\n| `FileNotFoundError` | File doesn't exist | `open('missing.txt')` |\n| `AttributeError` | Missing attribute | `'text'.missing()` |\n| `NameError` | Undefined variable | `print(undefined)` |\n\n### Without Exception Handling\n\n```python\n# Program crashes on error\nnumber = int(input(\"Enter number: \"))  # User enters 'abc'\nresult = 100 / number\nprint(f\"Result: {result}\")\n# ValueError! Program terminates immediately\n```\n\n### With Exception Handling\n\n```python\n# Program continues despite error\ntry:\n    number = int(input(\"Enter number: \"))\n    result = 100 / number\n    print(f\"Result: {result}\")\nexcept ValueError:\n    print(\"Please enter a valid number\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\n# Program continues...\n```\n\n---\n\n## try-except Block\n\n### Basic Syntax\n\n```python\ntry:\n    # Code that might raise exception\n    risky_operation()\nexcept ExceptionType:\n    # Code to handle exception\n    handle_error()\n```\n\n### How It Works\n\n**Execution Flow:**\n\n1. **Try block executes** normally\n2. **If exception occurs:**\n   - Try block stops immediately\n   - Jump to except block\n   - Execute exception handler\n   - Continue after try-except\n3. **If no exception:**\n   - Try block completes\n   - Skip except block\n   - Continue after try-except\n\n### Visual Flow\n\n```\ntry:\n    line1  ✓ executes\n    line2  ✓ executes\n    line3  ❌ raises exception → jump to except\n    line4  ✗ skipped\nexcept:\n    handle_error  ✓ executes\n\nrest of program  ✓ continues\n```\n\n### Simple Example\n\n```python\ntry:\n    number = int(\"abc\")  # ValueError!\n    print(\"This won't print\")\nexcept ValueError:\n    print(\"Invalid number format\")\n\nprint(\"Program continues\")\n```\n\n**Output:**\n```\nInvalid number format\nProgram continues\n```\n\n---\n\n## Catching Specific Exceptions\n\n### Multiple except Blocks\n\n```python\ntry:\n    number = int(input(\"Enter number: \"))\n    result = 100 / number\n    print(f\"Result: {result}\")\nexcept ValueError:\n    print(\"Not a valid number\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n```\n\n**Order matters**: Most specific exceptions first, general last.\n\n### Catching Multiple Exceptions Together\n\n```python\ntry:\n    risky_operation()\nexcept (ValueError, TypeError) as e:\n    print(f\"Value or type error: {e}\")\n```\n\n### Getting Exception Information\n\n```python\ntry:\n    number = int(\"abc\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")  # Error: invalid literal for int()...\n    print(f\"Type: {type(e)}\")  # Type: <class 'ValueError'>\n```\n\n### Catching All Exceptions (Use Sparingly)\n\n```python\ntry:\n    risky_operation()\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n```\n\n**Warning**: Catching all exceptions can hide bugs!\n\n---\n\n## else Clause\n\n**else** executes only if try block succeeds (no exception).\n\n### Syntax\n\n```python\ntry:\n    # Code that might raise exception\n    risky_code()\nexcept ExceptionType:\n    # Handle exception\n    handle_error()\nelse:\n    # Executes only if NO exception\n    success_code()\n```\n\n### When to Use else\n\nCode that should only run if try succeeds.\n\n```python\ntry:\n    file = open('data.txt', 'r')\nexcept FileNotFoundError:\n    print(\"File not found\")\nelse:\n    # Only runs if file opened successfully\n    content = file.read()\n    print(content)\n    file.close()\n```\n\n### else vs Putting Code in try\n\n```python\n# ❌ Bad: Catch too much\ntry:\n    file = open('data.txt', 'r')\n    content = file.read()  # If this fails, hard to debug\n    process(content)       # Or this?\nexcept Exception:\n    print(\"Something failed, but what?\")\n\n# ✅ Good: Specific try, clear else\ntry:\n    file = open('data.txt', 'r')\nexcept FileNotFoundError:\n    print(\"File not found\")\nelse:\n    content = file.read()  # Different error handling possible\n    process(content)\n    file.close()\n```\n\n---\n\n## finally Clause\n\n**finally** always executes, whether exception occurred or not.\n\n### Syntax\n\n```python\ntry:\n    risky_code()\nexcept ExceptionType:\n    handle_error()\nfinally:\n    # ALWAYS executes\n    cleanup_code()\n```\n\n### Use Cases\n\n1. **Close files**\n2. **Release resources**\n3. **Close network connections**\n4. **Cleanup operations**\n\n### Example: File Cleanup\n\n```python\nfile = None\ntry:\n    file = open('data.txt', 'r')\n    content = file.read()\n    process(content)\nexcept FileNotFoundError:\n    print(\"File not found\")\nexcept Exception as e:\n    print(f\"Error: {e}\")\nfinally:\n    # Always close file if opened\n    if file:\n        file.close()\n        print(\"File closed\")\n```\n\n### finally Always Runs\n\n```python\ntry:\n    print(\"Try\")\n    raise ValueError(\"Error!\")\nexcept ValueError:\n    print(\"Except\")\nfinally:\n    print(\"Finally\")  # Always prints\n\n# Output:\n# Try\n# Except\n# Finally\n```\n\n**Even with return:**\n\n```python\ndef test():\n    try:\n        return \"From try\"\n    finally:\n        print(\"Finally runs\")  # Prints before return!\n\ntest()  # Prints: Finally runs, then returns\n```\n\n---\n\n## Complete try-except-else-finally\n\n### Full Syntax\n\n```python\ntry:\n    # Code that might raise exception\n    risky_code()\nexcept ExceptionType1:\n    # Handle specific exception\n    handle_error1()\nexcept ExceptionType2:\n    # Handle different exception\n    handle_error2()\nelse:\n    # Only if try succeeds\n    success_code()\nfinally:\n    # Always executes\n    cleanup_code()\n```\n\n### Execution Flow Table\n\n| Scenario | try | except | else | finally |\n|----------|-----|--------|------|--------|\n| **No exception** | ✓ | ✗ | ✓ | ✓ |\n| **Exception caught** | Partial ✓ | ✓ | ✗ | ✓ |\n| **Exception not caught** | Partial ✓ | ✗ | ✗ | ✓ then crash |\n\n### Complete Example\n\n```python\ndef divide_numbers(a, b):\n    try:\n        print(\"Attempting division\")\n        result = a / b\n    except ZeroDivisionError:\n        print(\"Cannot divide by zero\")\n        return None\n    except TypeError:\n        print(\"Invalid types\")\n        return None\n    else:\n        print(\"Division successful\")\n        return result\n    finally:\n        print(\"Cleanup complete\")\n\nprint(divide_numbers(10, 2))   # Success\nprint(divide_numbers(10, 0))   # ZeroDivisionError\nprint(divide_numbers(10, 'a')) # TypeError\n```\n\n---\n\n## Raising Exceptions\n\nYou can **raise** exceptions intentionally.\n\n### Basic raise\n\n```python\ndef validate_age(age):\n    if age < 0:\n        raise ValueError(\"Age cannot be negative\")\n    if age > 150:\n        raise ValueError(\"Age too high\")\n    return age\n\ntry:\n    validate_age(-5)\nexcept ValueError as e:\n    print(f\"Error: {e}\")  # Error: Age cannot be negative\n```\n\n### raise Without Arguments\n\nRe-raise current exception:\n\n```python\ntry:\n    risky_operation()\nexcept Exception as e:\n    print(f\"Logging error: {e}\")\n    raise  # Re-raise same exception\n```\n\n### Common Pattern: Validation\n\n```python\ndef withdraw(balance, amount):\n    if amount <= 0:\n        raise ValueError(\"Amount must be positive\")\n    if amount > balance:\n        raise ValueError(\"Insufficient funds\")\n    return balance - amount\n\ntry:\n    new_balance = withdraw(100, 150)\nexcept ValueError as e:\n    print(f\"Transaction failed: {e}\")\n```\n\n---\n\n## Custom Exceptions\n\nCreate your own exception classes.\n\n### Basic Custom Exception\n\n```python\nclass InvalidEmailError(Exception):\n    \"\"\"Raised when email format is invalid\"\"\"\n    pass\n\ndef validate_email(email):\n    if '@' not in email:\n        raise InvalidEmailError(\"Email must contain @\")\n    return email\n\ntry:\n    validate_email(\"invalidemail.com\")\nexcept InvalidEmailError as e:\n    print(f\"Error: {e}\")\n```\n\n### Custom Exception with Attributes\n\n```python\nclass InsufficientFundsError(Exception):\n    \"\"\"Raised when account has insufficient funds\"\"\"\n    def __init__(self, balance, amount):\n        self.balance = balance\n        self.amount = amount\n        self.shortage = amount - balance\n        message = f\"Need ${amount}, but only ${balance} available\"\n        super().__init__(message)\n\ndef withdraw(balance, amount):\n    if amount > balance:\n        raise InsufficientFundsError(balance, amount)\n    return balance - amount\n\ntry:\n    withdraw(100, 150)\nexcept InsufficientFundsError as e:\n    print(f\"Error: {e}\")\n    print(f\"Short by: ${e.shortage}\")\n```\n\n### Exception Hierarchy\n\n```python\nclass ValidationError(Exception):\n    \"\"\"Base validation error\"\"\"\n    pass\n\nclass EmailError(ValidationError):\n    \"\"\"Email validation error\"\"\"\n    pass\n\nclass PhoneError(ValidationError):\n    \"\"\"Phone validation error\"\"\"\n    pass\n\n# Can catch all validation errors\ntry:\n    raise EmailError(\"Invalid email\")\nexcept ValidationError as e:\n    print(f\"Validation failed: {e}\")\n```\n\n---\n\n## Debugging with Exceptions\n\n### Getting Traceback Information\n\n```python\nimport traceback\n\ntry:\n    risky_function()\nexcept Exception as e:\n    print(f\"Error: {e}\")\n    print(\"\nFull traceback:\")\n    traceback.print_exc()\n```\n\n### Logging Exceptions\n\n```python\nimport logging\n\nlogging.basicConfig(level=logging.ERROR)\n\ntry:\n    risky_operation()\nexcept Exception as e:\n    logging.error(\"An error occurred\", exc_info=True)\n```\n\n### Assert for Debugging\n\n```python\ndef divide(a, b):\n    assert b != 0, \"Denominator cannot be zero\"\n    return a / b\n\n# Raises AssertionError if condition false\ntry:\n    divide(10, 0)\nexcept AssertionError as e:\n    print(f\"Assertion failed: {e}\")\n```\n\n---\n\n## Best Practices\n\n### 1. Be Specific with Exceptions\n\n```python\n# ❌ Too broad\ntry:\n    code()\nexcept:\n    pass  # Catches everything, even Ctrl+C!\n\n# ✅ Specific\ntry:\n    code()\nexcept ValueError:\n    handle_value_error()\nexcept FileNotFoundError:\n    handle_file_error()\n```\n\n### 2. Don't Silence Exceptions\n\n```python\n# ❌ Silent failure\ntry:\n    important_operation()\nexcept:\n    pass  # Error happens, no one knows!\n\n# ✅ At least log\ntry:\n    important_operation()\nexcept Exception as e:\n    logging.error(f\"Operation failed: {e}\")\n    # Or raise, or notify user\n```\n\n### 3. Use else for Success Code\n\n```python\n# ✅ Clear separation\ntry:\n    file = open('data.txt', 'r')\nexcept FileNotFoundError:\n    print(\"File not found\")\nelse:\n    process(file.read())\n    file.close()\n```\n\n### 4. Use finally for Cleanup\n\n```python\n# ✅ Guaranteed cleanup\nresource = acquire_resource()\ntry:\n    use_resource(resource)\nfinally:\n    release_resource(resource)\n```\n\n### 5. Provide Helpful Error Messages\n\n```python\n# ❌ Vague\nraise ValueError(\"Invalid input\")\n\n# ✅ Specific\nraise ValueError(f\"Age must be 0-150, got {age}\")\n```\n\n---\n\n## Common Exception Patterns\n\n### Pattern 1: Retry Logic\n\n```python\nimport time\n\ndef retry_operation(max_attempts=3):\n    for attempt in range(max_attempts):\n        try:\n            result = risky_operation()\n            return result\n        except ConnectionError:\n            if attempt < max_attempts - 1:\n                print(f\"Retry {attempt + 1}/{max_attempts}\")\n                time.sleep(1)\n            else:\n                raise\n```\n\n### Pattern 2: Context Manager\n\n```python\nclass DatabaseConnection:\n    def __enter__(self):\n        self.conn = connect_to_db()\n        return self.conn\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.conn.close()\n        # Return False to propagate exception\n        return False\n\nwith DatabaseConnection() as conn:\n    conn.query(\"SELECT * FROM users\")\n# Connection auto-closed even if exception\n```\n\n### Pattern 3: Default Values\n\n```python\ndef get_config(key, default=None):\n    try:\n        return config[key]\n    except KeyError:\n        return default\n\nport = get_config('port', 8080)\n```","syntax":"# Basic try-except\ntry:\n    # risky code\nexcept ExceptionType:\n    # handle error\n\n# Multiple exceptions\ntry:\n    # code\nexcept ValueError:\n    # handle ValueError\nexcept TypeError:\n    # handle TypeError\n\n# Catch multiple as one\ntry:\n    # code\nexcept (ValueError, TypeError) as e:\n    # handle either\n\n# Get exception info\ntry:\n    # code\nexcept Exception as e:\n    print(e)\n\n# else clause\ntry:\n    # code\nexcept Exception:\n    # handle error\nelse:\n    # runs if no exception\n\n# finally clause\ntry:\n    # code\nexcept Exception:\n    # handle error\nfinally:\n    # always runs\n\n# Raise exception\nraise ValueError(\"message\")\nraise  # re-raise\n\n# Custom exception\nclass MyError(Exception):\n    pass\n\nraise MyError(\"message\")","examples":[{"code":"# Example 1: Basic try-except\nprint(\"Calculator\")\ntry:\n    num1 = int(input(\"Enter first number: \"))\n    num2 = int(input(\"Enter second number: \"))\n    result = num1 / num2\n    print(f\"Result: {result}\")\nexcept ValueError:\n    print(\"Please enter valid numbers\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\n\nprint(\"Program continues...\")\n\n# Try with: 10, 2 → Works\n# Try with: abc → ValueError caught\n# Try with: 10, 0 → ZeroDivisionError caught","output":"Calculator\nEnter first number: 10\nEnter second number: 0\nCannot divide by zero\nProgram continues...","explanation":"try block contains code that might fail. Specific exceptions caught separately. Program doesn't crash - handles errors gracefully and continues execution."},{"code":"# Example 2: try-except-else-finally Flow\ndef read_file(filename):\n    file = None\n    try:\n        print(f\"Trying to open {filename}\")\n        file = open(filename, 'r')\n    except FileNotFoundError:\n        print(\"File not found!\")\n        return None\n    else:\n        print(\"File opened successfully\")\n        content = file.read()\n        return content\n    finally:\n        print(\"Cleanup...\")\n        if file:\n            file.close()\n            print(\"File closed\")\n\n# Test\nresult = read_file('missing.txt')\nprint(f\"Result: {result}\")","output":"Trying to open missing.txt\nFile not found!\nCleanup...\nResult: None","explanation":"Flow: try → exception → except → finally. else skipped (exception occurred). finally always runs for cleanup. If file existed: try → else → finally."},{"code":"# Example 3: Multiple Exception Types\ndef safe_divide(a, b):\n    try:\n        result = a / b\n        return result\n    except ZeroDivisionError:\n        print(\"Error: Division by zero\")\n        return None\n    except TypeError:\n        print(\"Error: Invalid types\")\n        return None\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        return None\n\nprint(safe_divide(10, 2))    # 5.0\nprint(safe_divide(10, 0))    # None (ZeroDivisionError)\nprint(safe_divide(10, '2'))  # None (TypeError)\nprint(safe_divide('10', 2))  # None (TypeError)","output":"5.0\nError: Division by zero\nNone\nError: Invalid types\nNone\nError: Invalid types\nNone","explanation":"Catches different exceptions with specific handlers. Most specific first, general Exception last. Each error type handled appropriately. Function returns None on error."},{"code":"# Example 4: Custom Exception\nclass AgeError(Exception):\n    \"\"\"Custom exception for age validation\"\"\"\n    pass\n\ndef validate_age(age):\n    if not isinstance(age, int):\n        raise TypeError(\"Age must be an integer\")\n    if age < 0:\n        raise AgeError(\"Age cannot be negative\")\n    if age > 150:\n        raise AgeError(\"Age too high (must be <= 150)\")\n    return age\n\n# Test different cases\nages = [25, -5, 200, 'twenty']\n\nfor age in ages:\n    try:\n        valid_age = validate_age(age)\n        print(f\"Valid age: {valid_age}\")\n    except AgeError as e:\n        print(f\"AgeError: {e}\")\n    except TypeError as e:\n        print(f\"TypeError: {e}\")","output":"Valid age: 25\nAgeError: Age cannot be negative\nAgeError: Age too high (must be <= 150)\nTypeError: Age must be an integer","explanation":"Custom exception class inherits from Exception. Raises custom AgeError for domain-specific validation. Different exceptions for different error types. Makes error handling clearer."},{"code":"# Example 5: Raising and Re-raising Exceptions\ndef withdraw(balance, amount):\n    if amount <= 0:\n        raise ValueError(\"Amount must be positive\")\n    if amount > balance:\n        raise ValueError(f\"Insufficient funds: need ${amount}, have ${balance}\")\n    return balance - amount\n\ndef process_withdrawal(balance, amount):\n    try:\n        new_balance = withdraw(balance, amount)\n        print(f\"Withdrawal successful. New balance: ${new_balance}\")\n        return new_balance\n    except ValueError as e:\n        print(f\"Transaction failed: {e}\")\n        # Log error, then re-raise\n        print(\"Logging error...\")\n        raise  # Re-raise same exception\n\ntry:\n    process_withdrawal(100, 150)\nexcept ValueError:\n    print(\"Handled at higher level\")","output":"Transaction failed: Insufficient funds: need $150, have $100\nLogging error...\nHandled at higher level","explanation":"withdraw() raises ValueError. process_withdrawal() catches, logs, then re-raises with 'raise'. Outer try-except catches re-raised exception. Useful for logging while propagating error."},{"code":"# Example 6: Exception Information\nimport sys\n\ndef divide_debug(a, b):\n    try:\n        result = a / b\n        return result\n    except Exception as e:\n        exc_type, exc_value, exc_traceback = sys.exc_info()\n        print(f\"Exception type: {exc_type.__name__}\")\n        print(f\"Exception message: {exc_value}\")\n        print(f\"Line number: {exc_traceback.tb_lineno}\")\n        return None\n\nprint(\"Test 1:\")\ndivide_debug(10, 0)\n\nprint(\"\nTest 2:\")\ndivide_debug(10, 'a')","output":"Test 1:\nException type: ZeroDivisionError\nException message: division by zero\nLine number: 5\n\nTest 2:\nException type: TypeError\nException message: unsupported operand type(s) for /: 'int' and 'str'\nLine number: 5","explanation":"sys.exc_info() provides detailed exception information. Shows exception type, message, and line number. Useful for debugging and logging. Helps identify exact error location."},{"code":"# Example 7: Nested try-except (Error Recovery)\ndef robust_input():\n    \"\"\"Get integer input with retry\"\"\"\n    attempts = 3\n    \n    for attempt in range(attempts):\n        try:\n            value = int(input(f\"Enter number (attempt {attempt + 1}/{attempts}): \"))\n            return value\n        except ValueError:\n            if attempt < attempts - 1:\n                print(\"Invalid input, try again\")\n            else:\n                print(\"Max attempts reached\")\n                raise ValueError(\"Failed to get valid input\")\n\ntry:\n    number = robust_input()\n    print(f\"You entered: {number}\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\n# Simulated input: 'abc', 'def', '123'\n# Output: Invalid attempts, then success","output":"Enter number (attempt 1/3): abc\nInvalid input, try again\nEnter number (attempt 2/3): def\nInvalid input, try again\nEnter number (attempt 3/3): 123\nYou entered: 123","explanation":"Nested try-except with retry logic. Gives user multiple chances. Final attempt raises exception if all fail. Common pattern for user input validation and network requests."}],"common_mistakes":[{"mistake":"Catching all exceptions with bare 'except'","correction":"Always specify exception type or use Exception","example":"❌ try:\n       code()\n   except:  # Catches EVERYTHING, even Ctrl+C!\n       pass\n\n✅ try:\n       code()\n   except ValueError:\n       handle_value_error()\n   except Exception as e:\n       print(f\"Error: {e}\")"},{"mistake":"Silently ignoring exceptions with empty except","correction":"At minimum, log the error","example":"❌ try:\n       important_operation()\n   except:\n       pass  # Error disappears!\n\n✅ try:\n       important_operation()\n   except Exception as e:\n       logging.error(f\"Operation failed: {e}\")\n       # Or notify user, or re-raise"},{"mistake":"Using try-except instead of if for flow control","correction":"Use if for expected conditions, exceptions for errors","example":"❌ try:\n       value = dict[key]  # KeyError if missing\n   except KeyError:\n       value = default\n\n✅ value = dict.get(key, default)  # Clearer\n# Or\n✅ if key in dict:\n       value = dict[key]\n   else:\n       value = default"},{"mistake":"Not providing specific error messages","correction":"Include context in exception messages","example":"❌ raise ValueError(\"Invalid input\")\n\n✅ raise ValueError(f\"Age must be 0-150, got {age}\")\n✅ raise FileNotFoundError(f\"Config file not found: {filepath}\")"},{"mistake":"Catching parent exception before child","correction":"Order exceptions from specific to general","example":"❌ try:\n       code()\n   except Exception:  # Catches everything!\n       handle()\n   except ValueError:  # Never reached!\n       handle_value_error()\n\n✅ try:\n       code()\n   except ValueError:  # Specific first\n       handle_value_error()\n   except Exception:   # General last\n       handle()"}],"interview_questions":[{"question":"What is the difference between syntax errors and exceptions?","difficulty":"Easy","answer":"Syntax errors occur before code runs (parsing). Exceptions occur during execution. Syntax: missing colon, wrong indentation. Exceptions: ZeroDivisionError, ValueError. Syntax errors must be fixed, exceptions can be caught."},{"question":"What is the purpose of 'else' clause in try-except?","difficulty":"Medium","answer":"'else' executes only if try block succeeds (no exception). Use for code that should only run on success. Keeps try block minimal (only risky code). Clearer than putting all code in try."},{"question":"When does 'finally' block execute?","difficulty":"Easy","answer":"'finally' ALWAYS executes: if exception caught, not caught, or no exception. Even if return statement in try/except. Used for cleanup: closing files, releasing resources, network cleanup."},{"question":"What happens if you don't catch an exception?","difficulty":"Easy","answer":"Exception propagates up call stack. If never caught, program terminates with traceback. Shows exception type, message, and line number. Can be caught at higher level."},{"question":"How do you create a custom exception?","difficulty":"Medium","answer":"Inherit from Exception class: class MyError(Exception): pass. Can add __init__ for custom attributes. Raise with: raise MyError('message'). Makes domain-specific errors clearer."},{"question":"What's the difference between 'raise' and 'raise Exception'?","difficulty":"Hard","answer":"'raise' (no arguments) re-raises current exception in except block. Preserves original traceback. 'raise Exception(message)' raises new exception. Use bare 'raise' when logging then propagating."},{"question":"Can you have multiple except blocks?","difficulty":"Easy","answer":"Yes, to handle different exceptions differently. Order matters: specific exceptions first, general last. Can also catch multiple types together: except (ValueError, TypeError)."},{"question":"What is 'as e' in 'except Exception as e'?","difficulty":"Easy","answer":"'as e' assigns exception object to variable 'e'. Access message: str(e). Access type: type(e). Useful for logging, displaying error details, debugging."},{"question":"Should you catch all exceptions in production code?","difficulty":"Hard","answer":"Generally no. Catch specific expected exceptions. Catching all hides bugs, catches system events (Ctrl+C). If must catch all, log error, maybe re-raise. Let unexpected errors crash for debugging."},{"question":"What's the execution order: try-except-else-finally?","difficulty":"Medium","answer":"No exception: try → else → finally. Exception caught: try (partial) → except → finally. Exception not caught: try (partial) → finally → crash. finally always runs."}],"practice_problems":[{"difficulty":"Beginner","problem":"Write a function that safely converts string to integer, returning None if conversion fails.","hint":"Use try-except with ValueError","solution":"def safe_int(s):\n    try:\n        return int(s)\n    except ValueError:\n        return None\n\n# Test\nprint(safe_int('123'))   # 123\nprint(safe_int('abc'))   # None\nprint(safe_int('12.5'))  # None"},{"difficulty":"Beginner","problem":"Write a divide function that handles division by zero gracefully.","hint":"Catch ZeroDivisionError","solution":"def safe_divide(a, b):\n    try:\n        return a / b\n    except ZeroDivisionError:\n        print(\"Cannot divide by zero\")\n        return None\n\nprint(safe_divide(10, 2))   # 5.0\nprint(safe_divide(10, 0))   # None + message"},{"difficulty":"Intermediate","problem":"Write a function to get user age (0-150) with retry until valid input.","hint":"Loop with try-except, validate range","solution":"def get_age():\n    while True:\n        try:\n            age = int(input(\"Enter age: \"))\n            if age < 0 or age > 150:\n                raise ValueError(\"Age must be 0-150\")\n            return age\n        except ValueError as e:\n            print(f\"Invalid input: {e}\")\n\nage = get_age()\nprint(f\"Valid age: {age}\")"},{"difficulty":"Intermediate","problem":"Create custom exception NegativeValueError and use it to validate square root input.","hint":"Inherit from Exception, check if value < 0","solution":"import math\n\nclass NegativeValueError(Exception):\n    pass\n\ndef safe_sqrt(x):\n    if x < 0:\n        raise NegativeValueError(f\"Cannot take sqrt of negative: {x}\")\n    return math.sqrt(x)\n\ntry:\n    print(safe_sqrt(16))   # 4.0\n    print(safe_sqrt(-4))   # Exception\nexcept NegativeValueError as e:\n    print(f\"Error: {e}\")"},{"difficulty":"Advanced","problem":"Write a retry decorator that retries function on exception up to 3 times.","hint":"Use decorator with loop and exception handling","solution":"import time\n\ndef retry(max_attempts=3, delay=1):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    if attempt < max_attempts - 1:\n                        print(f\"Attempt {attempt + 1} failed, retrying...\")\n                        time.sleep(delay)\n                    else:\n                        print(f\"All {max_attempts} attempts failed\")\n                        raise\n        return wrapper\n    return decorator\n\n@retry(max_attempts=3)\ndef unreliable_function():\n    import random\n    if random.random() < 0.7:\n        raise ConnectionError(\"Connection failed\")\n    return \"Success!\"\n\ntry:\n    result = unreliable_function()\n    print(result)\nexcept ConnectionError:\n    print(\"Operation failed after retries\")"}],"real_world_use_cases":[{"scenario":"User Input Validation","description":"Robust input handling with retry logic","code":"def get_integer_input(prompt, min_val=None, max_val=None, max_attempts=3):\n    \"\"\"Get validated integer input from user\"\"\"\n    for attempt in range(max_attempts):\n        try:\n            value = int(input(prompt))\n            \n            # Validate range\n            if min_val is not None and value < min_val:\n                raise ValueError(f\"Value must be >= {min_val}\")\n            if max_val is not None and value > max_val:\n                raise ValueError(f\"Value must be <= {max_val}\")\n            \n            return value\n            \n        except ValueError as e:\n            if attempt < max_attempts - 1:\n                print(f\"Invalid input: {e}. Try again.\")\n            else:\n                raise ValueError(\"Max attempts exceeded\")\n\n# Usage\ntry:\n    age = get_integer_input(\"Enter age (0-150): \", min_val=0, max_val=150)\n    print(f\"Age entered: {age}\")\nexcept ValueError as e:\n    print(f\"Failed to get input: {e}\")"},{"scenario":"Database Connection Handler","description":"Safe database operations with cleanup","code":"class DatabaseConnection:\n    def __init__(self, db_name):\n        self.db_name = db_name\n        self.connection = None\n    \n    def connect(self):\n        try:\n            # Simulate connection\n            print(f\"Connecting to {self.db_name}...\")\n            # self.connection = database.connect(self.db_name)\n            self.connection = True  # Simulated\n            print(\"Connected successfully\")\n        except Exception as e:\n            print(f\"Connection failed: {e}\")\n            raise\n    \n    def execute_query(self, query):\n        if not self.connection:\n            raise ConnectionError(\"Not connected to database\")\n        \n        try:\n            print(f\"Executing: {query}\")\n            # result = self.connection.execute(query)\n            result = [\"data1\", \"data2\"]  # Simulated\n            return result\n        except Exception as e:\n            print(f\"Query failed: {e}\")\n            raise\n    \n    def close(self):\n        if self.connection:\n            print(\"Closing connection\")\n            self.connection = None\n\n# Usage with try-finally\ndb = DatabaseConnection(\"myapp_db\")\ntry:\n    db.connect()\n    results = db.execute_query(\"SELECT * FROM users\")\n    print(f\"Results: {results}\")\nfinally:\n    db.close()\n    print(\"Cleanup complete\")"},{"scenario":"API Request with Retry","description":"HTTP requests with exponential backoff","code":"import time\nimport random\n\nclass APIError(Exception):\n    \"\"\"Custom API exception\"\"\"\n    pass\n\ndef api_request(endpoint, max_retries=3):\n    \"\"\"Make API request with retry logic\"\"\"\n    \n    for attempt in range(max_retries):\n        try:\n            print(f\"Attempt {attempt + 1}: Requesting {endpoint}\")\n            \n            # Simulate request (randomly fails)\n            if random.random() < 0.5:\n                raise APIError(\"Connection timeout\")\n            \n            # Simulate successful response\n            return {\"status\": \"success\", \"data\": \"result\"}\n            \n        except APIError as e:\n            if attempt < max_retries - 1:\n                # Exponential backoff\n                wait_time = 2 ** attempt\n                print(f\"Request failed: {e}\")\n                print(f\"Retrying in {wait_time}s...\")\n                time.sleep(wait_time)\n            else:\n                print(f\"Max retries reached. Giving up.\")\n                raise\n        except Exception as e:\n            # Unexpected error - don't retry\n            print(f\"Unexpected error: {e}\")\n            raise\n\n# Usage\ntry:\n    response = api_request(\"/api/users\")\n    print(f\"Success: {response}\")\nexcept APIError:\n    print(\"API request failed after retries\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")"},{"scenario":"File Processing with Error Logging","description":"Process multiple files with detailed error tracking","code":"import logging\nfrom pathlib import Path\n\nlogging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')\n\nclass FileProcessingError(Exception):\n    pass\n\ndef process_file(filepath):\n    \"\"\"Process single file with error handling\"\"\"\n    path = Path(filepath)\n    \n    try:\n        # Check file exists\n        if not path.exists():\n            raise FileNotFoundError(f\"File not found: {filepath}\")\n        \n        # Read file\n        logging.info(f\"Processing {filepath}\")\n        content = path.read_text()\n        \n        # Validate content\n        if not content.strip():\n            raise FileProcessingError(f\"File is empty: {filepath}\")\n        \n        # Simulate processing\n        word_count = len(content.split())\n        logging.info(f\"Processed {filepath}: {word_count} words\")\n        \n        return {\"file\": filepath, \"words\": word_count, \"status\": \"success\"}\n        \n    except FileNotFoundError as e:\n        logging.error(str(e))\n        return {\"file\": filepath, \"status\": \"not_found\", \"error\": str(e)}\n    \n    except FileProcessingError as e:\n        logging.error(str(e))\n        return {\"file\": filepath, \"status\": \"empty\", \"error\": str(e)}\n    \n    except Exception as e:\n        logging.error(f\"Unexpected error processing {filepath}: {e}\")\n        return {\"file\": filepath, \"status\": \"error\", \"error\": str(e)}\n\ndef batch_process(files):\n    \"\"\"Process multiple files and generate report\"\"\"\n    results = []\n    \n    for filepath in files:\n        result = process_file(filepath)\n        results.append(result)\n    \n    # Generate summary\n    successful = sum(1 for r in results if r['status'] == 'success')\n    print(f\"\nSummary: {successful}/{len(files)} files processed successfully\")\n    return results\n\n# Create test files\nPath('file1.txt').write_text(\"This is file 1\")\nPath('file2.txt').write_text(\"\")  # Empty file\n\n# Process files\nfiles = ['file1.txt', 'file2.txt', 'file3.txt']\nresults = batch_process(files)\n\nfor result in results:\n    print(result)"}],"exam_notes":["Exception: runtime error that disrupts program flow","try block contains code that might raise exception","except block handles specific exception type","Multiple except blocks for different exception types","except (Type1, Type2) catches multiple types","except Exception as e assigns exception to variable","else clause executes only if try succeeds (no exception)","finally clause ALWAYS executes (cleanup code)","Execution flow: try → except (if error) → else (if success) → finally (always)","raise keyword raises exception: raise ValueError('message')","raise (bare) re-raises current exception","Custom exceptions inherit from Exception class","Order except blocks: specific first, general last","Common exceptions: ValueError, TypeError, FileNotFoundError, ZeroDivisionError","try-except doesn't catch syntax errors (those prevent execution)","Don't use bare except: (catches everything including Ctrl+C)","Use specific exceptions, not except Exception for everything","finally useful for: closing files, releasing resources, cleanup","Best practice: minimal code in try, specific except handlers","Exceptions propagate up call stack if not caught"],"summary":"Exception handling prevents crashes by catching and managing runtime errors gracefully.\n\n**Basic Structure:**\n\n```python\ntry:\n    # Code that might fail\n    risky_operation()\nexcept ExceptionType:\n    # Handle specific error\n    handle_error()\nelse:\n    # Only if try succeeds\n    success_code()\nfinally:\n    # Always executes\n    cleanup_code()\n```\n\n**Execution Flow:**\n\n| Case | try | except | else | finally |\n|------|-----|--------|------|--------|\n| Success | ✓ | ✗ | ✓ | ✓ |\n| Error caught | Partial | ✓ | ✗ | ✓ |\n| Error not caught | Partial | ✗ | ✗ | ✓ then crash |\n\n**Common Exceptions:**\n\n```python\nZeroDivisionError  # 10 / 0\nValueError         # int('abc')\nTypeError          # '5' + 5\nIndexError         # list[999]\nKeyError           # dict['missing']\nFileNotFoundError  # open('missing.txt')\n```\n\n**Multiple Exceptions:**\n\n```python\ntry:\n    code()\nexcept ValueError:\n    # Handle value error\nexcept TypeError:\n    # Handle type error\nexcept Exception as e:\n    # Catch any other\n    print(f\"Error: {e}\")\n```\n\n**When to Use Each:**\n\n- **try**: Wrap risky code\n- **except**: Handle specific errors\n- **else**: Code that runs on success\n- **finally**: Guaranteed cleanup\n\n**Raising Exceptions:**\n\n```python\ndef validate(age):\n    if age < 0:\n        raise ValueError(\"Age cannot be negative\")\n    return age\n\n# Re-raise\ntry:\n    code()\nexcept Exception as e:\n    log(e)\n    raise  # Propagate error\n```\n\n**Custom Exceptions:**\n\n```python\nclass ValidationError(Exception):\n    pass\n\nraise ValidationError(\"Invalid data\")\n```\n\n**Best Practices:**\n\n```python\n# ✅ Specific exceptions\ntry:\n    code()\nexcept ValueError:\n    handle_value_error()\n\n# ❌ Too broad\ntry:\n    code()\nexcept:\n    pass  # Don't do this!\n\n# ✅ Helpful messages\nraise ValueError(f\"Age must be 0-150, got {age}\")\n\n# ✅ Order: specific → general\ntry:\n    code()\nexcept ValueError:  # Specific first\n    pass\nexcept Exception:   # General last\n    pass\n```\n\n**Common Patterns:**\n\n```python\n# Default value\ntry:\n    value = dict[key]\nexcept KeyError:\n    value = default\n\n# Retry logic\nfor attempt in range(3):\n    try:\n        return do_operation()\n    except NetworkError:\n        if attempt < 2:\n            time.sleep(1)\n        else:\n            raise\n\n# Resource cleanup\nfile = open('data.txt')\ntry:\n    process(file)\nfinally:\n    file.close()\n```\n\n**Remember:**\n- Exceptions for errors, not flow control\n- Be specific with exception types\n- Always clean up resources (finally)\n- Provide helpful error messages\n- Don't silence errors (log them!)\n\nMaster exception handling for robust, production-ready code!","order":7},"courseTutorials":[{"slug":"python-introduction","path":"content/python/python-introduction.json","title":"Introduction to Python - Complete Beginner Guide","category":"python","subject":"Python","description":"","order":1},{"slug":"python-virtual-environments","path":"content/python/python-virtual-environments.json","title":"Python Virtual Environments - Complete Guide","category":"python","subject":"Python","description":"","order":2},{"slug":"python-installation","path":"content/python/python-installation.json","title":"Python Installation & Setup - Step-by-Step Guide","category":"python","subject":"Python","description":"","order":3},{"slug":"python-conditionals","path":"content/python/python-conditionals.json","title":"Python Conditional Statements - Complete Guide","category":"python","subject":"Python","description":"","order":4},{"slug":"python-data-types","path":"content/python/python-data-types.json","title":"Python Data Types - Complete Guide","category":"python","subject":"Python","description":"","order":5},{"slug":"python-dictionaries","path":"content/python/python-dictionaries.json","title":"Python Dictionaries - Complete Guide","category":"python","subject":"Python","description":"","order":6},{"slug":"python-exception-handling","path":"content/python/python-exception-handling.json","title":"Python Exception Handling - Complete Guide","category":"python","subject":"Python","description":"","order":7},{"slug":"python-file-handling","path":"content/python/python-file-handling.json","title":"Python File Handling - Complete Guide","category":"python","subject":"Python","description":"","order":8},{"slug":"python-functions","path":"content/python/python-functions.json","title":"Python Functions - Complete Guide","category":"python","subject":"Python","description":"","order":9},{"slug":"python-input-output","path":"content/python/python-input-output.json","title":"Python Input and Output - Complete Guide","category":"python","subject":"Python","description":"","order":10},{"slug":"python-interview-preparation","path":"content/python/python-interview-preparation.json","title":"Python Interview Preparation - Complete Guide","category":"python","subject":"Python","description":"","order":11},{"slug":"python-lists","path":"content/python/python-lists.json","title":"Python Lists - Complete Guide","category":"python","subject":"Python","description":"","order":12},{"slug":"python-loops","path":"content/python/python-loops.json","title":"Python Loops - Complete Guide","category":"python","subject":"Python","description":"","order":13},{"slug":"python-modules-packages","path":"content/python/python-modules-packages.json","title":"Python Modules and Packages - Complete Guide","category":"python","subject":"Python","description":"","order":15},{"slug":"python-oop","path":"content/python/python-oop.json","title":"Python Object-Oriented Programming (OOP) - Complete Guide","category":"python","subject":"Python","description":"","order":16},{"slug":"python-operators","path":"content/python/python-operators.json","title":"Python Operators - Complete Guide","category":"python","subject":"Python","description":"","order":17},{"slug":"python-sets","path":"content/python/python-sets.json","title":"Python Sets - Complete Guide","category":"python","subject":"Python","description":"","order":18},{"slug":"python-strings","path":"content/python/python-strings.json","title":"Python Strings - Complete Guide","category":"python","subject":"Python","description":"","order":19},{"slug":"python-tuples","path":"content/python/python-tuples.json","title":"Python Tuples - Complete Guide","category":"python","subject":"Python","description":"","order":20},{"slug":"python-variables","path":"content/python/python-variables.json","title":"Python Variables - Complete Beginner Guide","category":"python","subject":"Python","description":"","order":21}],"practicePack":null,"prevTutorial":{"slug":"python-dictionaries","title":"Python Dictionaries - Complete Guide"},"nextTutorial":{"slug":"python-file-handling","title":"Python File Handling - Complete Guide"}},"__N_SSG":true}