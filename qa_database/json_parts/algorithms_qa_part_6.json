{
    "dataset": "Algorithms_QA_DB",
    "version": "1.0",
    "generated_for": "LLM_training_and_retrieval",
    "parts": [
        {
            "part_id": "Part_6",
            "questions": [
                {
                    "id": 51,
                    "topic": "Graph Algorithms",
                    "difficulty": "Beginner",
                    "question": "What is a 'Graph' in computer science?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "A set of points called 'Vertices' connected by lines called 'Edges'."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "A graph is a non-linear data structure consisting of a finite set of nodes (vertices) and a set of edges that connect pairs of nodes. It is used to model relationships like social networks, maps, or circuits."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "A tuple G = (V, E), where V is a set of vertices and E is a set of pairs of vertices representing connections."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Data structure defined by a set of nodes and the links between them."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Like a map of cities (nodes) connected by highways (edges)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Set of vertices and edges."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Unlike trees, graphs can have cycles and multiple paths between the same two nodes. Every tree is a graph, but not every graph is a tree."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "It's a way to draw dots and connect them with lines to show how things are related."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Graphs can be further classified as cyclic/acyclic, sparse/dense, and simple/multigraphs depending on their edge properties."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A collection of vertices and edges that connect them."
                        }
                    ]
                },
                {
                    "id": 52,
                    "topic": "Graph Algorithms",
                    "difficulty": "Intermediate",
                    "question": "Compare Adjacency Matrix vs Adjacency List.",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Matrix uses a grid (V x V); List uses an array of lists. Matrix is better for 'dense' graphs, List is better for 'sparse' graphs."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Adjacency Matrix uses O(V^2) space and is fast for edge lookup (O(1)). Adjacency List uses O(V+E) space and is faster for iterating over neighbors. Most real-world graphs (like social networks) are sparse, so Adjacency Lists are more common."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Matrix: O(V^2) space, O(1) edge check. List: O(V+E) space, O(V) edge check. Matrix is preferred for dense graphs where E is close to V^2."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Matrix: Sparse graphs waste space; Dense graphs O(1) lookup. List: Space-efficient for sparse graphs; O(V) lookup."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Matrix is like a full seating chart (even empty seats take up a box). List is like a guest list for each table (only mentions people who are actually there)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Matrix (Dense/Fast lookup) vs List (Sparse/Space-efficient)."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "If you frequently add/remove edges, Matrix is easier. If you perform traversals like BFS/DFS, Adjacency List is far more efficient (O(V+E) vs O(V^2))."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "A matrix is a big spreadsheet. A list is a bunch of small notes. Use the spreadsheet if it's mostly full, the notes if it's mostly empty."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Compact Adjacency Lists (CSR) are often used in high-performance computing to get some of the memory benefits of matrices with the space efficiency of lists."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Alternative mathematical representations for storing topological graph data."
                        }
                    ]
                },
                {
                    "id": 53,
                    "topic": "Graph Algorithms",
                    "difficulty": "Beginner",
                    "question": "What is the difference between Directed and Undirected graphs?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Directed: edges have arrows (one-way). Undirected: edges are two-way lines."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "In an Undirected graph, if there is an edge between A and B, you can go from A to B AND B to A. In a Directed graph (Digraph), an edge (A -> B) only allows travel from A to B."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Undirected: Edges are unordered sets {u, v}. Directed: Edges are ordered pairs (u, v)."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Undirected: symmetric relation. Directed: asymmetric/directional relation."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Directed is like Twitter (you follow them, they might not follow you). Undirected is like Facebook (you are either friends or you aren't)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Ordered edges (Directed) vs Unordered edges (Undirected)."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "A directed graph can be 'Strongly Connected' (path between every pair in both directions) or 'Weakly Connected' (ignoring direction makes it connected)."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Directed is a one-way street. Undirected is a regular street where you can drive both ways."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Connectivity analysis differs: Transitive closure and topological sorting only apply meaningfully to directed graphs."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Categorization of graphs based on the presence or absence of edge orientation."
                        }
                    ]
                },
                {
                    "id": 54,
                    "topic": "Graph Algorithms",
                    "difficulty": "Beginner",
                    "question": "What is a 'Weighted' Graph?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "A graph where every edge has a numerical value (cost, distance, or time)."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "In a weighted graph, each edge is assigned a numerical value called a weight. This 'weight' usually represents a real-world metric like distance, cost, or travel time between two vertices."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "A graph G = (V, E) with a mapping function W: E -> R (real numbers)."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Graph where edges are associated with numerical attributes (weights/costs)."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Like a road map where some roads are 10 miles long and others are 50 miles long. The '10' and '50' are the weights."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Graph with numerical values on edges."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Weighted graphs are the basis for pathfinding algorithms like Dijkstra's or Bellman-Ford, which seek the path with the minimum total weight sum."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "It's a map where some paths are harder or longer than others, so you mark them with numbers."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Weights can be negative in some models (e.g., profit/loss), which requires specific handling (Bellman-Ford) because Dijkstra cannot handle negative edges."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A graph in which a number is assigned to each edge."
                        }
                    ]
                },
                {
                    "id": 55,
                    "topic": "Graph Algorithms",
                    "difficulty": "Intermediate",
                    "question": "Explain 'Breadth-First Search' (BFS).",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Visiting all neighbors first, then neighbors of neighbors, using a queue."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "BFS is a graph traversal algorithm that explores all nodes at the current depth before moving to the next level. It uses a Queue and a 'visited' array to avoid infinite loops. It is guaranteed to find the shortest path in an unweighted graph."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "A layer-by-layer traversal with O(V+E) time. Uses a FIFO queue: enqueue start, mark visited, then repetitively dequeue, explore neighbors, and enqueue unvisited ones."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Level-by-level traversal; uses adjacency list and a queue. O(V+E)."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Like a ripple in a pond: it spreads out evenly in all directions, reaching everything at distance 1, then everything at distance 2."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Queue-based level-order exploration."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "BFS is excellent for finding the minimum number of edges between two nodes. Its space complexity is O(V) in the worst case (e.g., a star graph)."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Explore everyone you can reach in one step, then everyone they can reach, and so on."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "BFS can be modified (0-1 BFS) for graphs where edge weights are only 0 or 1, using a deque instead of a simple queue."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "An algorithm for traversing or searching tree or graph data structures by exploring all neighbor nodes at the present depth prior to moving on to nodes at the next depth level."
                        }
                    ]
                },
                {
                    "id": 56,
                    "topic": "Graph Algorithms",
                    "difficulty": "Intermediate",
                    "question": "Explain 'Depth-First Search' (DFS).",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Going as far as possible down one path before back-tracking, using a stack or recursion."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "DFS is a graph traversal algorithm that follows one branch as deep as possible before backtracking to explore other branches. It uses a Stack (recursive or explicit) and a visited array. It's often used for cycle detection and topological sorting."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "A recursive or stack-based traversal with O(V+E) time. It explores along each branch until it hits a terminal or visited node, then backtracks."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Path-based traversal using recursion/stack. O(V+E)."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Like exploring a maze: you walk into one path until you hit a wall, then trace your steps back until you find another turn."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Stack-based deep exploration."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "DFS consumes less memory in very 'wide' but 'shallow' graphs compared to BFS. It also generates edge classifications like 'Tree Edges', 'Back Edges', and 'Cross Edges'."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Pick a direction and keep goings until you can't go further, then come back and try the other turns you missed."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "DFS is the basis for Tarjan's and Kosaraju's algorithms for finding strongly connected components (SCCs)."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "An algorithm for traversing or searching tree or graph data structures which starts at the root and explores as far as possible along each branch before backtracking."
                        }
                    ]
                },
                {
                    "id": 57,
                    "topic": "Graph Algorithms",
                    "difficulty": "Intermediate",
                    "question": "When should you use BFS over DFS?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Use BFS for shortest paths in unweighted graphs; use DFS for puzzles or exploring all paths."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Use BFS if you need the shortest path (fewest edges) between two nodes. Use DFS if the target is likely deep in the tree or if you need to perform topological sorting, cycle detection, or find connected components."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "BFS: Shortest path, unweighted distances, bipartite checking. DFS: Connectivity, cycle detection, strongly connected components, Maze solving."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "BFS for optimality/distance; DFS for connectivity/topology."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "BFS is like a search party. DFS is like a scout who runs ahead to see how far the mountain goes."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "BFS for shortest path; DFS for exhaustive structure exploration."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "BFS requires more memory for 'wide' graphs because the queue grows with the 'frontal wave' of visited nodes. DFS can be memory-heavy for very 'deep' graphs due to recursion depth."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "If you want to find the nearest exit, use BFS. If you want to see if there is any way out at all, DFS is usually fine."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "In large state spaces (like chess AI), IDDFS (Iterative Deepening DFS) is used to combine the space benefits of DFS with the optimality of BFS."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Heuristic selection criteria between breadth-first and depth-first traversal strategies."
                        }
                    ]
                },
                {
                    "id": 58,
                    "topic": "Graph Algorithms",
                    "difficulty": "Intermediate",
                    "question": "Why is the complexity of BFS/DFS O(V + E)?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Because you visit every node (V) once and check every edge (E) once."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "In both algorithms, every vertex is enqueued/visited exactly once, contributing O(V). For each vertex, we iterate through its adjacency list. Summing up the sizes of all adjacency lists for all vertices gives twice the number of edges (for undirected) or exactly E (for directed), hence O(V + E)."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Summation logic: Σ(deg(v)) = 2E. Total work = V insertions + Σ(work per node), yielding linear complexity O(V + E)."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Linear runtime; visits all vertices and examines all edges once."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Like checking a network: it takes time to walk to each room (V) and extra time to check every wire (E) connected to those rooms."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Linear traverse of all vertices and edges."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Note that if using an Adjacency Matrix, the complexity becomes O(V^2) because for every node, you must scan a whole row of size V to find neighbors."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "The time depends on the total count of 'circles' and 'lines' in your graph."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Space complexity also accounts for O(V) to store the visited states and the queue/stack data structures."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Big O analysis of graph traversals based on vertex and edge counts."
                        }
                    ]
                },
                {
                    "id": 59,
                    "topic": "Graph Algorithms",
                    "difficulty": "Intermediate",
                    "question": "How do you detect a cycle in a Directed Graph?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Use DFS and check if your path ever hits a node that is currently in your 'active' stack."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "A cycle exists in a directed graph if and only if a 'Back Edge' is found during DFS. This is tracked by maintaining a 'recursion stack' (or using a 3-color scheme: white/unvisited, gray/active, black/fully-explored)."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Cycle detection via DFS: If an edge points to a node that has been discovered but not yet finished (Active in recursion stack), a cycle is present."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Occurrence of back-edges during Depth First Search."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Like following a trail: if you see a sign that says 'You are already here', but the trail keeps going, you're in a loop."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Identify back-edges during DFS traversal."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "For Undirected graphs, the rule is simpler: if you hit a visited node that isn't the direct parent, there is a cycle. For Directed, hitting 'any' visited node isn't enough; it must be in the current path."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Keep a list of 'visited but not finished' nodes. If a path leads back to one of them, it's a loop."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Kahn’s Algorithm (for topological sorting) can also detect cycles; if the final sorted list has fewer nodes than the graph, a cycle exists."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Checking for the existence of at least one path that starts and ends at the same vertex."
                        }
                    ]
                },
                {
                    "id": 60,
                    "topic": "Graph Algorithms",
                    "difficulty": "Intermediate",
                    "question": "What is a 'Connected Component'?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "A group of nodes where you can get to any node in the group from any other node."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "A connected component is a sub-graph in which every pair of nodes is connected by a path. In an undirected graph, finding them is simple using BFS or DFS; any node not reached in one pass belongs to a different component."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "A maximal subgraph such that any two vertices are reachable from each other. Identified by iterating and starting traversal from unvisited nodes."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Subsets of vertices where paths exist between all members."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Like 'islands' in an ocean. Each island is a connected component where you can walk anywhere, but you can't walk from one island to another."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "A maximal path-connected subgraph."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "In Directed graphs, we distinguish between Weakly Connected Components (ignoring arrows) and Strongly Connected Components (arrows strictly followed)."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "It's just a bunch of nodes that are all linked together. If there are gaps in the graph, it has multiple components."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Connected components are used in social network analysis to find 'cliques' or 'isolated groups'."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph."
                        }
                    ]
                }
            ]
        }
    ]
}