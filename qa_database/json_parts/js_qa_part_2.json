{
    "dataset": "JavaScript_QA_DB",
    "version": "1.0",
    "generated_for": "LLM_training_and_retrieval",
    "parts": [
        {
            "part_id": "Part_2",
            "questions": [
                {
                    "id": 11,
                    "topic": "Execution Context",
                    "difficulty": "Advanced",
                    "question": "What are the three core components of a JavaScript Execution Context?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Variables, Scope, and 'this'."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "1. **Variable Environment** (where variables live). 2. **Scope Chain** (reference to outer environments). 3. **The `this` Binding** (reference to the context object)."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "LexicalEnvironment (Identifier Resolution), VariableEnvironment (var/function declarations), and ThisBinding."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Variable Environment, Scope Chain, this."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like a toolkit for a job: Materials (Variables), Map to the store (Scope), and the Workbench user manual (this)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Variables, Scope Chain, `this`."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "The context is created in two phases: Creation (scanning for declarations) and Execution (assigning values)."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "It remembers your variables, who your parent is, and who called you."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "In ES6 specs, 'Variable Object' was replaced by Lexical Environments, but the concept remains the same."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "An execution context contains the Code Evaluation State, Function, Realm, and Lexical Environment."
                        }
                    ]
                },
                {
                    "id": 12,
                    "topic": "Hoisting",
                    "difficulty": "Intermediate",
                    "question": "How does `Hoisting` affect Function Declarations differently than Function Expressions?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Declarations move to the top and can be used immediately. Expressions behave like variables."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Function Declarations (`function foo() {}`) are fully hoisted, meaning they can be called before they are defined in the code. Function Expressions (`var foo = function() {}`) have their variable declaration hoisted (as undefined), but the assignment happens at runtime, so calling them early throws a TypeError."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Declarations are hoisted with their body. Expressions are variable assignments; only the identifier is hoisted (if var) or TDZ'd (if let/const)."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Declarations are fully hoisted. Expressions are not."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Declaration is like a VIP on the guest list (ready at the door). Expression is like a guest who arrives late; the bouncer knows their name but they aren't there yet."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Declarations = fully usable; Expressions = undefined until assigned."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "This is why `myFunc()` works at line 1 even if defined at line 100, but `myVarFunc()` crashes."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "You can use a normal function before you write it. You can't do that with a function inside a variable."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Class declarations are NOT hoisted (unlike functions), behaving more like `let`."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Function declarations are hoisted with their implementation. Function expressions hoist only the variable declaration."
                        }
                    ]
                },
                {
                    "id": 13,
                    "topic": "Scope",
                    "difficulty": "Intermediate",
                    "question": "What is 'Lexical Scope'?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "It means a function looks for variables where it was written, not where it was called."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Lexical Scope (or Static Scope) means that a function's scope is determined by its physical location in the source code at **author time**. Nested functions have access to variables declared in their outer scope."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Scope is determined by token location during the compilation/lexing phase. It is static and does not change at runtime."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Scope determined by code placement."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like inheritance in a house. If you are born in the kitchen, you can see the kitchen stuff, regardless of where you walk later."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Scope defined by author-time code structure."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "This contrasts with 'Dynamic Scope' (used in Bash/Perl), where scope depends on the call stack."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "A child function can see the parent's variables because it is written inside the parent."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "`eval()` and `with` can cheat lexical scope at runtime, but are discouraged/banned in strict mode."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "The scope of a variable is defined by its position in the source code."
                        }
                    ]
                },
                {
                    "id": 14,
                    "topic": "Closures",
                    "difficulty": "Intermediate",
                    "question": "What is a Closure in JavaScript?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "A function that remembers variables from outside itself."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "A closure is a function bundled together with its lexical environment. Usage: It allows an inner function to access variables from an outer function that has already returned (finished executing)."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "A persistent reference to the VariableEnvironment of a parent execution context, preventing it from being garbage collected."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Inner function accessing outer function's scope."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It looks like a backpack. The function carries a backpack containing all the variables that were present when it was born."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "A function remembering its creation scope."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Closures enable data privacy (emulating private methods) and functional patterns like currying."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "When a function leaves home, it takes a suitcase of memories (variables) with it."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Every function in JS is technically a closure, but it's only observable when the function is executed outside its definition scope."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "The combination of a function and the lexical environment within which that function was declared."
                        }
                    ]
                },
                {
                    "id": 15,
                    "topic": "Internal Mechanics",
                    "difficulty": "Advanced",
                    "question": "What is the 'Temporal Dead Zone' (TDZ)?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "The time where a variable exists but you can't touch it yet without crashing."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "The TDZ is the period between the start of a block and the line where a `let` or `const` variable is declared. Accessing the variable during this time throws a `ReferenceError`, unlike `var` which would be `undefined`."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "State of a variable that is hoisted but uninitialized. It persists until the JS engine evaluates the declaration statement."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Time between block start and variable declaration."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like a reserved table at a restaurant. The sign is there (variable exists), but you can't sit (use it) until the waiter opens it."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Zone where `let`/`const` are hoisted but inaccessible."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "TDZ prevents subtle bugs where usage precedes declaration, enforcing cleaner coding patterns."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "You cannot use a `let` variable before the line of code that creates it."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "`typeof i` triggers a ReferenceError in the TDZ, whereas for a purely undeclared variable it returns 'undefined'."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "The region of a scope where a variable is bound but cannot be accessed."
                        }
                    ]
                },
                {
                    "id": 16,
                    "topic": "Event Loop",
                    "difficulty": "Advanced",
                    "question": "How does the 'Event Loop' handle `setTimeout` vs `Promise` callbacks locally?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Promises run first. Timeouts run second."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "They go to different queues. `setTimeout` goes to the **Task Queue (Macrotask)**. Promises go to the **Microtask Queue**. The Event Loop prioritizes the Microtask Queue, processing ALL microtasks before moving to the next Macrotask."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Microtask Queue (Job Queue) > Macrotask Queue (Callback Queue). The engine drains the Microtask Queue completely after every stack frame."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Promises (Microtasks) have higher priority than Timeouts (Macrotasks)."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Macrotask is the regular line at the bank. Microtask is the VIP line. The teller empties the VIP line first."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Microtasks (Promises) flush before Macrotasks."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "This means a recursive Promise loop can block the Event Loop/UI rendering, whereas a recursive setTimeout will typically yield."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Promise code cuts in line in front of Timeout code."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "`queueMicrotask()` allows you to manually schedule a microtask."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Microtasks are executed immediately after the current script and before any new macrotask."
                        }
                    ]
                },
                {
                    "id": 17,
                    "topic": "Internal Mechanics",
                    "difficulty": "Intermediate",
                    "question": "Why is JavaScript considered 'Single-Threaded'?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "It can only do one task at a time."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "JS has a single Call Stack, meaning it can only execute one piece of code at any given instant. It handles concurrency via the Event Loop and asynchronous Web APIs, giving the illusion of multi-threading."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "It runs on a single main thread for the heap and call stack. It does not perform parallel execution of its own code logic (excluding Web Workers)."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "It has only one Call Stack."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It represents a one-lane highway. You can't pass the car in front of you."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "One Call Stack; one instruction at a time."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "This design avoids complex thread synchronization issues (deadlocks) but necessitates async programming for long tasks."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "It has one brain. It works on one problem until it's done, then picks up the next."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "This 'thread' is often shared with Browser UI rendering, so heavy JS blocks screen updates."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "JavaScript has a single call stack and executes code sequentially."
                        }
                    ]
                },
                {
                    "id": 18,
                    "topic": "Call Stack",
                    "difficulty": "Intermediate",
                    "question": "What causes a 'Maximum call stack size exceeded' error?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "An infinite loop of functions calling themselves."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "This is a Stack Overflow. It occurs when there is uncontrolled recursion (a function calling itself without an exit condition), filling the Call Stack memory limit."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Infinite Recursion pushes stack frames until the stack limit (browser dependent, e.g., 10k frames) is reached."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Uncontrolled recursion."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Like stacking plates endlessly. Eventually, the pile gets too high and falls over."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Infinite recursion."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Also happens with mutually recursive functions (A calls B, B calls A)."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "A function called itself too many times and ran out of memory."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Trampolining is a technique to avoid this by flattening recursion into a loop."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Expected stack frame limit reached due to deep or infinite recursion."
                        }
                    ]
                },
                {
                    "id": 19,
                    "topic": "Scope",
                    "difficulty": "Intermediate",
                    "question": "Why does `for (var i=0; i<3; i++) { setTimeout(()=>log(i), 100) }` log `3, 3, 3`?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Because `var` makes `i` shared, so it ends up being 3 for everyone."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Because `var` is function-scoped (or global). The variable `i` is shared across all iterations. By the time the `setTimeout` callbacks run, the loop has finished, and `i` has incremented to 3."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Closure over a single shared variable reference. Loop execution completes synchronously before the async macrotasks run. `let` fixes this by creating a new block binding per iteration."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Var has function scope, so the reference to i is shared."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like writing a number on a whiteboard. You change it 1, 2, 3. Later, 3 people look at the whiteboard. They all see 3."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Closure captures the variable reference, not value; loop ends first."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "This is the classic closure interview question. The fix is `let i` or an IIFE `(function(j){...})(i)`."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "The timeout happens later. By then, the loop is finished and 'i' is sitting at the number 3."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "This demonstrates the difference between capturing by reference (JS default) vs value."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "The callbacks close over the same variable environment where i is defined."
                        }
                    ]
                },
                {
                    "id": 20,
                    "topic": "Internal Mechanics",
                    "difficulty": "Advanced",
                    "question": "What happens during the 'Creation Phase' of an Execution Context?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "The engine gets memory ready for variables and functions."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "The engine scans the code for variable and function declarations. Memory is allocated. Variables (`var`) are set to `undefined`. Functions are stored in memory in their entirety. The `this` value and Scope Chain are determined."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Environment Record creation. 1. Bind 'this'. 2. Create LexicalEnvironment. 3. Create VariableEnvironment. Hoisting occurs here."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Memory allocation and Hoisting."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's setting the table before dinner. You put out the plates (memory spots) before serving the food (values)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Memory allocation, Hoisting, and `this` binding."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Code is not executed yet. This phase is why hoisting exists."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "The computer reads through your list of variables and reserves space for them."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Arguments object is also initialized during this phase."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "The JavaScript engine creates the Variable Object, Scope Chain, and sets the value of 'this'."
                        }
                    ]
                }
            ]
        }
    ]
}