{
    "dataset": "cpp_QA_DB",
    "version": "1.0",
    "generated_for": "LLM_training_and_retrieval",
    "parts": [
        {
            "part_id": "Part_5",
            "questions": [
                {
                    "id": 41,
                    "topic": "Advanced Concepts",
                    "difficulty": "Advanced",
                    "question": "What is 'Move Semantics'?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Move semantics is a way to 'steal' data from a temporary object rather than making a slow copy. It's like moving contents from one box to another instead of buying a new box and cloning everything inside."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Move semantics allows the transfer of resources (like heap memory) from one object to another without copying. It uses 'RValue References' (`&&`) and `std::move`. This significantly optimizes performance, especially for objects like `std::vector` or `std::string` that manage large amounts of memory."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Optimization technique that exploits the distinction between LValues and RValues. When an object is moved, its internal pointers are copied to the target, and the source object's pointers are set to `nullptr` to prevent double deletion. It's facilitated by the Move Constructor and Move Assignment operator."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "A C++11 feature that enables the transfer of resources between objects, eliminating unnecessary deep copies through the use of RValue references."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like 'Changing ownership of a folder'. Instead of copying 1000 files from Folder A to Folder B (Copy), you just change the name on the folder from 'A' to 'B' (Move). The files stay put, only the label changes."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Resource transfer instead of resource duplication."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "`std::move` doesn't actually move anything; it just casts an LValue to an RValue to 'opt-in' to move semantics. For move semantics to work, the source object must be left in a 'valid but unspecified state', meaning it can be safely destroyed but its contents are gone."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "It's what makes modern C++ so fast. It ensures that when you return a big list from a function, the computer doesn't waste time making a copy of that list."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Move semantics is the foundation of 'Move-Only' types like `std::unique_ptr`. These types cannot be copied (preventing logic errors) but can be moved (allowing flexibility in ownership)."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "The mechanism of transferring content of an object to another without copying it."
                        }
                    ]
                },
                {
                    "id": 42,
                    "topic": "Advanced Concepts",
                    "difficulty": "Advanced",
                    "question": "What are 'Lambdas' in C++?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Lambdas are 'Anonymous Functions'—functions you can write right in the middle of your code without giving them a name."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Lambdas (introduced in C++11) are locally defined function objects. They consist of a capture clause `[]`, parameters `()`, and a body `{}`. They are often used for quick operations passed to STL algorithms like `std::sort` or `std::for_each`."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Syntactic sugar for creating a 'Functor' (a class with an overloaded `operator()`). The 'Capture Clause' specifies which variables from the surrounding scope are available inside the lambda, either by value `[=]` or by reference `[&]`."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "An unnamed function defined at the point of its use, supporting closure property by capturing variables from the local scope."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like a 'Disposable Camera'. You don't need to go through the process of setting up a professional photo studio (defining a named function). You just take the quick shot you need right there and throw it away when done."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Inline, anonymous function objects."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Under the hood, the compiler generates a unique class for every lambda. This is why lambdas can be faster than function pointers—the compiler can easily inline the calls because the type is known perfectly at compile time."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "If you just need a small bit of code to run once inside a loop, use a Lambda. It saves you from having to jump around your file to find where the function was hidden."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "C++14 introduced 'Generic Lambdas' using `auto` as a parameter type, and C++20 allowed lambdas to be 'Template Lambdas' with explicit template parameters, increasing their power for generic programming."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A function that you can write inline in your source code, and use as an argument to another function."
                        }
                    ]
                },
                {
                    "id": 43,
                    "topic": "Advanced Concepts",
                    "difficulty": "Advanced",
                    "question": "What is 'Perfect Forwarding'?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Perfect forwarding is a way to pass an argument through a function and keep its 'identity' (whether it was a temporary object or a permanent one) exactly as it was."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Perfect forwarding allows a template to pass along its arguments to another function while preserving their LValue/RValue and `const` properties. It's achieved using 'Universal References' (`T&&`) and `std::forward<T>`."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "A technique to solve the forwarding problem in templates. Without `std::forward`, an RValue reference parameter becomes an LValue inside the function body (because it has a name), which breaks move semantics. `std::forward` restores the original value category."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "A mechanism in C++ templates that preserves the value category of arguments when passing them to another function."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like a 'Certified Mail Service'. Most mail gets opened and handled (converted to LValue). Perfect forwarding ensures the package arrives at the final destination 'uopened' and exactly in the same condition it was sent."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Preserving value categories during argument passing in templates."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "This relies on 'Reference Collapsing' rules: `& + &&` becomes `&`, and `&& + &&` becomes `&&`. This is why the syntax `T&&` in a template can act as either an LValue or RValue reference depending on the type passed in."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "You'll mostly see this inside very advanced libraries. It's the 'Plumbing' that makes sure smart pointers and containers work efficiently without you ever knowing it."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Perfect forwarding is critical for 'Variadic Templates'—functions that take any number of arguments, like `std::make_shared`. It ensures that every one of those arguments is passed to the constructor as efficiently as possible."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "The ability of a function template to forward its arguments to another function while keeping their exact types and value categories."
                        }
                    ]
                },
                {
                    "id": 44,
                    "topic": "Advanced Concepts",
                    "difficulty": "Advanced",
                    "question": "What is 'SFINAE' (Substitution Failure Is Not An Error)?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "SFINAE is a rule that tells the compiler: 'If you try to use a template and it doesn't work for this specific type, don't crash the whole program. Just quietly try a different template instead.'"
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "SFINAE is a principle in C++ where the compiler ignores a template specialization if substituting a type into it fails during template argument deduction. This allows for 'Template Metaprogramming' where you can enable or disable functions based on what the type can do (e.g., check if a type has a `.sort()` method)."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Deduction rule. If a substitution errors out, that candidate is simply removed from the overload set. This is often used with `std::enable_if` to implement 'Type Trait' based polymorphism at compile time."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "A compiler rule where failing to substitute a template parameter does not result in a compilation error, but instead removes that particular template from the list of viable candidates."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like a 'Job Recruitment' process. If a candidate doesn't meet the requirements for one job opening, the HR department doesn't shut down the whole company—they just move on to the next candidate on the pile."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Silently discarding unsuitable template candidates during deduction."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "SFINAE is notoriously difficult to read and debug. It results in very cryptic compiler errors if all templates fail substitution. Modern C++ (C++20) has introduced 'Concepts' as a cleaner and more readable alternative to SFINAE."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "This is very advanced stuff. It's basically how the computer makes smart decisions about which specialized version of a function to use for your specific data."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "`void_t` is a common pattern used in SFINAE to check for the existence of types or member functions in a concise way, often used for building introspection systems at compile-time."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A feature of C++ template deduction that specifies that failing to substitute a template parameter does not by itself cause a compilation error."
                        }
                    ]
                },
                {
                    "id": 45,
                    "topic": "Advanced Concepts",
                    "difficulty": "Advanced",
                    "question": "What is 'Static Polymorphism'?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Static polymorphism is like having 'Many Forms' but the decision of which form to use is made while the program is being built (compiled), not while it's running."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Static polymorphism refers to features like templates, function overloading, and CRTP (Curiously Recurring Template Pattern) where polymorphic behavior is resolved at compile time. This is much faster than dynamic polymorphism (`virtual` functions) because there is no VTable lookup overhead."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Resolved at compile-time via function overloading or template instantiation. CRTP is the most advanced form, where a base class is templated on its derived class, allowing the base to call derived methods without `virtual` overhead."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Polymorphism implemented through templates and overloading, resolved before the execution of the program."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Dynamic polymorphism is like a 'DJ' at a club changing the song based on the crowd (Runtime). Static polymorphism is like a 'Pre-recorded CD' where the mix is already decided before the party starts (Compile-time)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Compile-time resolution of polymorphic calls."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "The main trade-off of static polymorphism is 'Code Bloat'. The compiler generates a new version of the code for every type used. However, this allows the compiler to perform aggressive inlining, making it significantly faster for high-performance systems."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Templates are the most common way you'll use this. They let you write code that 'adapts' to whatever you give it, but it does all the adapting before you hit the play button."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Modern C++ Concepts (C++20) make static polymorphism much safer by allowing you to define 'requirements' for types (e.g., 'must be printable') that the compiler can easily check and provide clear error messages for."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A form of polymorphism that occurs when multiple functions with the same name are present, but their signatures are different, or through templates."
                        }
                    ]
                },
                {
                    "id": 46,
                    "topic": "Advanced Concepts",
                    "difficulty": "Advanced",
                    "question": "What is the 'Curiously Recurring Template Pattern' (CRTP)?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "CRTP is a weird but cool trick where a child class inherits from a parent that is 'templated' on the child itself. It's like a parent knowing exactly who its child is before the child is even finished being born."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "CRTP is a pattern where a class `Derived` inherits from a template base class `Base<Derived>`. This allows the base class to access and call methods of the derived class at compile time, enabling static polymorphism without the cost of virtual functions."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Implementation: `class Derived : public Base<Derived>`. The Base class uses `static_cast<T*>(this)` to access the derived members. It is used to add functionality to a class without using dynamic dispatch."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "A design pattern in C++ where a class inherits from a base class that uses the derived class as a template parameter."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like a 'Self-Learning Prototype'. The base class is a general plan that says 'I will work with whoever is being built right now', and the child adds its own custom flair that the base immediately adopts."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Static polymorphism via inheritance and templates."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "CRTP is widely used in high-performance libraries like Eigen for linear algebra or WTL for UI. It allows 'Mix-in' functionality and ensures that the compiler can inline the derived calls, which standard `virtual` functions cannot easily do."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Think of it as the ultimate speed hack for inheritance. It makes your code run faster by doing all the 'connecting' work during the build process."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "A common use for CRTP is 'Static Interface' enforcement. You can write a base class that defines a skeleton for an algorithm, and the derived class fills in the steps. The compiler will check to make sure the steps are actually there."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "An idiom in C++ in which a class X derives from a class template instantiation using X itself as template argument."
                        }
                    ]
                },
                {
                    "id": 47,
                    "topic": "Advanced Concepts",
                    "difficulty": "Advanced",
                    "question": "What are 'Type Traits'?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Type traits are like 'Questions' you can ask the compiler about a data type, such as 'Is this an integer?' or 'Can this type be copied?'."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Type traits (found in `<type_traits>`) are template-based structures that provide information about types at compile time. They are used in template metaprogramming to enable different code paths based on the properties of a type (e.g., `std::is_pointer`, `std::is_const`)."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Compile-time metadata about types. They use template specialization to return values (usually `true` or `false` via `::value`) or types (via `::type`). They are the building blocks of SFINAE logic."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "A group of templates that provide information about the properties of types at compile time."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like an 'Ingredient Inspector'. Before you start cooking, you ask 'Is this gluten-free?' or 'is this a liquid?'. Based on the answer, you use aDifferent pot or cooking method."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Compile-time interrogation of type properties."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Since C++17, you can use the `_v` and `_t` suffixes (e.g., `std::is_integral_v<int>`) to access the results more concisely. Type traits allow for 'Tag Dispatching', which can select specific optimized versions of an algorithm for POD (Plain Old Data) types."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "They help you write smart code that changes its behavior depending on what kind of variable you give it."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "`std::decay` is a particularly powerful trait that removes `const` and `volatile` qualifiers and converts arrays/functions to pointers, which is essential when building generic wrappers like `std::function`."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "The mechanism that allows C++ programmers to probe properties of types at compile time."
                        }
                    ]
                },
                {
                    "id": 48,
                    "topic": "Advanced Concepts",
                    "difficulty": "Advanced",
                    "question": "What is `std::any`, `std::variant`, and `std::optional`?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "They are modern 'Safety Containers'. `optional` is for values that might not exist, `variant` is for a value that is one of several types, and `any` can literally hold anything."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "These are C++17 'Vocabulary Types' for safer programming. `std::optional` represents a value or nothing. `std::variant` is a type-safe 'Union' that holds one of a selection of types. `std::any` is a type-safe container for a single value of any type."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "1. `optional<T>`: Replaces `nullptr` for single values. 2. `variant<A, B>`: Knows which type it holds; access via `std::get` or `std::visit`. 3. `any`: Uses dynamic allocation and RTTI to hold and check any object type."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Standard library types introduced in C++17 to provide safer alternatives to pointers, unions, and void pointers respectively."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "`optional` is a 'Gift Box' (might be empty). `variant` is a 'Transformer' (it can be a car OR a robot, but not both at once). `any` is a 'Black Hole' (you can throw anything in, but you need to know what it was to get it back out)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Modern, type-safe alternatives for empty or varied data."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "`std::variant` is particularly powerful for state machines. It prevents the memory overhead of inheritance-based polymorphism and the safety risks of C-style unions. `std::any` should be used sparingly as it requires heap allocation and is harder for the compiler to optimize."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Use `std::optional` if you have a function that might fail to return a name. It's much better than returning an empty string or throwing an error every single time."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "`std::visit` is the companion for `std::variant`, providing a compile-time 'exhaustive' switch-like mechanism that ensures you handle every possible type the variant could be holding."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A set of container-like types used to represent values with varying degrees of certainty or type flexibility."
                        }
                    ]
                },
                {
                    "id": 49,
                    "topic": "Advanced Concepts",
                    "difficulty": "Advanced",
                    "question": "What is 'Memory Alignment'?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Memory alignment is the requirement that data should be stored at addresses that are multiples of certain numbers (like 4 or 8). It's like parking a car perfectly within the lines so the CPU can 'get in' faster."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Memory alignment refers to how data is arranged in RAM. CPUs process data in 'words'. If a 4-byte integer is at an address that isn't a multiple of 4, the CPU might need two memory reads instead of one, causing a performance hit or a crash on some architectures."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Restriction that objects must reside at specific memory offsets. Compilers inject 'Padding' into structs to ensure members are aligned with their natural requirements. C++11 introduced `alignas` and `alignof` to control and query this."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "The requirement for certain types of data to be placed in memory at addresses that are multiple of their size."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like a 'Bookshelf'. If your books are 4-inches wide, and you try to place one overlapping the edge of a shelf, it might fall or look messy. It works best if you line them up perfectly with the marks on the shelf."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Addressing data at specific byte boundaries for CPU efficiency."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "The order of members in a `struct` matters for alignment. A `struct` with a `char`, then an `int`, then another `char` will be larger than one with an `int` followed by two `char`s, because of the padding needed to keep the `int` aligned."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "You don't usually have to worry about this, but understanding it explains why some objects are slightly larger in memory than the sum of their 'parts'."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "SIMD (Single Instruction, Multiple Data) instructions often have very strict 16-byte or 32-byte alignment requirements. Failing to align your data properly when using these instruction sets can lead to 'Bus Errors' and instant program termination."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "The restriction of an object's memory address to a multiple of its size or a specific value."
                        }
                    ]
                },
                {
                    "id": 50,
                    "topic": "Advanced Concepts",
                    "difficulty": "Advanced",
                    "question": "What is the `constexpr` keyword?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "`constexpr` is a promise that a value or the result of a function can be calculated while the program is still being compiled, instead of waiting until it's running."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "`constexpr` (introduced in C++11) allows the programmer to specify that a value or function is a constant expression. This means the evaluation can happen at compile-time, allowing the result to be used where a constant is required (like array sizes or template arguments) and improving runtime performance."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Specifies that the value of an object or a function can be determined at compile time. A `constexpr` function must be simple enough for the compiler to execute. C++14/17/20 have greatly expanded what is allowed inside a `constexpr` block (loops, `if`, etc.)."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "A keyword that declares that the value of a variable or the return of a function is a constant expression that can be evaluated during compilation."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like 'Pre-calculating a math problem'. Instead of making the student do `2 + 2` on the test (Runtime), the teacher just writes `4` on the paper (Compile-time)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Enforcing compile-time evaluation for better performance."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Difference between `const` and `constexpr`: `const` promises you won't change the value, but that value might only be known at runtime (e.g., from user input). `constexpr` requires the value to be known at compile time."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "It's a great tool for making your program start up faster. If you can calculate things before the user even opens the app, why not do it?"
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "In C++20, `consteval` was added to force compile-time evaluation (making it an error if the compiler can't do it), and `constinit` was added to ensure a variable is initialized at compile-time to avoid the 'Static Initialization Order Fiasco'."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A keyword used to indicate that the evaluation of a variable or function can be performed at compile-time."
                        }
                    ]
                }
            ]
        }
    ]
}