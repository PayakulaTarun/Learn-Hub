{
    "dataset": "angular_QA_DB",
    "version": "1.0",
    "generated_for": "LLM_training_and_retrieval",
    "parts": [
        {
            "part_id": "Part_3",
            "questions": [
                {
                    "id": 21,
                    "topic": "Syntax & Core Features",
                    "difficulty": "Intermediate",
                    "question": "What are 'Pipes' in Angular?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Pipes are tools in the template that let you format data before showing it to the user (like turning 'apple' into 'APPLE')."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Pipes are simple functions to use in template expressions to accept an input value and return a transformed value. Examples include 'uppercase', 'date', and 'currency'."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Classes decorated with @Pipe that implement the PipeTransform interface. They use the pipe operator (|) in the template."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Template transformation tools; categories include Pure and Impure pipes."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "A pipe is like a filter on a camera. The scenery (data) stays the same, but the filter changes how it looks in the photo (the UI)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Template expressions for data transformation."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Angular evaluates pipes during every change detection cycle. Pure pipes are only re-evaluated when their input primitive or object reference changes, while impure pipes are re-evaluated on every change detection."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "They are little commands you can add to your text to make it look nice, like formatting a date or adding a dollar sign."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "The 'async' pipe is a specialized pipe that automatically subscribes to an Observable or Promise and returns the latest value, handling cleanup to prevent memory leaks."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A way to transform and format data directly in HTML templates."
                        }
                    ]
                },
                {
                    "id": 22,
                    "topic": "Syntax & Core Features",
                    "difficulty": "Intermediate",
                    "question": "Explain 'Pure' vs 'Impure' Pipes.",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Pure pipes only run when the input value itself changes. Impure pipes run every time Angular checks for changes anywhere."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Pure pipes are called only when a change to the input value is detected (for primitives) or when the object reference changes. Impure pipes are called on every change detection cycle, regardless of input changes, making them more resource-intensive."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Pure: default choice, optimization based on immutability. Impure: set 'pure: false' in metadata; needed for tracking changes inside objects or arrays that aren't immutably updated."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Pure (input/reference change only); Impure (every change detection cycle)."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "A pure pipe is like a lazy student who only re-does a problem if the numbers change. An impure pipe is like an overachiever who re-does the problem every time the teacher walks by, even if nothing changed."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Reference-change-only (Pure) vs Every-cycle (Impure) transformation."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Because pipes are often used with large datasets, the performance difference is massive. Impure pipes should be avoided unless absolutely necessary (like the 'json' pipe or for filtering arrays without immutability)."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Pure pipes are smart and fast because they save work. Impure pipes are 'always-on' and can slow down your app if you aren't careful."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "The AsyncPipe is the most prominent impure pipe, as it must constanty check for new values in an asynchronous stream that doesn't necessarily change the observable reference."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Categories of Angular pipes distinguished by their re-evaluation frequency relative to the change detection process."
                        }
                    ]
                },
                {
                    "id": 23,
                    "topic": "Syntax & Core Features",
                    "difficulty": "Intermediate",
                    "question": "How do components communicate using '@Input()' and '@Output()'?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "@Input lets a parent component send data down to a child. @Output lets a child send an event back up to the parent."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "@Input is a decorator used to define property binding for child components, allowing them to receive data. @Output is used with EventEmitter to create custom events that notify the parent when an action occurs in the child."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Unidirectional data flow enhancers. @Input() enables property binding on the child element. @Output() combined with EventEmitter provides an observable-like event stream for parents to subscribe to."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "@Input: Parent-to-child data. @Output with EventEmitter: Child-to-parent event notification."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "@Input is like a parent giving a child an allowance (sending things down). @Output is like the child screaming 'I'm hungry!' to get the parent's attention (sending things up)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Downward data binding (@Input) vs Upward event emission (@Output)."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "This pattern establishes a strict hierarchy. If you need data shared across distant branches of the component tree, services are better suited than 'prop drilling' through many levels of inputs and outputs."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Use Input when the child needs to know something. Use Output when the child needs to say something happened, like a button click."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Inputs can also be transformed using 'setter' functions, which is useful for triggering logic whenever the input data changes without using life cycle hooks."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Decorators defining the interface for data exchange between parent and child components."
                        }
                    ]
                },
                {
                    "id": 24,
                    "topic": "Syntax & Core Features",
                    "difficulty": "Intermediate",
                    "question": "Explain 'ngOnInit'.",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "It's a function that runs exactly once after Angular has finished setting up the component and its inputs."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "ngOnInit is a lifecycle hook called after Angular has initialized all data-bound properties of a directive. It's the best place for initialization logic, like fetching data from a server."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Called once after the first ngOnChanges(). It signals that the component's input properties are resolved and available for use."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Initialization lifecycle hook; follows constructor and ngOnChanges; runs once."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "The constructor is like being born. ngOnInit is like your first day of schoolâ€”it's when you actually start doing your work and using the things your parents gave you."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Post-initialization lifecycle hook for component setup."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "You should use ngOnInit rather than the constructor for data fetching because at the constructor stage, the component might not have received its inputs from the parent yet."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "The perfect place to put your code if you want it to run as soon as the component appears on the screen."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "While common, overly large ngOnInit methods can make components hard to test; complex logic should be delegated to services."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A lifecycle hook that is called after Angular has initialized all data-bound properties."
                        }
                    ]
                },
                {
                    "id": 25,
                    "topic": "Syntax & Core Features",
                    "difficulty": "Advanced",
                    "question": "What is '@ViewChild'?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "It is a way to get a reference to an element or a child component inside your own template so you can control it from the TypeScript file."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "@ViewChild is a decorator used to gain access to a child component, directive, or a DOM element from its parent component class. It's often used to call methods on a child directly."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "A parameter decorator that configures a view query. The change detector looks for the first element or the directive matching the selector in the view DOM."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Accessing a single component/element from the view DOM; results available in ngAfterViewInit."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like having a remote control for a toy. Even though the toy (child component) has its own batteries and logic, you (the parent) can press a button to make it beep."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Decorator for accessing child elements/components in a template."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "The query results are not available until the view has been initialized (ngAfterViewInit). You can set '{static: true}' to resolve it during ngOnInit if the element is not inside a structural directive."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Instead of using ID or classes like jQuery, you use this to 'grab' a part of your webpage so you can play with it in your code."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "@ViewChild returns a ElementRef for DOM elements or the component instance for child components. It can also be configured to return a TemplateRef for ng-templates."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A decorator that identifies a child component or element within the view of a component."
                        }
                    ]
                },
                {
                    "id": 26,
                    "topic": "Syntax & Core Features",
                    "difficulty": "Intermediate",
                    "question": "What are 'Services' in Angular?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Services are classes that hold shared logic, data, or tasks (like talking to a server) that can be reused across many components."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Services are an broad category of objects that encapsulate logic which is not related specifically to a view. They are typically used for data sharing, business logic, and making API calls, and are injected into components via DI."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "@Injectable classes designed for modularity and the Single Responsibility Principle. They allow components to focus on displaying data while delegating complex tasks like HTTP to the service layer."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Classes for modular shared logic; decorated with @Injectable."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "A service is like a utility company (like electricity or water). Many houses (components) in a neighborhood use the same utility, so the power lines are shared instead of every house building its own power plant."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Reusable classes for logic and data management injected into components."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "By default, services provided in 'root' are singletons, meaning there is only one instance of the service for the entire application, making it a reliable way to maintain state across different parts of the app."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Think of a service as a 'worker' that does a specific job for any part of your app that asks for it."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Services can be scoped to specific modules or components, allowing for ephemeral state that is destroyed when the provider's lifecycle ends."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A class with a well-defined purpose that is injected into components to share logic or data."
                        }
                    ]
                },
                {
                    "id": 27,
                    "topic": "Syntax & Core Features",
                    "difficulty": "Intermediate",
                    "question": "Explain '@HostListener'.",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "It is a decorator that lets you listen for events (like a click) on the actual tag your component or directive is attached to."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "@HostListener is a decorator that declares a DOM event to listen for and provides a handler method to run when that event occurs on the host element."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "A decorator used to handle events on the host element of a directive or component. It provides a declarative way to attach event listeners without manual addEventListener calls."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Event listener decorator for host elements."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like having a sensor on your front door. You don't have to watch for arrivals; the sensor (HostListener) just pings you the moment somebody touches the door."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Decorator to listen for events on the component's host element."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "It can capture events like 'window:resize' or 'document:click' in addition to local host events. It automatically handles cleanup when the component is destroyed."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "A way to tell Angular: 'Run this function whenever someone clicks on me (the element).'"
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "HostListener supports event capturing and window/document level events through special syntax like '(window:scroll)', allowing for sophisticated interaction tracking without side effects."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A decorator that declares a DOM event to listen for on the host element."
                        }
                    ]
                },
                {
                    "id": 28,
                    "topic": "Syntax & Core Features",
                    "difficulty": "Intermediate",
                    "question": "Explain '@HostBinding'.",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "It lets you bind a property (like a CSS class or an attribute) to the tag that your component or directive belongs to."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "@HostBinding is a decorator used to set a property of the host element. For example, you can use it to dynamically change the host element's background color or class list based on a state in your class."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "A decorator that marks a class property as a host-binding property and supplies configuration metadata. It allows for setting properties on the host element declaratively."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Decorator for setting properties on the host element."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like a person changing their clothes based on the weather. If it starts raining (state change), the person (host element) automatically puts on a jacket (a CSS class)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "A decorator that binds a class property to a property of the host element."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "It replaces the need to inject Renderer2 or ElementRef when simply trying to update the styles or classes of the host, leading to cleaner and more testable code."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "A way to change how the outside of your component looks depending on what's happening inside."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "HostBinding can target style, class, and attribute bindings directly, such as `@HostBinding('style.transform')` or `@HostBinding('attr.aria-label')`."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A decorator that binds a property of the host element to a class member."
                        }
                    ]
                },
                {
                    "id": 29,
                    "topic": "Syntax & Core Features",
                    "difficulty": "Intermediate",
                    "question": "What is 'Transclusion' (Content Projection)?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "It's a way to insert external HTML content into a specific spot within a component's template."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Content projection is the process of projecting content from a parent component into a child component's template using the <ng-content> tag. It allows for more flexible and reusable components."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "A pattern in which a component 'slots' external content into its template. It helps in creating wrapper components like cards or modals."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Using <ng-content> to project content from parent to child."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Think of a photo frame. The frame (component) is always the same, but you can project any photo (the content) into the empty space in the middle."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Injecting external HTML into a component's template via <ng-content>."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "You can have multiple projection points by using the 'select' attribute on <ng-content>, allowing for more advanced layouts where different pieces of content go to different designated slots."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "It lets you put some HTML inside your component tag, and that HTML will show up in a special spot you chose."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Content projection is handled during the view construction phase and the projected content is managed by the parent's lifecycle hooks, not the child's."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A technique to insert content into a specific location within a component's template."
                        }
                    ]
                },
                {
                    "id": 30,
                    "topic": "Syntax & Core Features",
                    "difficulty": "Advanced",
                    "question": "Compare '@ViewChild' vs '@ContentChild'.",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "ViewChild finds things in your own template. ContentChild finds things that were projected into your template from the outside."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "@ViewChild queries elements within the component's own template. @ContentChild queries elements that are projected into the component via <ng-content>."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "ViewChild refers to a 'View Query' and results are available in ngAfterViewInit. ContentChild refers to a 'Content Query' and results are available in ngAfterContentInit."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "ViewChild (own template); ContentChild (projected content)."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "ViewChild is like looking for something in your own pockets. ContentChild is like looking for something you told a guest to bring and put into a container you provided."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Accessing internal template items (View) vs projected items (Content)."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "@ContentChild is specifically for components that use transclusion. If you want to interact with a component instance that a user put inside your tags, you must use @ContentChild."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "One looks at your own HTML, the other looks at the HTML other people sent into your component."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Both can use 'static: true' for early resolution if the query results are not dependent on runtime structural logic."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Decorators that identify a component or element within the view or content-projected area."
                        }
                    ]
                }
            ]
        }
    ]
}