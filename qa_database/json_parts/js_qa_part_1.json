{
    "dataset": "JavaScript_QA_DB",
    "version": "1.0",
    "generated_for": "LLM_training_and_retrieval",
    "parts": [
        {
            "part_id": "Part_1",
            "questions": [
                {
                    "id": 1,
                    "topic": "Introduction",
                    "difficulty": "Beginner",
                    "question": "What is the primary distinction between Client-side and Server-side JavaScript?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "Client-side runs in the browser. Server-side runs on a computer/server."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Client-side JS runs in the user's web browser, handling UI interactions and DOM access. Server-side JS (like Node.js) runs on a backend server, handling file systems, databases, and API requests."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Execution Environment. Client-side executes in a browser runtime (Window global), limited by sandbox. Server-side executes in a server runtime (e.g., Node/Deno), granting access to FS, OS, and Networking modules."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Client-side runs in the browser; Server-side runs on the server."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Client-side is the waiter taking your order (User Interface). Server-side is the chef in the kitchen cooking (Backend Logic)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Browser vs Server execution environments."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Historically, JS was only client-side. Node.js (V8 outside browser) enabled server-side execution. They share syntax but have different APIs (DOM vs `fs`/`http`)."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "One works on your computer inside Chrome. The other works on a big computer on the internet."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Isomorphic (Universal) JS is code written to run on both sides (e.g., Next.js rendering)."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "Client-side scripts run in the browser's JavaScript engine. Server-side scripts run in a server-side runtime environment."
                        }
                    ]
                },
                {
                    "id": 2,
                    "topic": "Variables",
                    "difficulty": "Intermediate",
                    "question": "What is the key functional difference between `var` and `let` regarding scope?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "`var` works inside the whole function. `let` works only inside the block `{}`."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "`var` is function-scoped (or globally scoped if defined outside a function). `let` is block-scoped (confined to the nearest curly braces `{}`). Additionally, `var` is hoisted and initialized as `undefined`, while `let` is hoisted but stays in the Temporal Dead Zone (TDZ)."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "`var`: Function scope, Hoist-initialized (`undefined`), redeclarable. `let`: Block scope, Hoist-uninitialized (TDZ), not redeclarable in the same scope."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Var is function-scoped; Let is block-scoped."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "`var` leaks out of `if` statements like water through a net. `let` is a watertight container."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Function Scope (`var`) vs Block Scope (`let`)."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Before ES6, JS only had function scope. `let` was introduced to fix common closure bugs in loops (e.g., `for` loops sharing the same `i` variable in callbacks)."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Use `let` most of the time. `var` is the old way and can cause bugs by being visible where you don't expect it."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "`var` on the global scope creates a property on the `window` object. `let` does not."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "var variables are scoped to the function or global scope. let variables are scoped to the immediate enclosing block."
                        }
                    ]
                },
                {
                    "id": 3,
                    "topic": "Variables",
                    "difficulty": "Intermediate",
                    "question": "Can the contents of a variable declared with `const` be changed? Explain.",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "You can't change the variable itself, but if it's an object, you can change the stuff inside it."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "Yes, if the value is mutable (like an Object or Array). `const` prevents *reassignment* of the variable identifier to a new reference, but it does not make the referenced object immutable. You can modify properties or push items to an array."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "`const` ensures immutability of the *binding*, not the *value*. For primitives, this effectively makes the value immutable. For reference types, the memory address is constant, but the heap data can change."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "Yes, if it is an object or array (reference type)."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Think of `const` as a leash tied to a dog. You can't switch to a different dog (reassign), but the dog itself can change positions or get a haircut (mutate)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Yes, for objects/arrays; No for primitives."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "To make an object truly immutable, you need `Object.freeze()`, not just `const`. `const o = {}; o.a = 1;` is valid."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "You can't say `x = somethingElse`, but you can say `x.name = 'Bob'`."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "In functional programming, true immutability is preferred using libraries like Immutable.js, as `const` offers a false sense of security."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "const prevents reassignment of the variable, but does not ensure deep immutability of reference types."
                        }
                    ]
                },
                {
                    "id": 4,
                    "topic": "Data Types",
                    "difficulty": "Intermediate",
                    "question": "What is the historical bug associated with `typeof null` in JavaScript?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "It says it's an 'object', but it should be 'null'. "
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "`typeof null` returns `'object'`. This is a known bug from the first implementation of JavaScript (related to type tags in C) that was never fixed to avoid breaking legacy web pages."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Returns `'object'`. In original JS engine (v1), values were 32-bit units with type tags. The null pointer (`0x00`) overlapped with the object type tag (`000`), causing the mistaken classification."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "It returns 'object'."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It's like labelling an empty box as 'Box' instead of 'Empty'."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "`typeof null === 'object'`."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Because of this, you should always check for null using `val === null` specifically, never `typeof`."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "JS makes a mistake and calls 'null' an object. It's just something you have to remember."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "There was a proposal to fix this (typeof null === 'null'), but it was rejected because it broke too many existing sites."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "typeof null evaluates to 'object', typically considered a language design error."
                        }
                    ]
                },
                {
                    "id": 5,
                    "topic": "Data Types",
                    "difficulty": "Beginner",
                    "question": "List the primitive data types in JavaScript.",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "String, Number, Boolean, Undefined, Null, Symbol, BigInt."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "There are 7 primitives: String, Number, BigInt, Boolean, Undefined, Null, and Symbol. Everything else (Arrays, Functions) is an Object."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Primitive values are immutable and have no methods: String, Number, BigInt, Boolean, Undefined, Null, Symbol."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "String, Number, Boolean, Null, Undefined, Symbol, BigInt."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Primitives are the atoms (Gold, Oxygen). Objects are molecules built from atoms."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Str, Num, Bool, Null, Undef, Sym, BigInt."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Primitives are passed by value. Objects are passed by reference."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Text, Numbers, True/False, Empty checks (null/undefined)."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "`Symbol` was added in ES6 for unique keys. `BigInt` was added recently for huge integers."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "A primitive (primitive value, primitive data type) is data that is not an object and has no methods."
                        }
                    ]
                },
                {
                    "id": 6,
                    "topic": "Operators",
                    "difficulty": "Beginner",
                    "question": "What is the output of `5 == '5'` versus `5 === '5'`?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "First is true, second is false."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "`5 == '5'` is `true` because loose equality performs Type Coercion (converts string to number). `5 === '5'` is `false` because strict equality checks both Value and Type, and Number !== String."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "`==` triggers abstract equality comparison alg (Coercion). `===` triggers strict equality comparison alg (No Coercion)."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "True and False."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "`==` asks 'Do these look alike?'. `===` asks 'Are these identical twins?'."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "True (Coercion) vs False (Type Mismatch)."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Always use `===` to prevent unpredicted bugs. `==` logic is complex (e.g., `[] == 0` is true)."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Double equals ignores the type (text vs number). Triple equals cares about the type."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "There is also `Object.is(5, '5')` which behaves like `===` but handles NaN and -0 differently."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "== allows for type coercion. === requires both components to be of the same type and value."
                        }
                    ]
                },
                {
                    "id": 7,
                    "topic": "Operators",
                    "difficulty": "Intermediate",
                    "question": "What is the result of `'5' + 3` versus `'5' - 3`?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "'53' and 2."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "`'5' + 3` results in `'53'` (string) because the `+` operator favors string concatenation if one operand is a string. `'5' - 3` results in `2` (number) because `-` is strictly a mathematical operator, so it coerces the string to a number."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "`+` is overloaded (Addition/Concatenation). String wins. `-` is number-only. String coerces to Number."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "'53' and 2."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "Plus is glue (sticks text). Minus is math (subtracts numbers)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Concatenation ('53') vs Subtraction (2)."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "This behavior is the source of the 'Wat' talk meme. It highlights implicit coercion risks."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "Adding text keeps it as text. Subtracting text turns it into a number."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "If the subtraction failed (e.g. `'Hello' - 3`), the result would be `NaN`."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "+ performs concatenation if a string is present. - performs arithmetic subtraction."
                        }
                    ]
                },
                {
                    "id": 8,
                    "topic": "Syntax",
                    "difficulty": "Beginner",
                    "question": "Is `myVariable` the same as `MyVariable` in JavaScript? Why?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "No, they are different because capital letters matter."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "No. JavaScript is case-sensitive. Identifiers with different casing are treated as completely distinct variables."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "No. Direct string match on ASCII/Unicode identifiers fails. JS parsers respect case."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "No, JS is case-sensitive."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "'God' vs 'god'. One is a specific name, the other is a general noun. Case changes meaning."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "No, distinct identifiers."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "Conventionally, camelCase is used for variables (`myVar`) and PascalCase for Classes (`MyClass`)."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "The computer sees them as totally different names."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "HTML attributes are often case-insensitive, but JS variables interacting with them are strict."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "No, JavaScript identifiers are case-sensitive."
                        }
                    ]
                },
                {
                    "id": 9,
                    "topic": "Conditionals",
                    "difficulty": "Intermediate",
                    "question": "Which of the following values is NOT Falsy: `0`, `''`, `null`, `undefined`, `{}`, `false`?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "{}"
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "`{}` (Empty Object) is Truthy. All objects (even empty ones) are truthy in JavaScript. The others (`0`, `''`, `null`, `undefined`, `false`) are the standard falsy values."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "`{}` coerces to `true` in Boolean context. Falsy set: `false`, `0`, `''`, `null`, `undefined`, `NaN`."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "{}"
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "An empty box `{}` is still a real physical box (True). 'Nothingness' (null) is no box (False)."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "The empty object `{}` is truthy."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "`[]` (empty array) is also truthy. This is a common bug in conditionals checking for data existence."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "The curley braces. Even though it's empty, it exists."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "`document.all` is a weird falsy object in legacy browsers, but generally objects are truthy."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "An empty object {} is a truthy value."
                        }
                    ]
                },
                {
                    "id": 10,
                    "topic": "Conditionals",
                    "difficulty": "Intermediate",
                    "question": "How does the `switch` statement compare cases?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "simple",
                            "answer": "It checks if they are exactly the same type and value."
                        },
                        {
                            "variant_id": 2,
                            "style": "interview",
                            "answer": "`switch` uses Strict Comparison (`===`). It will not coerce types. If you switch on string `'1'` and case is number `1`, it will fail."
                        },
                        {
                            "variant_id": 3,
                            "style": "technical",
                            "answer": "Strict Equality Algorithm (`===`). No type conversion occurs."
                        },
                        {
                            "variant_id": 4,
                            "style": "exam",
                            "answer": "It uses strict equality (===)."
                        },
                        {
                            "variant_id": 5,
                            "style": "analogy",
                            "answer": "It matches ID cards exactly. A photocopy (coerced value) is rejected."
                        },
                        {
                            "variant_id": 6,
                            "style": "one_liner",
                            "answer": "Strict equality (`===`)."
                        },
                        {
                            "variant_id": 7,
                            "style": "deep_explanation",
                            "answer": "To do flexible matching, some devs do `switch(true)` and use expressions in cases, but that's controversial style."
                        },
                        {
                            "variant_id": 8,
                            "style": "beginner_friendly",
                            "answer": "It is very strict. The number 5 is not the same as the text \"5\"."
                        },
                        {
                            "variant_id": 9,
                            "style": "advanced",
                            "answer": "Because it's `===`, switching on objects requires the exact same reference, not deep equality."
                        },
                        {
                            "variant_id": 10,
                            "style": "strict_definition",
                            "answer": "The switch statement uses strict comparison (===)."
                        }
                    ]
                }
            ]
        }
    ]
}