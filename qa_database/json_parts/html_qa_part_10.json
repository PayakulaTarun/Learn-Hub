{
    "dataset": "HTML_QA_DB",
    "version": "1.0",
    "generated_for": "LLM_training_and_retrieval",
    "parts": [
        {
            "part_id": "Part_10",
            "questions": [
                {
                    "id": 91,
                    "topic": "Native Modals",
                    "difficulty": "Advanced",
                    "question": "What is the specific advantage of the `<dialog>` element over a traditional `<div>` modal?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "one_liner",
                            "answer": "It provides a native Top Layer implementation (z-index independent) and built-in accessibility (Focus Trapping, Escape key handling) via `.showModal()`."
                        },
                        {
                            "variant_id": 2,
                            "style": "strict_definition",
                            "answer": "The `<dialog>` element represents a dialog box or other interactive component. When opened via `.showModal()`, the browser places it in the 'Top Layer', rendering it above all other z-index contexts. It also creates an inert background (`::backdrop`) and enforces focus trapping."
                        },
                        {
                            "variant_id": 3,
                            "style": "beginner_friendly",
                            "answer": "Making a popup with `div` is hard—you have to write code to gray out the background and stop clicks. `<dialog>` does all that mostly for free. It just floats on top of everything automatically."
                        },
                        {
                            "variant_id": 4,
                            "style": "intermediate",
                            "answer": "The JS API `.showModal()` is the key. `.show()` opens it like a div (modeless). `.showModal()` acts like a true popup (modal), preventing interaction with the rest of the page via the `inert` mechanism."
                        },
                        {
                            "variant_id": 5,
                            "style": "advanced",
                            "answer": "Top Layer Context: No matter where the `<dialog>` is nested in the DOM (even inside `overflow: hidden` divs), `.showModal()` breaks it out to the viewport top layer. This solves the classic 'Clipping' issue where tooltips/modals get cut off by parent containers."
                        },
                        {
                            "variant_id": 6,
                            "style": "analogy",
                            "answer": "Div Modal is building a treehouse (Modal) inside your yard. Dialog is putting a satellite in orbit. It sits above the entire neighborhood (Page)."
                        },
                        {
                            "variant_id": 7,
                            "style": "step_by_step",
                            "answer": "1. HTML: `<dialog id='d'>`. 2. JS: `d.showModal()`. 3. Result: Top Layer, Backdrop, Focus Trap. 4. JS: `d.close()`. 5. Result: Clean removal."
                        },
                        {
                            "variant_id": 8,
                            "style": "interview",
                            "answer": "The `<dialog>` element solves z-index wars and stacking context issues by utilizing the Top Layer API. It natively handles accessibility requirements like Focus Management and 'Escape' to close, which typically require hundreds of lines of JS library code."
                        },
                        {
                            "variant_id": 9,
                            "style": "student_style",
                            "answer": "It's a built-in popup tag. You open it with JS and it automatically blocks the background."
                        },
                        {
                            "variant_id": 10,
                            "style": "deep_explanation",
                            "answer": "The `<dialog>` element is the semantic interface to the User Agent's native modal controller. Invoking `showModal()` promotes the element to a specialized rendering layer (Top Layer), distinct from the Document Flow, and applies the `::backdrop` pseudo-element. This inherently solves occlusion and accessibility focus-cycle problems."
                        }
                    ]
                },
                {
                    "id": 92,
                    "topic": "Interaction States",
                    "difficulty": "Advanced",
                    "question": "What does the `inert` global attribute do?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "one_liner",
                            "answer": "It completely disables a DOM subtree—removing it from the accessibility tree and blocking all mouse/keyboard events (click, focus, select)."
                        },
                        {
                            "variant_id": 2,
                            "style": "strict_definition",
                            "answer": "The `inert` attribute is a boolean attribute that indicates that the element and all its descendants are to be made non-interactive. It maps to `aria-hidden='true'` and sets `tabindex='-1'` effectively on the entire subtree."
                        },
                        {
                            "variant_id": 3,
                            "style": "beginner_friendly",
                            "answer": "It freezes a section of the page. It's like putting a sheet of glass over a part of your site—you can see it, but you can't click, type, or tab into it."
                        },
                        {
                            "variant_id": 4,
                            "style": "intermediate",
                            "answer": "Useful for performance and Modals. When a modal opens, you can apply `inert` to the main `root` container. This instantly traps focus in the modal without complex JS loops, because the rest of the app is 'inert'."
                        },
                        {
                            "variant_id": 5,
                            "style": "advanced",
                            "answer": "It is stronger than `pointer-events: none` because it also kills Keyboard focus and Text Selection. It removes the subtree from the Accessibility Tree. Browsers optimize styling/hit-testing for inert/hidden subtrees."
                        },
                        {
                            "variant_id": 6,
                            "style": "analogy",
                            "answer": "It's Carbonite freezing (Star Wars). The element is there, but it is effectively dead to interaction."
                        },
                        {
                            "variant_id": 7,
                            "style": "step_by_step",
                            "answer": "1. Open Modal. 2. Set `<div id='app' inert>`. 3. User tabs. 4. Focus skips 'app' completely. 5. Focus cycles in Modal."
                        },
                        {
                            "variant_id": 8,
                            "style": "interview",
                            "answer": "The `inert` attribute allows us to programmatically disable interactivity for large DOM sections. It is a game-changer for accessibility patterns like Focus Trapping, as we can simply make the 'background' content `inert` rather than manually managing tabindex for thousands of nodes."
                        },
                        {
                            "variant_id": 9,
                            "style": "student_style",
                            "answer": "It turns off the HTML. You can't click or tab to anything inside an inert tag."
                        },
                        {
                            "variant_id": 10,
                            "style": "deep_explanation",
                            "answer": "Attributes like `disabled` only apply to form controls. The `inert` attribute applies the 'disabled' concept to generic DOM nodes. It directs the User Agent to ignore the node for hit-testing, focus events, and text selection, while instructing the Accessibility API to mark the entire branch as unavailable."
                        }
                    ]
                },
                {
                    "id": 93,
                    "topic": "Mobile UX",
                    "difficulty": "Intermediate",
                    "question": "How does `enterkeyhint` improve Mobile UX?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "one_liner",
                            "answer": "It changes the label/icon of the 'Enter' key on virtual keyboards (e.g., 'Go', 'Search', 'Send') to match the user's intent."
                        },
                        {
                            "variant_id": 2,
                            "style": "strict_definition",
                            "answer": "The `enterkeyhint` global attribute defines the action label (or icon) to present for the enter key on virtual keyboards. Values include: `enter`, `done`, `go`, `next`, `previous`, `search`, `send`."
                        },
                        {
                            "variant_id": 3,
                            "style": "beginner_friendly",
                            "answer": "On your phone keyboard, the blue button usually says 'Go'. But if you are in a chat app, you want it to say 'Send'. This code lets you change that button's text."
                        },
                        {
                            "variant_id": 4,
                            "style": "intermediate",
                            "answer": "Use `enterkeyhint='search'` for search bars (shows Magnifying Glass). Use `enterkeyhint='next'` for multi-step forms. It acts as a visual cue for what pressing Enter will actually do."
                        },
                        {
                            "variant_id": 5,
                            "style": "advanced",
                            "answer": "It does not change the event (`keycode` is still 13/Enter). It is purely a UI hint for the OS-level Virtual Keyboard (IME). Properly setting this increases conversion/usability by reducing cognitive friction."
                        },
                        {
                            "variant_id": 6,
                            "style": "analogy",
                            "answer": "It's changing the label on a Door. Instead of just 'Push', it says 'Exit' or 'Enter Party'. Same action (push), clearer context."
                        },
                        {
                            "variant_id": 7,
                            "style": "step_by_step",
                            "answer": "1. Input is Search Bar. 2. Add `enterkeyhint='search'`. 3. Open on iPhone. 4. Keyboard shows blue 'Search' button."
                        },
                        {
                            "variant_id": 8,
                            "style": "interview",
                            "answer": "`enterkeyhint` customizes the virtual keyboard's submit action. I use it to provide context-appropriate labels like 'Search' or 'Send', which is a subtle but impactful UX detail for mobile web apps."
                        },
                        {
                            "variant_id": 9,
                            "style": "student_style",
                            "answer": "It changes the enter button text on phones. Like changing it to 'Send' for messages."
                        },
                        {
                            "variant_id": 10,
                            "style": "deep_explanation",
                            "answer": "The `enterkeyhint` attribute interfaces with the device's Input Method Editor (IME). By hinting the expected interaction outcome (`send`, `go`), the Application interacts with the OS layer to render a more context-aware soft keyboard."
                        }
                    ]
                },
                {
                    "id": 94,
                    "topic": "Performance Optimization",
                    "difficulty": "Intermediate",
                    "question": "What is native lazy loading and how is it implemented?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "one_liner",
                            "answer": "Adding `loading='lazy'` to `<img>` or `<iframe>` tags defers loading until the user scrolls near them."
                        },
                        {
                            "variant_id": 2,
                            "style": "strict_definition",
                            "answer": "Native lazy loading is triggered by the `loading` attribute. `loading='lazy'` defers the fetch of the resource until it reaches a calculated distance-from-viewport threshold. `loading='eager'` loads it immediately (default)."
                        },
                        {
                            "variant_id": 3,
                            "style": "beginner_friendly",
                            "answer": "If you have 100 photos on a page, you don't want to download all of them instantly. Lazy loading means the browser waits until you scroll down intended to see the photo before downloading it."
                        },
                        {
                            "variant_id": 4,
                            "style": "intermediate",
                            "answer": "Modern browsers handle the Intersection logic internally, saving you from writing JS observers. IMPORTANT: Always include `width` and `height` attributes on lazy images to prevent Layout Shifts (CLS) when they finally load."
                        },
                        {
                            "variant_id": 5,
                            "style": "advanced",
                            "answer": "Thresholds are browser-defined (often dynamic based on network speed). Chrome might load 'lazy' images 1200px ahead on fast WiFi, but only 200px ahead on 3G. Do NOT lazy load 'above the fold' images (LCP penalty)."
                        },
                        {
                            "variant_id": 6,
                            "style": "analogy",
                            "answer": "Standard loading is ordering 50 pizzas at once. Lazy loading is telling the waiter 'Bring the next pizza only when I finish this slice'."
                        },
                        {
                            "variant_id": 7,
                            "style": "step_by_step",
                            "answer": "1. Identify images below fold. 2. Add `loading='lazy'`. 3. Add `width/height`. 4. Browser monitors scroll position. 5. Fetches just-in-time."
                        },
                        {
                            "variant_id": 8,
                            "style": "interview",
                            "answer": "We use `loading='lazy'` for off-screen assets to reduce initial payload and Time to Interactive. Crucially, I avoid it for hero images to prevent delaying the Largest Contentful Paint (LCP)."
                        },
                        {
                            "variant_id": 9,
                            "style": "student_style",
                            "answer": "It makes images load only when you scroll to them. Just write `loading='lazy'`."
                        },
                        {
                            "variant_id": 10,
                            "style": "deep_explanation",
                            "answer": "The `loading` attribute offloads the visibility-checking logic from JavaScript (IntersectionObserver) to the browser's internal layout engine. This is more performant as it runs off the main thread. It applies to Images and Iframes, significantly reducing initial byte-weight and memory footprint."
                        }
                    ]
                },
                {
                    "id": 95,
                    "topic": "Input UI",
                    "difficulty": "Intermediate",
                    "question": "What is the difference between `inputmode` and `type` for numeric inputs?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "one_liner",
                            "answer": "`type` determines semantic validation and UI (e.g., up/down spinners); `inputmode` specifically tells the virtual keyboard which layout to show (e.g., number pad)."
                        },
                        {
                            "variant_id": 2,
                            "style": "strict_definition",
                            "answer": "`type='number'`: Semantic number input (often implies validation, steppers). `inputmode='numeric'`: Hint to the UA to display a numeric input keyboard. They are orthogonal: you can have `type='text'` with `inputmode='numeric'` (useful for Credit Cards)."
                        },
                        {
                            "variant_id": 3,
                            "style": "beginner_friendly",
                            "answer": "`type='number'` puts those little up/down arrows on the box. `inputmode='numeric'` just makes sures the Big Number Buttons show up on your phone keyboard instead of letters."
                        },
                        {
                            "variant_id": 4,
                            "style": "intermediate",
                            "answer": "Common issue: `type='number'` can fail for things like credit cards (strips leading zeores, scientific notation `e`). Practice: Use `type='text'` + `inputmode='numeric'` + `pattern='\d*'` for Credit Cards / Zip Codes to get the numpad without the weird number logic."
                        },
                        {
                            "variant_id": 5,
                            "style": "advanced",
                            "answer": "Modes: `decimal` (adds period), `tel` (adds * and #), `numeric` (0-9). `email`, `url`, `search` are also inputmodes. `inputmode` gives granular control over the IME (Input Method Editor) without forcing strict HTML validation rules (like `min/max`)."
                        },
                        {
                            "variant_id": 6,
                            "style": "analogy",
                            "answer": "`type` is the Form Police rules (Must be a number!). `inputmode` is the Keyboard appearance (Show me numbers!)."
                        },
                        {
                            "variant_id": 7,
                            "style": "step_by_step",
                            "answer": "1. Need Credit Card? 2. `type='number'`? No (Format issues). 3. `type='text'`. 4. Users need Numpad. 5. Add `inputmode='numeric'`."
                        },
                        {
                            "variant_id": 8,
                            "style": "interview",
                            "answer": "`type` affects validation and browser widgets (spinners). `inputmode` affects the virtual keyboard layout. For IDs (like Credit Cards) that are technically strings of digits but not mathematical numbers, `inputmode='numeric'` on a text field is the correct approach."
                        },
                        {
                            "variant_id": 9,
                            "style": "student_style",
                            "answer": "Inputmode sets the keyboard style. Type sets the data type. Sometimes you want a text box but with a number keyboard."
                        },
                        {
                            "variant_id": 10,
                            "style": "deep_explanation",
                            "answer": "The `inputmode` global attribute provides a hint about the type of data that might be entered by the user while editing the element or its contents. This allows a user agent to select an appropriate input method (e.g., showing a keypad) without enforcing the rigid constraint validation associated with `type` attributes (e.g., `type='number'` disallowing standard formatting)."
                        }
                    ]
                },
                {
                    "id": 96,
                    "topic": "Internationalization",
                    "difficulty": "Advanced",
                    "question": "What is the specific use case for `<bdi>` (Bi-Directional Isolation)?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "one_liner",
                            "answer": "It restricts the directionality of its content (e.g., Arabic text) from affecting the surrounding text direction."
                        },
                        {
                            "variant_id": 2,
                            "style": "strict_definition",
                            "answer": "The `<bdi>` element isolates a span of text that might be formatted in a different direction from other text outside it. It prevents the Bidi algorithm from bleeding directionality changes into the parent context."
                        },
                        {
                            "variant_id": 3,
                            "style": "beginner_friendly",
                            "answer": "If you have a list of names, and one is 'Alice' (Left-to-Right) and one is 'Ahmed' (Right-to-Left), the 'Ahmed' text might flip the layout of the 'Alice' text next to it. `<bdi>` puts 'Ahmed' in a bubble so he doesn't mess up Alice."
                        },
                        {
                            "variant_id": 4,
                            "style": "intermediate",
                            "answer": "Crucial for User Generated Content. If you output a username `Hello {user}!`, and `{user}` is Arabic, without isolation, the `!` might jump to the start of the line or 'Hello' might flip. `<bdi>` wraps `{user}` to treat it neutrally."
                        },
                        {
                            "variant_id": 5,
                            "style": "advanced",
                            "answer": "Difference from `<bdo>`: `<bdo>` (Override) forces a direction. `<bdi>` (Isolation) auto-detects direction but insulates the surroundings. `<bdi>` is safer for dynamic content where you don't know the language."
                        },
                        {
                            "variant_id": 6,
                            "style": "analogy",
                            "answer": "It's a quarantine zone for text direction. Whether the text inside flows L->R or R->L, the barrier stops it from pushing the text outside around."
                        },
                        {
                            "variant_id": 7,
                            "style": "step_by_step",
                            "answer": "1. Dynamic list: `<li>User: {name} - 10pts</li>`. 2. Arabic name inserted. 3. Numbers/Structure flips. 4. Fix: `<li>User: <bdi>{name}</bdi> - 10pts</li>`."
                        },
                        {
                            "variant_id": 8,
                            "style": "interview",
                            "answer": "`<bdi>` handles Bi-Directional Isolation. I use it whenever inserting dynamic string content (usernames, comments) into the UI to prevent RTL strings from corrupting the layout of the surrounding LTR interface (or vice versa)."
                        },
                        {
                            "variant_id": 9,
                            "style": "student_style",
                            "answer": "It isolates text direction. Useful if you have mixed English and Arabic on the same line and don't want the layout to break."
                        },
                        {
                            "variant_id": 10,
                            "style": "deep_explanation",
                            "answer": "The Unicode Bidirectional Algorithm can cause unexpected rendering when mixed-direction scripts coexist. The `<bdi>` element essentially creates a new embedding level for its content while acting as an neutral character to its surrounding parent. This enables safe interpolation of unknown directional data."
                        }
                    ]
                },
                {
                    "id": 97,
                    "topic": "Rich Text",
                    "difficulty": "Advanced",
                    "question": "What are the security implications of `contenteditable='true'`?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "one_liner",
                            "answer": "It allows users to input rich HTML directly; pasting formatted text can inject malicious attributes or scripts (XSS)."
                        },
                        {
                            "variant_id": 2,
                            "style": "strict_definition",
                            "answer": "The `contenteditable` attribute makes an element editable. Since it modifies the DOM directly (creating HTML tags like `b`, `i`, `span`), it is a massive Self-XSS vector. Pasted content carries styles and attributes."
                        },
                        {
                            "variant_id": 3,
                            "style": "beginner_friendly",
                            "answer": "It turns a div into a Word doc. But if you copy text from a hacked site and paste it here, you might accidentally paste a virus (script) along with the text colors."
                        },
                        {
                            "variant_id": 4,
                            "style": "intermediate",
                            "answer": "Unlike `<textarea>` (Plain Text), `contenteditable` accepts Rich Text. You MUST sanitize input on paste events (`e.preventDefault()`, get `plain/text` only) and on the server. Otherwise, users can paste `<img onerror='alert()'>`."
                        },
                        {
                            "variant_id": 5,
                            "style": "advanced",
                            "answer": "Managing cursor position (Selection API / Range) is notoriously hard. Security-wise, CSP helps, but `contenteditable` is the hardest input to secure because the 'value' is actual Markup. You need a strict allowlist sanitizer (like DOMPurify) running constantly."
                        },
                        {
                            "variant_id": 6,
                            "style": "analogy",
                            "answer": "TextArea is a notebook (Text only). ContentEditable is a collage board (Cut-and-paste anything). If someone pastes dangerous material, it stays there."
                        },
                        {
                            "variant_id": 7,
                            "style": "step_by_step",
                            "answer": "1. User copies malicious text. 2. Pastes into ContentEditable. 3. Browser inserts HTML. 4. Malicious scripts execute. 5. Fix: Strip HTML on paste."
                        },
                        {
                            "variant_id": 8,
                            "style": "interview",
                            "answer": "`contenteditable` opens the door to DOM XSS via Copy-Paste. Since user input is rendered as HTML, not text, we must strictly listen to the `paste` event, strip all formatting/HTML tags, and insert only the plain text content."
                        },
                        {
                            "variant_id": 9,
                            "style": "student_style",
                            "answer": "It lets you edit the HTML on the page. Bad because you can accidentally paste bad code."
                        },
                        {
                            "variant_id": 10,
                            "style": "deep_explanation",
                            "answer": "The `contenteditable` attribute exposes the DOM to direct user manipulation. The browser's native implementation of rich-text editing commands (execCommand) and clipboard handling is inconsistent and insecure by design. Without aggressive sanitization middleware, it serves as a direct conduit for Markup Injection."
                        }
                    ]
                },
                {
                    "id": 98,
                    "topic": "Web Components",
                    "difficulty": "Distinguished",
                    "question": "What is the `is` attribute used for in the context of Custom Elements (Web Components)?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "one_liner",
                            "answer": "It allows you to extend a native HTML element (like `<button>`) with custom behavior while keeping its original semantics (`<button is='fancy-btn'>`)."
                        },
                        {
                            "variant_id": 2,
                            "style": "strict_definition",
                            "answer": "The `is` attribute implements 'Customized Built-in Elements'. It allows a Custom Element class to extend a native HTML class (e.g., `class MyButton extends HTMLButtonElement`). The tag remains `<button>` but gains the custom lifecycle callbacks."
                        },
                        {
                            "variant_id": 3,
                            "style": "beginner_friendly",
                            "answer": "If you make a `<my-button>`, it's just a blank box. You lose all the accessibility and click magic of a real button. If you use `<button is='my-button'>`, you keep the real button magic AND add your own flavor."
                        },
                        {
                            "variant_id": 4,
                            "style": "intermediate",
                            "answer": "This is distinct from 'Autonomous Custom Elements' (`<my-tag>`). Apple/Safari historically opposed `is` (implementation is patchy), but it remains in the spec. It is the only way to subclass `<table>` or `<ul>` while keeping the parser happy."
                        },
                        {
                            "variant_id": 5,
                            "style": "advanced",
                            "answer": "Progressive Enhancement: If JS fails or the browser doesn't support Web Components, `<button is='my-btn'>` still renders as a working Button. `<my-btn>` renders as an `HTMLUnknownElement` (inline span). This makes `is` critical for resilience."
                        },
                        {
                            "variant_id": 6,
                            "style": "analogy",
                            "answer": "Autonomous Element is building a car from scratch (Hard). `is` attribute is buying a Toyota and adding a turbocharger (Easier, and it still drives like a Toyota)."
                        },
                        {
                            "variant_id": 7,
                            "style": "step_by_step",
                            "answer": "1. Class: `class X extends HTMLButtonElement`. 2. Define: `customElements.define('x-btn', X, {extends:'button'})`. 3. HTML: `<button is='x-btn'>`."
                        },
                        {
                            "variant_id": 8,
                            "style": "interview",
                            "answer": "The `is` attribute enables Customized Built-in Elements. This preserves the accessibility and SEO value of the semantic tag (like `button` or `table`) while attaching Shadow DOM or custom behaviors. It is safer for Accessibility than Autonomous elements."
                        },
                        {
                            "variant_id": 9,
                            "style": "student_style",
                            "answer": "It lets you upgrade a normal tag. Like making a button tag act like your custom component."
                        },
                        {
                            "variant_id": 10,
                            "style": "deep_explanation",
                            "answer": "The `is` attribute specifies that a standard HTML element should behave as a defined Custom Element. This allows 'Type Extension' semantics. The resulting object is an instance of the specific custom class but retains the `localName` of the standard element, ensuring compatibility with layout engines and accessibility interfaces."
                        }
                    ]
                },
                {
                    "id": 99,
                    "topic": "Browser Translation",
                    "difficulty": "Intermediate",
                    "question": "What is the function of the `translate='no'` attribute?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "one_liner",
                            "answer": "It prevents browser translation engines (like Google Translate) from attempting to translate the content (useful for brand names, code, or logos)."
                        },
                        {
                            "variant_id": 2,
                            "style": "strict_definition",
                            "answer": "The `translate` global attribute manages whether the element’s attribute values and Text node children are to be translated when the page is localized. Value `no` protects the content from machine translation."
                        },
                        {
                            "variant_id": 3,
                            "style": "beginner_friendly",
                            "answer": "Google Translate tries to translate everything. Sometimes it translates things it shouldn't, like your company name 'Apple' into the fruit 'Manzana'. This tag tells Google 'Don't touch this word'."
                        },
                        {
                            "variant_id": 4,
                            "style": "intermediate",
                            "answer": "Critical for: Brand names (Uber -> 'Above'), Code snippets (`print()`), or Icons relying on ligature fonts (Material Icons), where translating the text breaks the icon."
                        },
                        {
                            "variant_id": 5,
                            "style": "advanced",
                            "answer": "You can apply it to the `<html>` tag to disable translation page-wide, or to specific spans. `class='notranslate'` is a common legacy Google-specific hook, but `translate='no'` is the HTML5 standard."
                        },
                        {
                            "variant_id": 6,
                            "style": "analogy",
                            "answer": "It's a 'Do Not Disturb' sign for the Translator bot."
                        },
                        {
                            "variant_id": 7,
                            "style": "step_by_step",
                            "answer": "1. Text: 'Use Stripe for payment'. 2. Browser translates 'Stripe' (Line). 3. Add `<span translate='no'>Stripe</span>`. 4. Result: 'Use Stripe...'."
                        },
                        {
                            "variant_id": 8,
                            "style": "interview",
                            "answer": "We use `translate='no'` to protect proper nouns, brand names, and technical terms from auto-translation. It prevents meaning corruption and UI breaking (for things like Icon Fonts) in a multilingual context."
                        },
                        {
                            "variant_id": 9,
                            "style": "student_style",
                            "answer": "It tells Google Translate to skip this part. Good for code or names."
                        },
                        {
                            "variant_id": 10,
                            "style": "deep_explanation",
                            "answer": "The `translate` attribute provides a directive to translation services. Unlike `lang`, which describes *what* language the content is, `translate='no'` describes *how* to process it (Immutable). This prevents semantic errors during automated localization workflows."
                        }
                    ]
                },
                {
                    "id": 100,
                    "topic": "HTML Logic",
                    "difficulty": "Distinguished",
                    "question": "Can you explain the 'HTML5 Outline algorithm' and is it actually used by browsers?",
                    "answer_variants": [
                        {
                            "variant_id": 1,
                            "style": "one_liner",
                            "answer": "The Outline Algorithm (using nesting `<section>` elements to auto-calculate heading levels) was defined in the spec but never implemented by any major browser; use explicit H1-H6 hierarchy instead."
                        },
                        {
                            "variant_id": 2,
                            "style": "strict_definition",
                            "answer": "The HTML5 Document Outline algorithm proposed that sectioning content (`<article>`, `<section>`) would start a new outline scope, allowing `<h1>` to be reused recursively (e.g., `h1` inside `section` becomes h2-equivalent). This was NEVER implemented by User Agents."
                        },
                        {
                            "variant_id": 3,
                            "style": "beginner_friendly",
                            "answer": "The theory: You can just use `<h1>` everywhere, and if you put it inside a `<section>`, it automatically shrinks to an `<h2>`. The Reality: Browsers ignored this rule. If you use `<h1>` everywhere, everything looks huge and screen readers get confused."
                        },
                        {
                            "variant_id": 4,
                            "style": "intermediate",
                            "answer": "It is the biggest 'Failed Promise' of HTML5. You must still physically use `<h1>`, `<h2>`, `<h3>`. Do not rely on valid HTML5 nesting to create structure for AT users. Linting tools often warn about this discrepancies."
                        },
                        {
                            "variant_id": 5,
                            "style": "advanced",
                            "answer": "While the `<h1>` does not visual scale down, the semantic outline is technically computed by validators (like the W3C Nu Validator), but Screen Readers read the literal tag level (`Heading Level 1`). Relying on the Outline Algorithm creates catastrophic accessibility failures (Flat structure)."
                        },
                        {
                            "variant_id": 6,
                            "style": "analogy",
                            "answer": "The Spec said: 'If you put a General in a small tent, he becomes a Sergeant'. The Browser said: 'No, he's still wearing General stars'. Result: Confusion."
                        },
                        {
                            "variant_id": 7,
                            "style": "step_by_step",
                            "answer": "1. Spec: nesting `section` lowers rank. 2. Dev: Uses `h1` inside `section`. 3. Browser: Renders `h1` (Big). 4. Screen Reader: Says 'Level 1'. 5. Conclusion: Don't do it."
                        },
                        {
                            "variant_id": 8,
                            "style": "interview",
                            "answer": "The HTML5 Outline Algorithm—dynamic heading levels based on nesting—is a theoretical spec that was never implemented by vendors. We must strictly ignore it and manually enforce the `h1` through `h6` hierarchy to ensure correct Accessibility Tree construction."
                        },
                        {
                            "variant_id": 9,
                            "style": "student_style",
                            "answer": "It was a cool idea to just use H1s everywhere, but it doesn't work. You have to use H1, H2, H3 properly."
                        },
                        {
                            "variant_id": 10,
                            "style": "deep_explanation",
                            "answer": "The Algorithm was designed to decouple component structure from the global document depth. However, due to lack of implementation in the Accessibility mappings (AAPI) of Chrome/Firefox/Safari, the document structure remains flat if `h1` is reused. Accessibility experts universally advise against relying on section-induced outlining."
                        }
                    ]
                }
            ]
        }
    ]
}