{"pageProps":{"tutorials":[{"slug":"python-conditionals","title":"Python Conditional Statements - Complete Guide","category":"backend","description":"Conditional statements are fundamental to programming - they let programs make decisions.\n\n**Three Main Types:**\n\n✅ **if** - Execute code only if condition is True\n```python\nif age >= 18:\n    print(\"Adult\")\n```\n\n✅ **if-else** - Two paths (one must execute)\n```python\nif age >= 18:\n    print(\"Adult\")\nelse:\n    print(\"Minor\")\n```\n\n✅ **if-elif-else** - Multiple conditions (first True wins)\n```python\nif score >= 90:\n    grade = 'A'\nelif score >= 80:\n    grade = 'B'\nelse:\n    grade = 'F'\n```\n\n**Key Rules:**\n\n1. **Colon (:)** required after condition\n2. **Indentation** (4 spaces) defines code block\n3. **Only first True** executes in if-elif-else\n4. **Order matters** - specific before general\n5. **else optional** - default case\n\n**Flow Decision:**\n\n| Scenario | Use |\n|----------|-----|\n| Single check | `if` |\n| Two options | `if-else` |\n| Multiple exclusive options | `if-elif-else` |\n| Dependent checks | Nested `if` |\n| Independent checks | Multiple `if` |\n\n**Common Patterns:**\n```python\n# Range check\nif 0 <= score <= 100:\n\n# Multiple conditions\nif age >= 18 and has_license:\n\n# Ternary (simple if-else)\nstatus = \"Adult\" if age >= 18 else \"Minor\"\n\n# Nested (dependent)\nif logged_in:\n    if has_permission:\n        # access granted\n```\n\n**Remember:**\n- **=** assigns, **==** compares\n- Indent with 4 spaces\n- Order if-elif from specific to general\n- Use `and` for all-required, `or` for any-required\n\nMaster conditionals to build intelligent, responsive programs!"},{"slug":"python-data-types","title":"Python Data Types - Complete Guide","category":"backend","description":"Python has rich built-in data types for different purposes. Understanding them is crucial for effective programming.\n\n**Main Data Types:**\n\n✅ **Numeric**: int, float, complex\n✅ **Text**: str (strings)\n✅ **Sequence**: list (mutable), tuple (immutable), set (unique)\n✅ **Mapping**: dict (key-value pairs)\n✅ **Boolean**: bool (True/False)\n✅ **None**: None (absence of value)\n\n**Mutable vs Immutable:**\n\n**Mutable** (can change): list, dict, set\n**Immutable** (cannot change): int, float, str, tuple, bool\n\n**Type Checking & Conversion:**\n```python\ntype(variable)          # Get type\nisinstance(var, int)    # Check type\nint('123')              # Convert to int\nfloat(100)              # Convert to float\nstr(3.14)               # Convert to string\n```\n\n**Quick Reference:**\n\n| Type | Example | Mutable | Ordered | Duplicates |\n|------|---------|---------|---------|------------|\n| int | 100 | ❌ | N/A | N/A |\n| float | 3.14 | ❌ | N/A | N/A |\n| str | \"hello\" | ❌ | ✅ | ✅ |\n| list | [1,2,3] | ✅ | ✅ | ✅ |\n| tuple | (1,2,3) | ❌ | ✅ | ✅ |\n| set | {1,2,3} | ✅ | ❌ | ❌ |\n| dict | {\"a\":1} | ✅ | ✅* | Keys: ❌ |\n\n*Python 3.7+ maintains insertion order\n\n**Remember:**\n- Use lists for changeable ordered data\n- Use tuples for constant ordered data\n- Use sets for unique values\n- Use dicts for labeled data (key-value)\n\nMaster these types to write efficient, bug-free Python code!"},{"slug":"python-dictionaries","title":"Python Dictionaries - Complete Guide","category":"backend","description":"Dictionaries are Python's key-value data structure - fast, flexible, and essential for structured data.\n\n**Key Concepts:**\n\n✅ **Key-Value Pairs**: Data stored as `{key: value}`\n✅ **Unique Keys**: No duplicates allowed\n✅ **Immutable Keys**: str, int, tuple (not list)\n✅ **Any Values**: Lists, dicts, objects, anything\n✅ **O(1) Lookup**: Hash table = very fast\n✅ **JSON-like**: Perfect for structured data\n\n**Creation:**\n```python\ndict = {\"name\": \"Alice\", \"age\": 25}\ndict = dict(name=\"Alice\", age=25)\ndict = {k: v for k, v in pairs}\n```\n\n**Access:**\n```python\nvalue = dict[\"key\"]           # KeyError if missing\nvalue = dict.get(\"key\", default)  # Safe\n```\n\n**Essential Methods:**\n\n| Method | Action |\n|--------|--------|\n| `dict[key] = value` | Add/update |\n| `dict.get(key, default)` | Safe access |\n| `dict.pop(key)` | Remove & return |\n| `dict.keys()` | All keys |\n| `dict.values()` | All values |\n| `dict.items()` | Key-value pairs |\n| `dict.update(other)` | Merge dicts |\n\n**Iteration (Best Practice):**\n```python\nfor key, value in dict.items():\n    print(f\"{key}: {value}\")\n```\n\n**Nested Dictionaries:**\n```python\ndata = {\n    \"user1\": {\"name\": \"Alice\", \"age\": 25},\n    \"user2\": {\"name\": \"Bob\", \"age\": 30}\n}\n\nname = data[\"user1\"][\"name\"]  # Alice\n```\n\n**Why Dictionaries are Fast:**\n- Hash tables: O(1) lookup\n- List: O(n) search\n- Dict: instant key-based access\n\n**When to Use:**\n\n| Scenario | Use |\n|----------|-----|\n| Need key-based lookup | ✅ Dict |\n| Store configuration | ✅ Dict |\n| JSON-like data | ✅ Dict |\n| Counting/frequency | ✅ Dict |\n| Ordered sequence | List |\n| Just need values | List |\n\n**Common Patterns:**\n```python\n# Count frequency\nfreq = {}\nfor item in items:\n    freq[item] = freq.get(item, 0) + 1\n\n# Group by key\ngroups = {}\nfor item in items:\n    key = get_key(item)\n    groups.setdefault(key, []).append(item)\n\n# Merge dicts\ncombined = {**dict1, **dict2}\n```\n\n**Remember:**\n```python\n# ❌ Wrong\ndict[[1,2]] = \"value\"  # Lists not hashable!\nvalue = dict[\"missing\"]  # KeyError!\n\n# ✅ Correct\ndict[(1,2)] = \"value\"  # Tuples OK\nvalue = dict.get(\"missing\", default)\n```\n\nMaster dictionaries for efficient data management!"},{"slug":"python-exception-handling","title":"Python Exception Handling - Complete Guide","category":"backend","description":"Exception handling prevents crashes by catching and managing runtime errors gracefully.\n\n**Basic Structure:**\n\n```python\ntry:\n    # Code that might fail\n    risky_operation()\nexcept ExceptionType:\n    # Handle specific error\n    handle_error()\nelse:\n    # Only if try succeeds\n    success_code()\nfinally:\n    # Always executes\n    cleanup_code()\n```\n\n**Execution Flow:**\n\n| Case | try | except | else | finally |\n|------|-----|--------|------|--------|\n| Success | ✓ | ✗ | ✓ | ✓ |\n| Error caught | Partial | ✓ | ✗ | ✓ |\n| Error not caught | Partial | ✗ | ✗ | ✓ then crash |\n\n**Common Exceptions:**\n\n```python\nZeroDivisionError  # 10 / 0\nValueError         # int('abc')\nTypeError          # '5' + 5\nIndexError         # list[999]\nKeyError           # dict['missing']\nFileNotFoundError  # open('missing.txt')\n```\n\n**Multiple Exceptions:**\n\n```python\ntry:\n    code()\nexcept ValueError:\n    # Handle value error\nexcept TypeError:\n    # Handle type error\nexcept Exception as e:\n    # Catch any other\n    print(f\"Error: {e}\")\n```\n\n**When to Use Each:**\n\n- **try**: Wrap risky code\n- **except**: Handle specific errors\n- **else**: Code that runs on success\n- **finally**: Guaranteed cleanup\n\n**Raising Exceptions:**\n\n```python\ndef validate(age):\n    if age < 0:\n        raise ValueError(\"Age cannot be negative\")\n    return age\n\n# Re-raise\ntry:\n    code()\nexcept Exception as e:\n    log(e)\n    raise  # Propagate error\n```\n\n**Custom Exceptions:**\n\n```python\nclass ValidationError(Exception):\n    pass\n\nraise ValidationError(\"Invalid data\")\n```\n\n**Best Practices:**\n\n```python\n# ✅ Specific exceptions\ntry:\n    code()\nexcept ValueError:\n    handle_value_error()\n\n# ❌ Too broad\ntry:\n    code()\nexcept:\n    pass  # Don't do this!\n\n# ✅ Helpful messages\nraise ValueError(f\"Age must be 0-150, got {age}\")\n\n# ✅ Order: specific → general\ntry:\n    code()\nexcept ValueError:  # Specific first\n    pass\nexcept Exception:   # General last\n    pass\n```\n\n**Common Patterns:**\n\n```python\n# Default value\ntry:\n    value = dict[key]\nexcept KeyError:\n    value = default\n\n# Retry logic\nfor attempt in range(3):\n    try:\n        return do_operation()\n    except NetworkError:\n        if attempt < 2:\n            time.sleep(1)\n        else:\n            raise\n\n# Resource cleanup\nfile = open('data.txt')\ntry:\n    process(file)\nfinally:\n    file.close()\n```\n\n**Remember:**\n- Exceptions for errors, not flow control\n- Be specific with exception types\n- Always clean up resources (finally)\n- Provide helpful error messages\n- Don't silence errors (log them!)\n\nMaster exception handling for robust, production-ready code!"},{"slug":"python-file-handling","title":"Python File Handling - Complete Guide","category":"backend","description":"File handling enables programs to read, write, and persist data - essential for real-world applications.\n\n**File Modes:**\n\n| Mode | Action | Creates | Overwrites |\n|------|--------|---------|------------|\n| `'r'` | Read | ❌ | N/A |\n| `'w'` | Write | ✅ | ✅ |\n| `'a'` | Append | ✅ | ❌ |\n| `'rb'` | Read binary | ❌ | N/A |\n\n**The 'with' Statement:**\n```python\n# ✅ Best practice\nwith open('file.txt', 'r') as file:\n    content = file.read()\n# Auto-closes even if error\n\n# ❌ Avoid (manual close)\nfile = open('file.txt', 'r')\ncontent = file.read()\nfile.close()  # Might not run if error\n```\n\n**Reading Methods:**\n\n```python\n# Entire file\ncontent = file.read()\n\n# One line\nline = file.readline()\n\n# All lines as list\nlines = file.readlines()\n\n# Best: iterate (memory efficient)\nfor line in file:\n    print(line.strip())\n```\n\n**Writing:**\n\n```python\n# Write (overwrites)\nwith open('file.txt', 'w') as file:\n    file.write(\"Hello\\n\")\n\n# Append (preserves)\nwith open('file.txt', 'a') as file:\n    file.write(\"World\\n\")\n```\n\n**JSON Files:**\n\n```python\nimport json\n\n# Write\nwith open('data.json', 'w') as file:\n    json.dump(data, file, indent=4)\n\n# Read\nwith open('data.json', 'r') as file:\n    data = json.load(file)\n```\n\n**CSV Files:**\n\n```python\nimport csv\n\n# Write\nwith open('data.csv', 'w', newline='') as file:\n    writer = csv.writer(file)\n    writer.writerows(rows)\n\n# Read\nwith open('data.csv', 'r') as file:\n    reader = csv.reader(file)\n    for row in reader:\n        print(row)\n```\n\n**Error Handling:**\n\n```python\ntry:\n    with open('file.txt', 'r') as file:\n        content = file.read()\nexcept FileNotFoundError:\n    print(\"File not found\")\n```\n\n**Path Operations:**\n\n```python\nfrom pathlib import Path\n\n# Check existence\nif Path('file.txt').exists():\n    # Read file\n\n# Read/write text\ncontent = Path('file.txt').read_text()\nPath('file.txt').write_text(content)\n```\n\n**Best Practices:**\n- ✅ Always use `with` statement\n- ✅ Use 'a' for logs, 'w' for fresh data\n- ✅ Handle FileNotFoundError\n- ✅ Use encoding='utf-8' for special chars\n- ✅ Use pathlib for modern code\n- ✅ Iterate for large files, not readlines()\n\n**Common Patterns:**\n\n```python\n# Copy file\nwith open('src.txt', 'r') as src:\n    with open('dst.txt', 'w') as dst:\n        dst.write(src.read())\n\n# Append to log\nwith open('log.txt', 'a') as file:\n    file.write(f\"{timestamp}: {message}\\n\")\n\n# Process large file\nwith open('big.txt', 'r') as file:\n    for line in file:\n        process(line)\n```\n\nMaster file handling for data persistence!"},{"slug":"python-functions","title":"Python Functions - Complete Guide","category":"backend","description":"Functions are building blocks of modular, reusable code. They organize programs into logical units.\n\n**Function Structure:**\n```python\ndef function_name(parameters):\n    \"\"\"Docstring\"\"\"\n    # Function body\n    return value\n```\n\n**Key Concepts:**\n\n✅ **Parameters vs Arguments**\n- Parameters: function definition (placeholders)\n- Arguments: function call (actual values)\n\n✅ **Argument Types:**\n```python\n# Positional\nfunc(1, 2)\n\n# Keyword  \nfunc(a=1, b=2)\n\n# Default\ndef func(a, b=10):\n\n# Variable\ndef func(*args, **kwargs):\n```\n\n✅ **Return Statement:**\n- Sends value back\n- Exits function immediately\n- Can return multiple values\n- No return → returns None\n\n✅ **Scope:**\n- Local: inside function\n- Global: outside functions\n- Use 'global' to modify global\n\n**Parameter Order:**\n```python\ndef func(regular, *args, keyword_only, default=val, **kwargs):\n    pass\n```\n\n**Common Patterns:**\n```python\n# Simple function\ndef greet(name):\n    return f\"Hello, {name}!\"\n\n# Default arguments\ndef power(base, exponent=2):\n    return base ** exponent\n\n# Multiple returns\ndef minmax(nums):\n    return min(nums), max(nums)\n\n# Variable args\ndef sum_all(*numbers):\n    return sum(numbers)\n```\n\n**Best Practices:**\n- Use descriptive function names\n- Add docstrings\n- Keep functions focused (one task)\n- Avoid global variables\n- Return values instead of modifying globals\n\n**Benefits:**\n- Code reusability\n- Better organization\n- Easier testing\n- Improved readability\n\nMaster functions to write clean, maintainable Python code!"},{"slug":"python-input-output","title":"Python Input and Output - Complete Guide","category":"backend","description":"Input and output are fundamental to interactive programs. Python makes them simple with input() and print() functions.\n\n**Input:**\n\n✅ **input()** gets user input (always returns string)\n✅ **Type cast** to convert: int(input()), float(input())\n✅ **split()** for multiple inputs: input().split()\n✅ **map()** to convert all: map(int, input().split())\n\n**Output:**\n\n✅ **print()** displays output\n✅ **sep** parameter: print(a, b, sep='-')\n✅ **end** parameter: print('Hi', end='')\n✅ **Multiple values**: print(a, b, c)\n\n**String Formatting (Best to Worst):**\n\n1. **f-strings** (modern, Python 3.6+):\n   ```python\n   f\"Name: {name}, Age: {age}\"\n   f\"Price: ${price:.2f}\"\n   ```\n\n2. **.format()** (intermediate):\n   ```python\n   \"Name: {}, Age: {}\".format(name, age)\n   ```\n\n3. **% operator** (old, avoid):\n   ```python\n   \"Name: %s, Age: %d\" % (name, age)\n   ```\n\n**f-string Formatting:**\n- Decimals: `{number:.2f}` → 3.14\n- Thousands: `{num:,}` → 1,000,000\n- Percent: `{ratio:.1%}` → 85.5%\n- Padding: `{num:05}` → 00042\n\n**Common Pattern:**\n```python\n# Get input with validation\nage = int(input(\"Age: \"))\nname = input(\"Name: \")\n\n# Display formatted output\nprint(f\"Hello {name}! You are {age} years old.\")\n```\n\n**Remember:**\n- input() = string\n- Convert before math\n- f-strings are best\n- Validate user input!"},{"slug":"python-installation","title":"Python Installation & Setup - Step-by-Step Guide","category":"backend","description":"Installing Python is the first step to becoming a Python developer. Follow platform-specific instructions carefully to ensure smooth setup.\n\n**Installation Checklist:**\n\n✅ **Download**: Get latest Python 3.x from python.org\n✅ **Install**: Run installer, CHECK 'Add to PATH' (critical!)\n✅ **Verify**: `python --version` shows Python 3.x.x\n✅ **Check pip**: `pip --version` confirms package manager works\n✅ **Choose editor**: IDLE (simple), VS Code (recommended), PyCharm (full-featured)\n\n**Platform Commands:**\n\n**Windows:**\n- Install: Download .exe, check PATH, install\n- Command: `python --version`, `pip install package`\n\n**macOS/Linux:**\n- Install: Download .pkg or use package manager\n- Command: `python3 --version`, `pip3 install package`\n\n**Common Issues:**\n1. \"python not recognized\" → Add to PATH or reinstall\n2. Wrong version → Use python3 on Unix systems\n3. pip not working → Use `python -m pip`\n\n**First Program:**\n```python\nprint(\"Hello, Python!\")\n```\nSave as `.py`, run with `python filename.py`\n\n**Next Steps:**\n1. Open terminal, type `python` (or `python3`)\n2. See `>>>` prompt? Installation successful!\n3. Type `print(\"I did it!\")` and press Enter\n4. Ready to learn Python programming!\n\n**Pro Tip:** Use virtual environments for projects to keep dependencies isolated and avoid conflicts."},{"slug":"python-interview-preparation","title":"Python Interview Preparation - Complete Guide","category":"backend","description":"Python interview preparation requires mastering fundamentals, understanding tricky concepts, and writing efficient, Pythonic code.\n\n**Key Tricky Concepts:**\n\n1. **Mutable Default Arguments:**\n```python\n❌ def func(items=[]):\n✅ def func(items=None):\n       if items is None: items = []\n```\n\n2. **Late Binding Closures:**\n```python\n# All print 2!\nfuncs = [lambda: i for i in range(3)]\n\n# Fix: use default argument\nfuncs = [lambda i=i: i for i in range(3)]\n```\n\n3. **Shallow vs Deep Copy:**\n```python\nshallow = list.copy()  # Copies references\ndeep = copy.deepcopy()  # Recursive copy\n```\n\n**Common Interview Problems:**\n\n```python\n# Two Sum - O(n)\ndef two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        if target - num in seen:\n            return [seen[target - num], i]\n        seen[num] = i\n\n# Valid Parentheses - Stack\ndef is_valid(s):\n    stack = []\n    pairs = {')':'(', '}':'{', ']':'['}\n    for c in s:\n        if c in pairs:\n            if not stack or stack.pop() != pairs[c]:\n                return False\n        else:\n            stack.append(c)\n    return not stack\n\n# Palindrome\ndef is_palindrome(s):\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\n```\n\n**Best Practices:**\n\n```python\n# Pythonic idioms\nsquares = [x**2 for x in range(10)]\nfor i, item in enumerate(items):\nfor a, b in zip(list1, list2):\nif any(x > 10 for x in nums):\nif all(x > 0 for x in nums):\n\n# Context managers\nwith open('file.txt') as f:\n    content = f.read()\n\n# Specific exceptions\ntry:\n    risky()\nexcept ValueError as e:\n    handle(e)\n```\n\n**Performance Tips:**\n\n```python\n# Use built-ins (fast)\nsum(numbers)\nmax(numbers)\nany(condition)\n\n# Set for membership O(1)\nif item in my_set:  # Fast\n\n# Join strings\n''.join(strings)  # Fast\nresult += string  # Slow in loop\n\n# List comprehension\n[x**2 for x in nums]  # Faster than loop\n```\n\n**Edge Cases:**\n- Empty inputs: [], '', None\n- Single element: [1]\n- Negative numbers\n- Duplicates\n- Large inputs\n- Unicode/special characters\n\n**Time Complexities:**\n| Operation | List | Dict | Set |\n|-----------|------|------|-----|\n| Access | O(1) | O(1) | N/A |\n| Search | O(n) | O(1) | O(1) |\n| Insert | O(n) | O(1) | O(1) |\n| Delete | O(n) | O(1) | O(1) |\n\n**Interview Tips:**\n1. Clarify requirements\n2. Discuss approach before coding\n3. Consider edge cases\n4. Think about time/space complexity\n5. Write clean, readable code\n6. Test with examples\n7. Optimize if asked\n\n**Common Mistakes to Avoid:**\n- ❌ Mutable default arguments\n- ❌ Modifying list while iterating\n- ❌ Using == instead of is for None\n- ❌ Bare except clauses\n- ❌ Forgetting edge cases\n\nPractice consistently and master both fundamentals and advanced concepts!"},{"slug":"python-introduction","title":"Introduction to Python - Complete Beginner Guide","category":"backend","description":"Python is a beginner-friendly, powerful programming language used worldwide for web development, data science, automation, and AI.\n\n**Why Python?**\n✅ Simplest syntax among major languages\n✅ No complex setup - write and run immediately\n✅ Massive job market demand\n✅ 300,000+ ready-to-use libraries\n✅ One language, multiple careers (web, data, AI, automation)\n\n**Key Concepts:**\n- **Interpreted**: No compilation step needed\n- **Dynamically Typed**: No type declarations (x = 5, x = \"hi\" both valid)\n- **Indentation-based**: Spaces/tabs define code blocks\n- **Object-Oriented**: Everything is an object\n\n**Your First Program:**\n```python\nprint(\"Hello, World!\")\n```\n\nThat's it! One line, no boilerplate code.\n\n**Python 3 vs Python 2:**\nAlways use Python 3. Python 2 is obsolete (support ended 2020).\n\n**Next Steps:**\n1. Install Python 3 (latest version)\n2. Learn variables and data types\n3. Practice with simple programs\n4. Explore libraries for your interest area\n\nPython's philosophy: \"There should be one obvious way to do it.\" Start coding and see why millions choose Python!"},{"slug":"python-lists","title":"Python Lists - Complete Guide","category":"backend","description":"Lists are Python's most versatile data structure - ordered, mutable collections perfect for storing sequences.\n\n**Key Characteristics:**\n\n✅ **Ordered**: Items maintain position\n✅ **Mutable**: Can be changed after creation  \n✅ **Indexed**: 0-based access\n✅ **Dynamic**: Grow/shrink as needed\n✅ **Heterogeneous**: Mix different types\n\n**Creation:**\n```python\nmy_list = [1, 2, 3, 4, 5]\nempty = []\nmixed = [1, \"text\", 3.14, True]\nnested = [[1, 2], [3, 4]]\n```\n\n**Accessing:**\n```python\nfirst = my_list[0]    # First item\nlast = my_list[-1]    # Last item\nslice = my_list[1:4]  # Items 1-3\n```\n\n**Essential Methods:**\n\n| Method | Action | Return |\n|--------|--------|--------|\n| `append(x)` | Add to end | None |\n| `insert(i, x)` | Insert at index | None |\n| `remove(x)` | Remove first x | None |\n| `pop([i])` | Remove & return | Item |\n| `sort()` | Sort in place | None |\n| `reverse()` | Reverse in place | None |\n| `copy()` | Create copy | New list |\n\n**Slicing:**\n```python\nlist[start:stop:step]\nlist[:5]      # First 5\nlist[5:]      # From index 5\nlist[::2]     # Every 2nd\nlist[::-1]    # Reversed\n```\n\n**List Comprehension:**\n```python\n# Instead of:\nresult = []\nfor x in range(5):\n    result.append(x**2)\n\n# Write:\nresult = [x**2 for x in range(5)]\n\n# With condition:\nevens = [x for x in range(10) if x % 2 == 0]\n```\n\n**Mutability Warning:**\n```python\nlist1 = [1, 2, 3]\nlist2 = list1      # Reference!\nlist2.append(4)    # Both affected\n\n# Create copy:\nlist2 = list1.copy()  # Independent\n```\n\n**Common Operations:**\n```python\nlen(my_list)       # Length\nmax(my_list)       # Maximum\nmin(my_list)       # Minimum\nsum(my_list)       # Sum\nx in my_list       # Membership\nlist1 + list2      # Concatenate\nlist1 * 3          # Repeat\n```\n\n**Remember:**\n- Lists = mutable, brackets []\n- Tuples = immutable, parentheses ()\n- Assignment creates reference, use .copy()\n- Slicing stop is exclusive\n- sort() modifies, sorted() returns new\n\nMaster lists to handle collections efficiently in Python!"},{"slug":"python-loops","title":"Python Loops - Complete Guide","category":"backend","description":"Loops are essential for automating repetitive tasks. Python provides two main loop types.\n\n**Loop Types:**\n\n✅ **for loop** - Iterate over sequences\n```python\nfor item in sequence:\n    # code\n\nfor i in range(5):  # 0,1,2,3,4\n    # code\n```\n\n✅ **while loop** - Repeat while condition True\n```python\nwhile condition:\n    # code\n    # update condition!\n```\n\n**range() Function:**\n```python\nrange(5)         # 0,1,2,3,4\nrange(2, 6)      # 2,3,4,5\nrange(0, 10, 2)  # 0,2,4,6,8\nrange(5, 0, -1)  # 5,4,3,2,1\n```\n\n**Control Statements:**\n\n| Statement | Action |\n|-----------|--------|\n| `break` | Exit loop immediately |\n| `continue` | Skip to next iteration |\n| `pass` | Do nothing (placeholder) |\n\n**When to Use:**\n\n| Scenario | Use |\n|----------|-----|\n| Known iterations | `for` with range |\n| Iterate list/string | `for item in sequence` |\n| Unknown iterations | `while` |\n| Until condition | `while` with break |\n| Pattern generation | Nested `for` |\n\n**Common Patterns:**\n```python\n# Sum numbers\ntotal = 0\nfor i in range(1, 11):\n    total += i\n\n# Find in list\nfor item in items:\n    if item == target:\n        break\n\n# Input validation\nwhile True:\n    value = input()\n    if valid(value):\n        break\n```\n\n**Critical Rules:**\n- range(n) goes 0 to n-1 (n excluded)\n- Always update while condition\n- break exits loop, continue skips iteration\n- Avoid modifying list while iterating\n- Use enumerate() for index+value\n\n**Avoid:**\n❌ Infinite loops (forgot to update condition)\n❌ Modifying sequence during iteration\n❌ Off-by-one errors with range\n\nMaster loops to write efficient, automated Python programs!"},{"slug":"python-modules-packages","title":"Python Modules and Packages - Complete Guide","category":"backend","description":"Modules and packages organize Python code into reusable, maintainable components.\n\n**Core Concepts:**\n\n**Module = .py file:**\n```python\n# math_utils.py\ndef add(a, b):\n    return a + b\n\nPI = 3.14159\n```\n\n**Import Methods:**\n```python\nimport math              # math.sqrt()\nfrom math import sqrt    # sqrt()\nimport numpy as np       # np.array()\nfrom math import *       # all items (avoid)\n```\n\n**Package = Directory:**\n```\nmy_package/\n    __init__.py  # Makes it package\n    module1.py\n    module2.py\n```\n\n**if __name__ == '__main__':**\n```python\ndef function():\n    pass\n\nif __name__ == \"__main__\":\n    # Only runs when executed directly\n    # Not when imported\n    function()\n```\n\n**pip Commands:**\n```bash\npip install package_name\npip install requests numpy pandas\npip install package==version\npip uninstall package\npip list\npip freeze > requirements.txt\npip install -r requirements.txt\n```\n\n**Virtual Environments:**\n```bash\n# Create\npython -m venv venv\n\n# Activate\nvenv\\Scripts\\activate  # Windows\nsource venv/bin/activate  # Mac/Linux\n\n# Install packages\npip install requests\n\n# Deactivate\ndeactivate\n```\n\n**Project Structure:**\n```\nproject/\n    src/\n        __init__.py\n        module1.py\n        module2.py\n    tests/\n        test_module1.py\n    venv/\n    requirements.txt\n    README.md\n```\n\n**Built-in Modules:**\n```python\nimport math      # Mathematical functions\nimport random    # Random numbers\nimport datetime  # Date and time\nimport os        # Operating system\nimport sys       # System parameters\nimport json      # JSON encoding/decoding\n```\n\n**Common Third-Party:**\n```python\nimport requests  # HTTP requests\nimport numpy     # Numerical computing\nimport pandas    # Data analysis\nimport matplotlib  # Plotting\n```\n\n**Import Search Path:**\n1. Current directory\n2. PYTHONPATH\n3. Standard library\n4. Site-packages (pip installs)\n\n**requirements.txt:**\n```\nrequests>=2.25.0\nnumpy==1.21.0\npandas>=1.3.0\n```\n\n**Best Practices:**\n- ✅ Use virtual environments always\n- ✅ Create requirements.txt for dependencies\n- ✅ Use if __name__ == '__main__' for test code\n- ✅ Use absolute imports for clarity\n- ✅ Organize related code into packages\n- ✅ Add __init__.py to packages\n- ❌ Avoid from module import *\n- ❌ Don't modify sys.path unnecessarily\n\n**Module Organization:**\n```python\n# Good structure\nproject/\n    core/        # Core functionality\n    utils/       # Utilities\n    models/      # Data models\n    tests/       # Tests\n    config.py    # Configuration\n    main.py      # Entry point\n```\n\n**Remember:**\n- Module = file, Package = directory\n- Always use virtual environments\n- Track dependencies in requirements.txt\n- Use if __name__ for test code\n- Organize code logically\n\nMaster modules for professional Python development!"},{"slug":"python-oop","title":"Python Object-Oriented Programming (OOP) - Complete Guide","category":"backend","description":"Object-Oriented Programming organizes code around objects - combining data and behavior in reusable, maintainable structures.\n\n**Core Concepts:**\n\n**Class & Object:**\n```python\nclass Car:  # Blueprint\n    def __init__(self, brand):\n        self.brand = brand  # Instance variable\n    \n    def start(self):  # Instance method\n        return f\"{self.brand} started\"\n\ncar = Car(\"Toyota\")  # Object (instance)\n```\n\n**Four Pillars:**\n\n1. **Encapsulation**\n```python\nclass Account:\n    def __init__(self, balance):\n        self.__balance = balance  # Private\n    \n    @property\n    def balance(self):  # Controlled access\n        return self.__balance\n```\n\n2. **Inheritance**\n```python\nclass Animal:\n    def speak(self):\n        pass\n\nclass Dog(Animal):  # Dog IS-A Animal\n    def speak(self):\n        return \"Woof!\"\n```\n\n3. **Polymorphism**\n```python\n# Same method, different implementations\nfor animal in [Dog(), Cat()]:\n    print(animal.speak())  # Different outputs\n```\n\n4. **Abstraction**\n```python\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):  # Must implement\n        pass\n```\n\n**Key Features:**\n\n| Feature | Purpose |\n|---------|----------|\n| `__init__` | Constructor |\n| `self` | Current instance |\n| `super()` | Call parent method |\n| `@property` | Getter |\n| `@setter` | Setter with validation |\n| `@classmethod` | Operate on class |\n| `@staticmethod` | Utility function |\n\n**Inheritance:**\n```python\nclass Parent:\n    def __init__(self, x):\n        self.x = x\n\nclass Child(Parent):\n    def __init__(self, x, y):\n        super().__init__(x)  # Call parent\n        self.y = y\n```\n\n**Encapsulation Levels:**\n```python\nclass MyClass:\n    def __init__(self):\n        self.public = 1      # Public\n        self._protected = 2  # Protected (convention)\n        self.__private = 3   # Private (name mangling)\n```\n\n**Magic Methods:**\n```python\nclass Point:\n    def __str__(self):  # print()\n        return f\"Point({self.x}, {self.y})\"\n    \n    def __add__(self, other):  # +\n        return Point(self.x + other.x, self.y + other.y)\n    \n    def __eq__(self, other):  # ==\n        return self.x == other.x and self.y == other.y\n```\n\n**Inheritance vs Composition:**\n```python\n# Inheritance: IS-A\nclass Dog(Animal):  # Dog IS-A Animal\n    pass\n\n# Composition: HAS-A\nclass Car:\n    def __init__(self):\n        self.engine = Engine()  # Car HAS-A Engine\n```\n\n**When to Use OOP:**\n✅ Complex systems with related entities\n✅ Code reuse through inheritance\n✅ Data protection with encapsulation\n✅ Modeling real-world objects\n✅ Large codebases needing organization\n\n**Best Practices:**\n- Keep classes focused (single responsibility)\n- Favor composition over deep inheritance\n- Use properties for controlled access\n- Document with docstrings\n- Follow naming conventions\n- Make attributes private when needed\n\n**Common Patterns:**\n```python\n# Singleton\nclass Singleton:\n    _instance = None\n    \n    def __new__(cls):\n        if not cls._instance:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n# Factory\nclass ShapeFactory:\n    @staticmethod\n    def create(shape_type):\n        if shape_type == 'circle':\n            return Circle()\n        elif shape_type == 'rectangle':\n            return Rectangle()\n```\n\nMaster OOP for scalable, maintainable code!"},{"slug":"python-operators","title":"Python Operators - Complete Guide","category":"backend","description":"Operators are fundamental to Python programming. They perform operations on data and control program flow.\n\n**Types of Operators:**\n\n✅ **Arithmetic**: `+ - * / // % **`\n   - `/` always float, `//` integer division\n   - `%` remainder, `**` power\n\n✅ **Comparison**: `== != > < >= <=`\n   - Return boolean (True/False)\n   - Can chain: `1 < x < 10`\n\n✅ **Logical**: `and or not`\n   - `and`: both true\n   - `or`: at least one true\n   - `not`: inverts\n\n✅ **Assignment**: `= += -= *= /=`\n   - `x += 5` ≡ `x = x + 5`\n\n✅ **Membership**: `in not in`\n   - Check if value in sequence\n\n✅ **Identity**: `is is not`\n   - Check same object\n   - Use `is None`, not `== None`\n\n**Critical Distinctions:**\n\n| Concept | Correct | Wrong |\n|---------|---------|-------|\n| Assignment | `x = 5` | `x == 5` |\n| Comparison | `x == 5` | `x = 5` |\n| Value check | `a == b` | `a is b` |\n| None check | `x is None` | `x == None` |\n| Integer div | `7 // 2` (3) | `7 / 2` (3.5) |\n| Remainder | `7 % 3` (1) | |\n\n**Operator Precedence (memorize):**\n```\n** > */% > +- > comparisons > and > or\n```\n\n**Best Practices:**\n- Use `==` for values, `is` for identity\n- Use `//` for integer division\n- Add parentheses for clarity\n- Check against `None` with `is`\n\n**Common Patterns:**\n```python\n# Even/odd check\nif x % 2 == 0: print(\"Even\")\n\n# Range check\nif 0 <= score <= 100: print(\"Valid\")\n\n# Multiple conditions\nif age >= 18 and has_id: print(\"Allowed\")\n\n# Increment\ncount += 1  # Instead of count = count + 1\n```\n\nMaster operators to write efficient, readable Python code!"},{"slug":"python-sets","title":"Python Sets - Complete Guide","category":"backend","description":"Sets are Python's implementation of mathematical set theory - unique, unordered collections with powerful operations.\n\n**Key Characteristics:**\n\n✅ **Unordered**: No indexing, no guaranteed order\n✅ **Unique**: Automatically removes duplicates\n✅ **Fast**: O(1) membership testing\n✅ **Mutable**: Can add/remove items\n✅ **Hashable elements**: Items must be immutable\n\n**Creation:**\n```python\nmy_set = {1, 2, 3}      # With braces\nmy_set = set([1,2,3])   # From list\nempty = set()           # Empty (NOT {})\n```\n\n**Set Operations (Mathematical):**\n\n```python\nA = {1, 2, 3, 4}\nB = {3, 4, 5, 6}\n\nA | B   # Union:        {1,2,3,4,5,6}\nA & B   # Intersection: {3,4}\nA - B   # Difference:    {1,2}\nA ^ B   # Sym Diff:      {1,2,5,6}\n```\n\n**Common Methods:**\n\n| Method | Action |\n|--------|--------|\n| `add(x)` | Add element |\n| `update(iter)` | Add multiple |\n| `remove(x)` | Remove (error if missing) |\n| `discard(x)` | Remove (no error) |\n| `pop()` | Remove arbitrary |\n| `clear()` | Remove all |\n\n**When to Use Sets:**\n\n✅ Remove duplicates\n✅ Membership testing (fast!)\n✅ Mathematical operations (union, intersection)\n✅ Find common/unique elements\n✅ No need for order\n✅ Ensure uniqueness\n\n**vs Other Types:**\n\n| Need | Use |\n|------|-----|\n| Order matters | List |\n| Duplicates needed | List |\n| Unique items only | **Set** |\n| Fast membership | **Set** |\n| Immutable | Tuple/frozenset |\n| Key-value pairs | Dict |\n\n**Common Patterns:**\n```python\n# Remove duplicates\nunique = list(set(my_list))\n\n# Find common\ncommon = set(list1) & set(list2)\n\n# Fast lookup\nallowed = {\"red\", \"green\", \"blue\"}\nif color in allowed:  # O(1) fast!\n\n# Count unique\nunique_count = len(set(items))\n```\n\n**Important:**\n```python\n# ❌ Wrong\nempty = {}  # Dict, not set!\nmy_set[0]   # No indexing!\nmy_set = {[1,2]}  # Lists not hashable!\n\n# ✅ Correct\nempty = set()\nlist(my_set)[0]  # Convert first\nmy_set = {(1,2)}  # Tuples OK\n```\n\nMaster sets for efficient collection operations!"},{"slug":"python-strings","title":"Python Strings - Complete Guide","category":"backend","description":"Strings are one of Python's most used data types - immutable sequences of characters with rich functionality.\n\n**Key Concepts:**\n\n✅ **Immutable**: Cannot change after creation\n✅ **Sequence**: Ordered, indexed, iterable\n✅ **Versatile**: 40+ built-in methods\n✅ **Unicode**: Supports all languages\n\n**Creation:**\n```python\nsingle = 'Hello'\ndouble = \"World\"\nmultiline = '''Multiple\nlines'''\nraw = r'C:\\Users'  # Ignores escapes\n```\n\n**Indexing & Slicing:**\n```python\ntext = \"Python\"\ntext[0]      # 'P' (first)\ntext[-1]     # 'n' (last)\ntext[0:3]    # 'Pyt'\ntext[::-1]   # 'nohtyP' (reverse)\n```\n\n**Essential Methods:**\n\n| Method | Purpose |\n|--------|----------|\n| `upper(), lower()` | Case conversion |\n| `strip()` | Remove whitespace |\n| `split()` | String → List |\n| `join()` | List → String |\n| `replace(old, new)` | Replace substring |\n| `find(sub)` | Find index |\n| `startswith(), endswith()` | Check boundaries |\n\n**String Formatting (Modern):**\n```python\n# f-strings (Python 3.6+)\nname = \"Alice\"\nage = 25\nf\"Name: {name}, Age: {age}\"\nf\"Next year: {age + 1}\"\nf\"Price: ${19.99:.2f}\"  # $19.99\nf\"{1000000:,}\"  # 1,000,000\n```\n\n**Immutability:**\n```python\ntext = \"Hello\"\n# ❌ Cannot modify\n# text[0] = 'J'  # TypeError!\n\n# ✅ Create new\ntext = 'J' + text[1:]  # \"Jello\"\ntext = text.replace('H', 'J')  # \"Jello\"\n```\n\n**Common Patterns:**\n```python\n# Reverse\nreversed = text[::-1]\n\n# Palindrome check\nis_palindrome = text == text[::-1]\n\n# Remove vowels\nno_vowels = ''.join(c for c in text if c not in 'aeiou')\n\n# Word count\nword_count = len(text.split())\n\n# Join list\nwords = ['Python', 'is', 'awesome']\nsentence = ' '.join(words)\n```\n\n**Performance Tips:**\n```python\n# ❌ Slow (creates new string each iteration)\nresult = \"\"\nfor word in words:\n    result += word\n\n# ✅ Fast (single join operation)\nresult = ''.join(words)\n```\n\n**String Operations:**\n```python\n'Hello' + ' ' + 'World'  # Concatenate\n'Ha' * 3  # 'HaHaHa'\n'Python' in text  # Membership\nlen(text)  # Length\n```\n\n**Remember:**\n- Strings are immutable\n- Use f-strings for formatting\n- join() not + for building strings\n- Methods return NEW strings\n- Slicing [::-1] reverses\n\nMaster strings for text processing!"},{"slug":"python-tuples","title":"Python Tuples - Complete Guide","category":"backend","description":"Tuples are Python's immutable, ordered collections - perfect for data that shouldn't change.\n\n**Key Characteristics:**\n\n✅ **Ordered**: Items maintain position\n✅ **Immutable**: Cannot be changed after creation\n✅ **Hashable**: Can be dict keys\n✅ **Fast**: Faster than lists\n✅ **Memory efficient**: Use less memory\n\n**Creation:**\n```python\nmy_tuple = (1, 2, 3)    # With parentheses\nmy_tuple = 1, 2, 3      # Without (packing)\nsingle = (5,)           # Trailing comma!\nempty = ()\n```\n\n**Tuple vs List:**\n\n| Feature | Tuple | List |\n|---------|-------|------|\n| Syntax | `()` | `[]` |\n| Mutable | ❌ No | ✅ Yes |\n| Speed | ✅ Fast | Slower |\n| Memory | ✅ Less | More |\n| Methods | 2 | 11+ |\n| Dict key | ✅ Yes | ❌ No |\n\n**Methods (Only 2!):**\n```python\nmy_tuple.count(value)   # Count occurrences\nmy_tuple.index(value)   # Find first index\n```\n\n**Packing & Unpacking:**\n```python\n# Packing\ncoords = 10, 20  # Creates (10, 20)\n\n# Unpacking\nx, y = coords    # x=10, y=20\n\n# Extended\nfirst, *rest, last = (1,2,3,4,5)\n# first=1, rest=[2,3,4], last=5\n\n# Swapping\na, b = b, a\n```\n\n**When to Use:**\n\n**Use Tuples:**\n- GPS coordinates: `(lat, lon)`\n- RGB colors: `(255, 0, 0)`\n- Database rows\n- Function returns\n- Fixed configuration\n- Dictionary keys\n\n**Use Lists:**\n- Shopping cart (add/remove)\n- To-do list (modify)\n- User input\n- Sorted results\n\n**Important:**\n```python\n# ❌ Cannot modify\nmy_tuple[0] = 10  # TypeError!\n\n# ✅ Can create new\nnew = my_tuple + (10,)\n\n# ❌ Single element\nsingle = (5)  # int!\n\n# ✅ Correct\nsingle = (5,)  # tuple\n```\n\n**Common Patterns:**\n```python\n# Multiple returns\ndef func():\n    return x, y, z\n\na, b, c = func()\n\n# Coordinate pairs\nlocations = [(x1,y1), (x2,y2)]\n\n# Swap\na, b = b, a\n```\n\n**Remember:**\n- Tuples = immutable, faster, hashable\n- Lists = mutable, flexible\n- Use tuples for data that won't change\n- Trailing comma for single element!\n\nChoose tuples for data integrity and performance!"},{"slug":"python-variables","title":"Python Variables - Complete Beginner Guide","category":"backend","description":"Variables are fundamental to programming. They store data that can be used, modified, and reused throughout your program.\n\n**Key Concepts:**\n\n✅ **Creation**: `variable_name = value` (no type declaration)\n✅ **Dynamic Typing**: Variables can change types freely\n✅ **Naming Rules**: Start with letter/underscore, no spaces/special chars/keywords\n✅ **Convention**: Use snake_case, descriptive names, UPPERCASE for constants\n✅ **Multiple Assignment**: `a = b = c = 0` or `x, y = 1, 2`\n✅ **Reassignment**: Variables can be updated: `score = 50`, then `score = 100`\n\n**Common Operations:**\n```python\nage = 25          # Create\nage += 1          # Increment\nprint(type(age))  # Check type\na, b = b, a       # Swap\n```\n\n**Remember:**\n- Start with letter or underscore (_)\n- No spaces (use underscores)\n- No keywords (if, for, while, etc.)\n- Be descriptive (age not a)\n- Case-sensitive (name ≠ Name)\n\n**Python's Power:**\nUnlike Java/C++, Python doesn't require type declarations. Just assign and go!\n\n```python\n# Other languages:\nint age = 25;\nString name = \"Alice\";\n\n# Python:\nage = 25\nname = \"Alice\"\n```\n\nSimple, readable, powerful!"},{"slug":"python-virtual-environments","title":"Python Virtual Environments - Complete Guide","category":"backend","description":"Virtual environments are essential for professional Python development - they isolate project dependencies and prevent conflicts.\n\n**What is Virtual Environment:**\n- Isolated Python installation with own packages\n- Separate from system Python\n- One venv per project\n- Prevents dependency conflicts\n\n**Why Essential:**\n```\nWithout venv:\n  Project A: Django 2.2\n  Project B: Django 4.0\n  Global Python: Only ONE version! ❌\n  \nWith venv:\n  Project A venv: Django 2.2 ✅\n  Project B venv: Django 4.0 ✅\n  Both work! No conflicts! ✅\n```\n\n**Create Virtual Environment:**\n```bash\npython -m venv venv\n```\n\n**Activate:**\n```bash\n# Windows CMD\nvenv\\Scripts\\activate.bat\n\n# Windows PowerShell\nvenv\\Scripts\\Activate.ps1\n\n# Mac/Linux\nsource venv/bin/activate\n\n# Activated: (venv) shows in prompt\n```\n\n**Deactivate:**\n```bash\ndeactivate\n```\n\n**Complete Workflow:**\n```bash\n# 1. Create project\nmkdir my_project && cd my_project\n\n# 2. Create venv\npython -m venv venv\n\n# 3. Activate\nsource venv/bin/activate  # or Windows equivalent\n\n# 4. Install packages\n(venv) $ pip install requests pandas\n\n# 5. Save dependencies\n(venv) $ pip freeze > requirements.txt\n\n# 6. Work on project\n(venv) $ python main.py\n\n# 7. Deactivate\n(venv) $ deactivate\n```\n\n**requirements.txt:**\n```bash\n# Create\npip freeze > requirements.txt\n\n# Install\npip install -r requirements.txt\n\n# Ensures same packages across team/deployments\n```\n\n**Check if Active:**\n1. Prompt shows `(venv)`\n2. `which python` → points to venv\n3. Python: `sys.prefix != sys.base_prefix`\n\n**Best Practices:**\n- ✅ One venv per project\n- ✅ Add venv/ to .gitignore\n- ✅ Commit requirements.txt\n- ✅ Activate before pip install\n- ✅ Use descriptive venv names\n- ❌ Never commit venv folder\n- ❌ Never install in global Python\n\n**.gitignore:**\n```\nvenv/\nenv/\n*.pyc\n__pycache__/\n```\n\n**OS-Specific Commands:**\n\n| OS | Create | Activate |\n|----|--------|----------|\n| Windows CMD | `python -m venv venv` | `venv\\Scripts\\activate.bat` |\n| Windows PS | `python -m venv venv` | `venv\\Scripts\\Activate.ps1` |\n| Mac/Linux | `python -m venv venv` | `source venv/bin/activate` |\n\n**Common Issues:**\n\n**PowerShell:**\n```powershell\n# Error: running scripts disabled\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n```\n\n**Forgot to activate:**\n```bash\n# ❌ No (venv) in prompt\n$ pip install package  # Installs globally!\n\n# ✅ Activate first\n$ source venv/bin/activate\n(venv) $ pip install package  # Safe\n```\n\n**Benefits:**\n1. **Isolation**: Each project independent\n2. **No conflicts**: Different package versions\n3. **Clean global**: System Python uncluttered\n4. **Reproducible**: requirements.txt recreates environment\n5. **Testing**: Test different Python/package versions\n6. **Deployment**: Exact dependencies in production\n\n**Remember:**\n- Always use virtual environments\n- Never commit venv/ folder\n- Always create requirements.txt\n- One venv = one project\n- Activate before installing\n\nMaster virtual environments for professional Python development!"},{"slug":"python","title":"Python Masterclass","category":"backend","description":"Master Python internals, async programming, and advanced patterns"}]},"__N_SSG":true}