{"pageProps":{"tutorial":{"title":"Python Interview Preparation - Complete Guide","slug":"python-interview-preparation","subject":"Python","category":"backend","level":"Advanced","estimated_read_time":"25 minutes","prerequisites":["Strong Python fundamentals","Data structures and algorithms","Object-oriented programming","Problem-solving skills"],"learning_objectives":["Master common Python interview questions","Understand tricky Python concepts","Write efficient, Pythonic code","Handle edge cases confidently","Apply best practices in coding interviews","Optimize code for performance","Debug complex problems","Communicate technical reasoning effectively"],"theory":"## Python Interview Overview\n\nPython interviews typically test:\n1. **Language fundamentals**: Data types, operators, control flow\n2. **Data structures**: Lists, dicts, sets, tuples\n3. **Algorithms**: Searching, sorting, recursion\n4. **OOP concepts**: Classes, inheritance, polymorphism\n5. **Problem-solving**: Logic, edge cases, optimization\n6. **Best practices**: PEP 8, Pythonic code, performance\n\n---\n\n## Tricky Concepts\n\n### 1. Mutable Default Arguments\n\n**The Problem:**\n```python\ndef add_item(item, items=[]):\n    items.append(item)\n    return items\n\nprint(add_item(1))  # [1]\nprint(add_item(2))  # [1, 2] ← Unexpected!\nprint(add_item(3))  # [1, 2, 3] ← List persists!\n```\n\n**Why?** Default argument is evaluated once at function definition, not each call. The same list object is reused!\n\n**Solution:**\n```python\ndef add_item(item, items=None):\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n\nprint(add_item(1))  # [1]\nprint(add_item(2))  # [2] ← Correct!\n```\n\n**Key Insight**: Never use mutable objects (list, dict) as default arguments.\n\n### 2. Late Binding Closures\n\n**The Problem:**\n```python\nfunctions = []\nfor i in range(3):\n    functions.append(lambda: i)\n\nfor f in functions:\n    print(f())  # 2, 2, 2 ← All print 2!\n```\n\n**Why?** Lambda captures variable `i` by reference, not value. When functions execute, `i` is already 2 (final value).\n\n**Solution:**\n```python\n# Method 1: Default argument\nfunctions = [lambda i=i: i for i in range(3)]\n\n# Method 2: functools.partial\nfrom functools import partial\nfunctions = [partial(lambda i: i, i) for i in range(3)]\n\nfor f in functions:\n    print(f())  # 0, 1, 2 ← Correct!\n```\n\n### 3. Shallow vs Deep Copy\n\n**Shallow Copy:**\n```python\nimport copy\n\noriginal = [[1, 2], [3, 4]]\nshallow = copy.copy(original)\n# or: shallow = original.copy()\n# or: shallow = list(original)\n\nshallow[0][0] = 'X'\nprint(original)  # [['X', 2], [3, 4]] ← Modified!\nprint(shallow)   # [['X', 2], [3, 4]]\n```\n\n**Deep Copy:**\n```python\ndeep = copy.deepcopy(original)\ndeep[0][0] = 'Y'\nprint(original)  # [[1, 2], [3, 4]] ← Unchanged!\nprint(deep)      # [['Y', 2], [3, 4]]\n```\n\n**Key Insight**: Shallow copy copies references, deep copy copies recursively.\n\n### 4. Truth Value Testing\n\n**Falsy values in Python:**\n```python\n# All evaluate to False\nbool(None)      # False\nbool(False)     # False\nbool(0)         # False\nbool(0.0)       # False\nbool('')        # False\nbool([])        # False\nbool(())        # False\nbool({})        # False\nbool(set())     # False\n```\n\n**Gotcha:**\n```python\nmylist = []\nif not mylist:  # Correct\n    print(\"List is empty\")\n\nif mylist == []:  # Works but not idiomatic\n    print(\"List is empty\")\n\nif len(mylist) == 0:  # Not Pythonic\n    print(\"List is empty\")\n```\n\n### 5. is vs ==\n\n```python\na = [1, 2, 3]\nb = [1, 2, 3]\nc = a\n\nprint(a == b)  # True (same values)\nprint(a is b)  # False (different objects)\nprint(a is c)  # True (same object)\n\n# Special case: Small integers\nx = 256\ny = 256\nprint(x is y)  # True (cached)\n\nz = 257\nw = 257\nprint(z is w)  # False (not cached)\n```\n\n**Rule**: Use `==` for value comparison, `is` for identity.\n\n### 6. Global Interpreter Lock (GIL)\n\n**Key Points:**\n- Python has GIL: only one thread executes Python bytecode at a time\n- Affects CPU-bound multi-threaded programs\n- I/O-bound programs not affected\n- Solutions: multiprocessing, async/await\n\n### 7. *args and **kwargs\n\n```python\ndef function(*args, **kwargs):\n    print(f\"args: {args}\")      # Tuple\n    print(f\"kwargs: {kwargs}\")  # Dict\n\nfunction(1, 2, 3, a=4, b=5)\n# args: (1, 2, 3)\n# kwargs: {'a': 4, 'b': 5}\n```\n\n**Unpacking:**\n```python\ndef add(a, b, c):\n    return a + b + c\n\nargs = [1, 2, 3]\nprint(add(*args))  # 6\n\nkwargs = {'a': 1, 'b': 2, 'c': 3}\nprint(add(**kwargs))  # 6\n```\n\n---\n\n## Common Interview Questions\n\n### Q1: Reverse a String\n\n**Multiple approaches:**\n```python\ns = \"hello\"\n\n# Method 1: Slicing (best)\nreversed_s = s[::-1]  # \"olleh\"\n\n# Method 2: reversed() function\nreversed_s = ''.join(reversed(s))\n\n# Method 3: Loop\nreversed_s = ''\nfor char in s:\n    reversed_s = char + reversed_s\n\n# Method 4: List reverse\nchars = list(s)\nchars.reverse()\nreversed_s = ''.join(chars)\n```\n\n### Q2: Check Palindrome\n\n```python\ndef is_palindrome(s):\n    # Clean string: remove spaces, lowercase\n    s = s.replace(' ', '').lower()\n    return s == s[::-1]\n\nprint(is_palindrome(\"A man a plan a canal Panama\"))  # True\nprint(is_palindrome(\"race a car\"))  # False\n```\n\n### Q3: Find First Non-Repeating Character\n\n```python\ndef first_non_repeating(s):\n    from collections import Counter\n    \n    counts = Counter(s)\n    for char in s:\n        if counts[char] == 1:\n            return char\n    return None\n\nprint(first_non_repeating(\"leetcode\"))  # 'l'\nprint(first_non_repeating(\"loveleetcode\"))  # 'v'\n```\n\n### Q4: Two Sum Problem\n\n```python\ndef two_sum(nums, target):\n    \"\"\"\n    Find indices of two numbers that add up to target.\n    Time: O(n), Space: O(n)\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return None\n\nprint(two_sum([2, 7, 11, 15], 9))  # [0, 1]\n```\n\n### Q5: FizzBuzz\n\n```python\ndef fizzbuzz(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 15 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result\n\nprint(fizzbuzz(15))\n```\n\n### Q6: Remove Duplicates from List\n\n```python\n# Method 1: Set (doesn't preserve order)\nnums = [1, 2, 2, 3, 4, 4, 5]\nunique = list(set(nums))  # Order not guaranteed\n\n# Method 2: Dict (preserves order, Python 3.7+)\nunique = list(dict.fromkeys(nums))\n\n# Method 3: Loop (preserves order)\nunique = []\nfor num in nums:\n    if num not in unique:\n        unique.append(num)\n\n# Method 4: List comprehension with seen set\nseen = set()\nunique = [x for x in nums if not (x in seen or seen.add(x))]\n```\n\n### Q7: Flatten Nested List\n\n```python\ndef flatten(nested_list):\n    result = []\n    for item in nested_list:\n        if isinstance(item, list):\n            result.extend(flatten(item))  # Recursive\n        else:\n            result.append(item)\n    return result\n\nnested = [1, [2, 3, [4, 5]], 6, [7, [8, 9]]]\nprint(flatten(nested))  # [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n### Q8: Find Missing Number\n\n```python\ndef find_missing(nums):\n    \"\"\"\n    Array contains 0 to n with one number missing.\n    Time: O(n), Space: O(1)\n    \"\"\"\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum\n\nprint(find_missing([0, 1, 3]))  # 2\nprint(find_missing([0, 1, 2, 3, 4, 6]))  # 5\n```\n\n### Q9: Valid Parentheses\n\n```python\ndef is_valid_parentheses(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:\n            top = stack.pop() if stack else '#'\n            if mapping[char] != top:\n                return False\n        else:\n            stack.append(char)\n    \n    return not stack\n\nprint(is_valid_parentheses(\"()\"))  # True\nprint(is_valid_parentheses(\"()[]{}\"))  # True\nprint(is_valid_parentheses(\"(]\"))  # False\n```\n\n### Q10: Anagram Check\n\n```python\ndef is_anagram(s1, s2):\n    # Method 1: Sorted\n    return sorted(s1) == sorted(s2)\n    \n    # Method 2: Counter\n    from collections import Counter\n    return Counter(s1) == Counter(s2)\n\nprint(is_anagram(\"listen\", \"silent\"))  # True\nprint(is_anagram(\"hello\", \"world\"))  # False\n```\n\n---\n\n## Best Practices\n\n### 1. PEP 8 Style Guide\n\n```python\n# Naming conventions\nMY_CONSTANT = 100           # Constants: UPPER_CASE\nmy_variable = 10            # Variables: snake_case\nmy_function()               # Functions: snake_case\n\nclass MyClass:              # Classes: PascalCase\n    def my_method(self):    # Methods: snake_case\n        pass\n\n# Indentation: 4 spaces\ndef function():\n    if condition:\n        do_something()\n    else:\n        do_other()\n\n# Line length: 79 characters\nlong_variable = (some_long_expression +\n                 another_expression)\n\n# Imports\nimport os\nimport sys\n\nfrom collections import Counter  # One per line\n```\n\n### 2. Pythonic Code\n\n```python\n# List comprehension (good)\nsquares = [x**2 for x in range(10)]\n\n# Instead of loop (verbose)\nsquares = []\nfor x in range(10):\n    squares.append(x**2)\n\n# Dictionary comprehension\nsquare_dict = {x: x**2 for x in range(5)}\n\n# Enumerate instead of range(len())\nfor i, item in enumerate(items):\n    print(f\"{i}: {item}\")\n\n# zip for parallel iteration\nfor name, age in zip(names, ages):\n    print(f\"{name} is {age}\")\n\n# any/all for boolean checks\nif any(x > 10 for x in numbers):\n    print(\"At least one > 10\")\n\nif all(x > 0 for x in numbers):\n    print(\"All positive\")\n```\n\n### 3. Context Managers\n\n```python\n# Always use with for files\nwith open('file.txt', 'r') as f:\n    content = f.read()\n# File automatically closed\n\n# Custom context manager\nfrom contextlib import contextmanager\n\n@contextmanager\ndef timer():\n    import time\n    start = time.time()\n    yield\n    end = time.time()\n    print(f\"Time: {end - start:.2f}s\")\n\nwith timer():\n    # Code to time\n    sum(range(1000000))\n```\n\n### 4. Exception Handling\n\n```python\n# Specific exceptions\ntry:\n    result = risky_operation()\nexcept ValueError as e:\n    print(f\"Value error: {e}\")\nexcept FileNotFoundError:\n    print(\"File not found\")\nexcept Exception as e:\n    print(f\"Unexpected: {e}\")\nfinally:\n    cleanup()\n\n# EAFP vs LBYL\n# EAFP (Easier to Ask Forgiveness than Permission)\ntry:\n    value = my_dict[key]\nexcept KeyError:\n    value = default\n\n# LBYL (Look Before You Leap)\nif key in my_dict:\n    value = my_dict[key]\nelse:\n    value = default\n\n# EAFP is more Pythonic\n```\n\n---\n\n## Edge Cases to Consider\n\n### 1. Empty Inputs\n```python\ndef process_list(items):\n    if not items:  # Check for empty\n        return []\n    # Process...\n```\n\n### 2. None Values\n```python\ndef calculate(value):\n    if value is None:\n        return 0\n    return value * 2\n```\n\n### 3. Single Element\n```python\ndef find_max(nums):\n    if len(nums) == 1:\n        return nums[0]\n    # Continue...\n```\n\n### 4. Negative Numbers\n```python\ndef absolute_sum(nums):\n    return sum(abs(x) for x in nums)\n```\n\n### 5. Large Inputs\n```python\n# Use generators for large data\ndef process_large_file(filepath):\n    with open(filepath) as f:\n        for line in f:  # Generator, not list\n            yield process(line)\n```\n\n---\n\n## Performance Optimization\n\n### 1. Use Built-in Functions\n```python\n# Slow\ntotal = 0\nfor num in numbers:\n    total += num\n\n# Fast\ntotal = sum(numbers)\n```\n\n### 2. List Comprehension vs Loop\n```python\nimport timeit\n\n# Comprehension (faster)\nresult = [x**2 for x in range(1000)]\n\n# Loop (slower)\nresult = []\nfor x in range(1000):\n    result.append(x**2)\n```\n\n### 3. Set for Membership Testing\n```python\n# Slow O(n)\nif item in my_list:\n    pass\n\n# Fast O(1)\nif item in my_set:\n    pass\n```\n\n### 4. Join vs Concatenation\n```python\n# Slow\nresult = ''\nfor s in strings:\n    result += s\n\n# Fast\nresult = ''.join(strings)\n```","syntax":"# Common patterns\n\n# List comprehension\n[expr for item in iterable if condition]\n\n# Dict comprehension\n{key: value for item in iterable}\n\n# Generator expression\n(expr for item in iterable)\n\n# Lambda\nlambda args: expression\n\n# Map, filter, reduce\nmap(function, iterable)\nfilter(function, iterable)\nfrom functools import reduce\nreduce(function, iterable)\n\n# Any, all\nany(iterable)\nall(iterable)\n\n# Enumerate\nfor i, item in enumerate(iterable):\n\n# Zip\nfor a, b in zip(iter1, iter2):\n\n# Context manager\nwith expression as variable:\n\n# Exception handling\ntry:\nexcept SpecificException as e:\nfinally:\n\n# Unpacking\na, b, *rest = [1, 2, 3, 4, 5]","examples":[{"code":"# Example 1: Mutable Default Argument Gotcha\ndef append_to_list(item, my_list=[]):\n    my_list.append(item)\n    return my_list\n\nprint(\"Call 1:\", append_to_list(1))\nprint(\"Call 2:\", append_to_list(2))\nprint(\"Call 3:\", append_to_list(3))\n\nprint(\"\\nFixed version:\")\ndef append_to_list_fixed(item, my_list=None):\n    if my_list is None:\n        my_list = []\n    my_list.append(item)\n    return my_list\n\nprint(\"Call 1:\", append_to_list_fixed(1))\nprint(\"Call 2:\", append_to_list_fixed(2))\nprint(\"Call 3:\", append_to_list_fixed(3))","output":"Call 1: [1]\nCall 2: [1, 2]\nCall 3: [1, 2, 3]\n\nFixed version:\nCall 1: [1]\nCall 2: [2]\nCall 3: [3]","explanation":"Mutable default arguments are evaluated once at function definition. Same object reused across calls! Solution: use None as default, create new object inside function."},{"code":"# Example 2: Two Sum with Hash Map\ndef two_sum(nums, target):\n    \"\"\"\n    Find indices where nums[i] + nums[j] = target.\n    Time: O(n), Space: O(n)\n    \"\"\"\n    seen = {}  # {value: index}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    \n    return None\n\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(f\"Input: {nums}, Target: {target}\")\nprint(f\"Indices: {result}\")\nprint(f\"Values: {nums[result[0]]} + {nums[result[1]]} = {target}\")","output":"Input: [2, 7, 11, 15], Target: 9\nIndices: [0, 1]\nValues: 2 + 7 = 9","explanation":"Hash map approach: for each number, check if complement (target - num) exists in seen dict. If yes, return indices. Store current number for future lookups. Single pass O(n) solution."},{"code":"# Example 3: Palindrome Check (Multiple Methods)\ndef is_palindrome_simple(s):\n    # Remove spaces, lowercase, compare with reverse\n    s = s.replace(' ', '').lower()\n    return s == s[::-1]\n\ndef is_palindrome_two_pointer(s):\n    # Clean string\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    \n    # Two pointers\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n\ntest_cases = [\n    \"racecar\",\n    \"A man a plan a canal Panama\",\n    \"hello\",\n    \"Was it a car or a cat I saw?\"\n]\n\nfor test in test_cases:\n    result1 = is_palindrome_simple(test)\n    result2 = is_palindrome_two_pointer(test)\n    print(f\"{test!r:40} → {result1} (both methods agree: {result1 == result2})\")","output":"'racecar'                                → True (both methods agree: True)\n'A man a plan a canal Panama'           → True (both methods agree: True)\n'hello'                                  → False (both methods agree: True)\n'Was it a car or a cat I saw?'          → True (both methods agree: True)","explanation":"Two approaches: 1) Clean string and compare with reverse (simple, Pythonic). 2) Two-pointer technique (space efficient). Both handle spaces, punctuation, case-insensitivity."},{"code":"# Example 4: Flatten Nested List (Recursive)\ndef flatten(nested_list):\n    \"\"\"Recursively flatten arbitrarily nested list.\"\"\"\n    result = []\n    \n    for item in nested_list:\n        if isinstance(item, list):\n            # Recursive call for nested lists\n            result.extend(flatten(item))\n        else:\n            result.append(item)\n    \n    return result\n\nnested = [1, [2, 3, [4, 5]], 6, [7, [8, [9, 10]]]]\nflat = flatten(nested)\nprint(f\"Nested: {nested}\")\nprint(f\"Flat:   {flat}\")\n\n# Edge cases\nprint(f\"Empty: {flatten([])}\")\nprint(f\"No nesting: {flatten([1, 2, 3])}\")\nprint(f\"Deep nesting: {flatten([[[[1]]]])}\")","output":"Nested: [1, [2, 3, [4, 5]], 6, [7, [8, [9, 10]]]]\nFlat:   [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nEmpty: []\nNo nesting: [1, 2, 3]\nDeep nesting: [1]","explanation":"Recursive solution: check if item is list. If yes, recursively flatten and extend result. If no, append to result. Handles arbitrary nesting depth. Also handles edge cases: empty, no nesting, deep nesting."},{"code":"# Example 5: Remove Duplicates (Preserve Order)\ndef remove_duplicates_order(items):\n    \"\"\"Remove duplicates while preserving order.\"\"\"\n    # Python 3.7+: dict maintains insertion order\n    return list(dict.fromkeys(items))\n\ndef remove_duplicates_set(items):\n    \"\"\"Remove duplicates (no order guarantee).\"\"\"\n    return list(set(items))\n\nnums = [1, 2, 2, 3, 4, 4, 5, 1, 3]\nprint(f\"Original: {nums}\")\nprint(f\"Order preserved: {remove_duplicates_order(nums)}\")\nprint(f\"Set (unordered): {remove_duplicates_set(nums)}\")\n\n# With strings\nwords = ['apple', 'banana', 'apple', 'cherry', 'banana']\nprint(f\"\\nWords: {words}\")\nprint(f\"Unique (ordered): {remove_duplicates_order(words)}\")","output":"Original: [1, 2, 2, 3, 4, 4, 5, 1, 3]\nOrder preserved: [1, 2, 3, 4, 5]\nSet (unordered): [1, 2, 3, 4, 5]\n\nWords: ['apple', 'banana', 'apple', 'cherry', 'banana']\nUnique (ordered): ['apple', 'banana', 'cherry']","explanation":"dict.fromkeys() preserves insertion order (Python 3.7+). Creates dict with items as keys, converts back to list. set() is faster but doesn't preserve order. Choose based on requirements."},{"code":"# Example 6: FizzBuzz (Clean Implementation)\ndef fizzbuzz(n):\n    \"\"\"Classic FizzBuzz problem.\"\"\"\n    result = []\n    for i in range(1, n + 1):\n        output = \"\"\n        if i % 3 == 0:\n            output += \"Fizz\"\n        if i % 5 == 0:\n            output += \"Buzz\"\n        result.append(output or str(i))\n    return result\n\nprint(\"FizzBuzz(15):\")\nfor i, value in enumerate(fizzbuzz(15), 1):\n    print(f\"{i:2d}: {value}\")","output":"FizzBuzz(15):\n 1: 1\n 2: 2\n 3: Fizz\n 4: 4\n 5: Buzz\n 6: Fizz\n 7: 7\n 8: 8\n 9: Fizz\n10: Buzz\n11: 11\n12: Fizz\n13: 13\n14: 14\n15: FizzBuzz","explanation":"Clean FizzBuzz: build output string conditionally. Check divisibility by 3 (Fizz), 5 (Buzz). Both → FizzBuzz. Neither → number. Uses 'output or str(i)' idiom (empty string is falsy)."},{"code":"# Example 7: Valid Parentheses (Stack-based)\ndef is_valid_parentheses(s):\n    \"\"\"Check if parentheses are balanced.\"\"\"\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:  # Closing bracket\n            top = stack.pop() if stack else '#'\n            if mapping[char] != top:\n                return False\n        else:  # Opening bracket\n            stack.append(char)\n    \n    return len(stack) == 0\n\ntest_cases = [\n    (\"()\", True),\n    (\"()[]{}\", True),\n    (\"(]\", False),\n    (\"([)]\", False),\n    (\"{[]}\", True),\n    (\"(((\", False)\n]\n\nfor test, expected in test_cases:\n    result = is_valid_parentheses(test)\n    status = \"✓\" if result == expected else \"✗\"\n    print(f\"{status} {test!r:10} → {result}\")","output":"✓ '()'       → True\n✓ '()[]{}' → True\n✓ '(]'       → False\n✓ '([)]'    → False\n✓ '{[]}'    → True\n✓ '((('      → False","explanation":"Stack-based approach: push opening brackets onto stack. For closing brackets, pop and check match. Edge cases: empty stack when popping (use '#'), unmatched at end (check stack empty)."}],"common_mistakes":[{"mistake":"Using mutable default arguments","correction":"Use None, create mutable inside function","example":"❌ def func(items=[]):\n       items.append(1)\n\n✅ def func(items=None):\n       if items is None:\n           items = []\n       items.append(1)"},{"mistake":"Modifying list while iterating","correction":"Iterate over copy or use list comprehension","example":"❌ for item in my_list:\n       my_list.remove(item)\n\n✅ for item in my_list.copy():\n       my_list.remove(item)\n\n✅ my_list = [x for x in my_list if condition]"},{"mistake":"Using == instead of is for None","correction":"Always use 'is' or 'is not' with None","example":"❌ if value == None:\n\n✅ if value is None:\n\n✅ if value is not None:"},{"mistake":"Catching bare except","correction":"Catch specific exceptions","example":"❌ try:\n       code()\n   except:  # Catches EVERYTHING\n       pass\n\n✅ try:\n       code()\n   except ValueError as e:\n       handle(e)\n   except Exception as e:\n       log(e)"},{"mistake":"Using key in dict.keys() instead of key in dict","correction":"Use 'in' directly on dict","example":"❌ if key in dict.keys():  # Unnecessary\n\n✅ if key in dict:  # Faster, cleaner"}],"interview_questions":[{"question":"Explain the difference between list, tuple, and set.","difficulty":"Easy","answer":"List: mutable, ordered, allows duplicates. Tuple: immutable, ordered, allows duplicates. Set: mutable, unordered, unique elements only. List for changing data, tuple for fixed, set for uniqueness/membership testing."},{"question":"What is the GIL and how does it affect Python?","difficulty":"Hard","answer":"Global Interpreter Lock ensures only one thread executes Python bytecode at a time. Affects CPU-bound multi-threaded programs (can't use multiple cores). Solutions: multiprocessing for CPU-bound, async/await for I/O-bound."},{"question":"Explain shallow vs deep copy.","difficulty":"Medium","answer":"Shallow copy creates new object but copies references to nested objects. Deep copy recursively copies all objects. Example: shallow copy of [[1,2]] shares inner list. Deep copy creates independent inner list."},{"question":"What are decorators? Give an example.","difficulty":"Medium","answer":"Decorators modify function behavior. Syntax: @decorator above function. Example: @timer measures execution time. Implementation: function that takes/returns function. Common: @property, @staticmethod, @classmethod."},{"question":"Explain list comprehension vs generator expression.","difficulty":"Medium","answer":"List comprehension [x for x] creates list in memory. Generator (x for x) creates iterator, lazy evaluation. Generator more memory-efficient for large data. List when need multiple passes, generator for single pass."},{"question":"What is the difference between is and ==?","difficulty":"Easy","answer":"== checks value equality. is checks identity (same object). Example: [1,2] == [1,2] is True, but [1,2] is [1,2] is False (different objects). Use is for None, True, False."},{"question":"Explain *args and **kwargs.","difficulty":"Easy","answer":"*args captures positional arguments as tuple. **kwargs captures keyword arguments as dict. Used for variable arguments. Example: def func(*args, **kwargs) accepts any arguments. Unpacking: func(*list, **dict)."},{"question":"How do you reverse a string?","difficulty":"Easy","answer":"Best: s[::-1] using slicing. Also: ''.join(reversed(s)) or loop. Slicing is most Pythonic and efficient."},{"question":"What are Python's falsy values?","difficulty":"Easy","answer":"None, False, 0, 0.0, '', [], (), {}, set(). Use 'if not x' to check for empty/falsy. Pythonic: if not my_list instead of if len(my_list) == 0."},{"question":"Explain the time complexity of common operations.","difficulty":"Medium","answer":"List: access O(1), append O(1), insert O(n), search O(n). Dict: access/insert/delete O(1) average. Set: add/remove/contains O(1) average. Sorting O(n log n)."}],"practice_problems":[{"difficulty":"Beginner","problem":"Write function to find most frequent element in list.","hint":"Use Counter from collections","solution":"from collections import Counter\n\ndef most_frequent(items):\n    if not items:\n        return None\n    counter = Counter(items)\n    return counter.most_common(1)[0][0]\n\nprint(most_frequent([1, 2, 2, 3, 3, 3]))  # 3"},{"difficulty":"Intermediate","problem":"Implement function to rotate list by k positions.","hint":"Use slicing","solution":"def rotate_list(nums, k):\n    if not nums:\n        return []\n    k = k % len(nums)  # Handle k > len\n    return nums[-k:] + nums[:-k]\n\nprint(rotate_list([1,2,3,4,5], 2))  # [4,5,1,2,3]"},{"difficulty":"Intermediate","problem":"Find all pairs in list that sum to target.","hint":"Use set for O(n) solution","solution":"def find_pairs(nums, target):\n    seen = set()\n    pairs = set()\n    \n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            pairs.add((min(num, complement), max(num, complement)))\n        seen.add(num)\n    \n    return list(pairs)\n\nprint(find_pairs([1,2,3,4,5], 5))  # [(1,4), (2,3)]"},{"difficulty":"Advanced","problem":"Implement LRU Cache using OrderedDict.","hint":"Use OrderedDict.move_to_end()","solution":"from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nprint(cache.get(1))  # 1\ncache.put(3, 3)  # Evicts 2\nprint(cache.get(2))  # -1"},{"difficulty":"Advanced","problem":"Implement function to find longest substring without repeating characters.","hint":"Sliding window with set","solution":"def longest_substring(s):\n    char_set = set()\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\nprint(longest_substring(\"abcabcbb\"))  # 3 (\"abc\")\nprint(longest_substring(\"bbbbb\"))  # 1 (\"b\")"}],"real_world_use_cases":[{"scenario":"Rate Limiter Implementation","description":"Implement API rate limiter using sliding window","code":"from collections import deque\nimport time\n\nclass RateLimiter:\n    def __init__(self, max_requests, window_seconds):\n        self.max_requests = max_requests\n        self.window = window_seconds\n        self.requests = deque()\n    \n    def is_allowed(self):\n        now = time.time()\n        \n        # Remove old requests outside window\n        while self.requests and self.requests[0] < now - self.window:\n            self.requests.popleft()\n        \n        # Check if under limit\n        if len(self.requests) < self.max_requests:\n            self.requests.append(now)\n            return True\n        return False\n\n# Usage: 5 requests per 10 seconds\nlimiter = RateLimiter(5, 10)\n\nfor i in range(7):\n    if limiter.is_allowed():\n        print(f\"Request {i+1}: Allowed\")\n    else:\n        print(f\"Request {i+1}: Rate limited\")\n    time.sleep(1)"},{"scenario":"URL Shortener","description":"Simple URL shortener with collision handling","code":"import random\nimport string\n\nclass URLShortener:\n    def __init__(self):\n        self.url_map = {}  # short -> long\n        self.reverse_map = {}  # long -> short\n    \n    def _generate_short_code(self, length=6):\n        chars = string.ascii_letters + string.digits\n        while True:\n            code = ''.join(random.choice(chars) for _ in range(length))\n            if code not in self.url_map:\n                return code\n    \n    def shorten(self, long_url):\n        # Check if already shortened\n        if long_url in self.reverse_map:\n            return self.reverse_map[long_url]\n        \n        short_code = self._generate_short_code()\n        self.url_map[short_code] = long_url\n        self.reverse_map[long_url] = short_code\n        return short_code\n    \n    def expand(self, short_code):\n        return self.url_map.get(short_code, None)\n\nshortener = URLShortener()\nshort = shortener.shorten(\"https://example.com/very/long/url\")\nprint(f\"Short URL: {short}\")\nprint(f\"Expanded: {shortener.expand(short)}\")"},{"scenario":"Cache with Expiration","description":"Simple cache with TTL (Time To Live)","code":"import time\n\nclass ExpiringCache:\n    def __init__(self, ttl_seconds=300):\n        self.cache = {}  # {key: (value, expiry_time)}\n        self.ttl = ttl_seconds\n    \n    def set(self, key, value):\n        expiry = time.time() + self.ttl\n        self.cache[key] = (value, expiry)\n    \n    def get(self, key):\n        if key not in self.cache:\n            return None\n        \n        value, expiry = self.cache[key]\n        if time.time() > expiry:\n            del self.cache[key]\n            return None\n        \n        return value\n    \n    def cleanup(self):\n        \"\"\"Remove expired entries\"\"\"\n        now = time.time()\n        expired = [k for k, (v, exp) in self.cache.items() if now > exp]\n        for key in expired:\n            del self.cache[key]\n        return len(expired)\n\ncache = ExpiringCache(ttl_seconds=5)\ncache.set(\"user_123\", {\"name\": \"Alice\", \"email\": \"alice@example.com\"})\nprint(f\"Immediate: {cache.get('user_123')}\")\ntime.sleep(6)\nprint(f\"After 6s: {cache.get('user_123')}\")"},{"scenario":"Event System","description":"Simple pub-sub event system","code":"class EventSystem:\n    def __init__(self):\n        self.listeners = {}  # {event_name: [callbacks]}\n    \n    def subscribe(self, event_name, callback):\n        if event_name not in self.listeners:\n            self.listeners[event_name] = []\n        self.listeners[event_name].append(callback)\n    \n    def unsubscribe(self, event_name, callback):\n        if event_name in self.listeners:\n            self.listeners[event_name].remove(callback)\n    \n    def emit(self, event_name, *args, **kwargs):\n        if event_name in self.listeners:\n            for callback in self.listeners[event_name]:\n                callback(*args, **kwargs)\n\n# Usage\nevents = EventSystem()\n\ndef on_user_login(user_id, username):\n    print(f\"User logged in: {username} (ID: {user_id})\")\n\ndef send_welcome_email(user_id, username):\n    print(f\"Sending welcome email to {username}\")\n\nevents.subscribe('user_login', on_user_login)\nevents.subscribe('user_login', send_welcome_email)\n\nevents.emit('user_login', user_id=123, username='alice')"}],"exam_notes":["Lists are mutable, tuples immutable, sets unordered/unique","Dict/set operations are O(1) average, list search is O(n)","Use list comprehension over loops for better performance","Generators save memory with lazy evaluation","is checks identity, == checks value equality","Use is/is not for None, True, False comparisons","Mutable default arguments are evaluated once (gotcha!)","Closures capture variables by reference (late binding)","Deep copy vs shallow copy: recursive vs reference copy","GIL affects CPU-bound multi-threading, not I/O-bound","*args captures positional args as tuple","**kwargs captures keyword args as dict","Use with for context managers (files, locks)","EAFP (try/except) more Pythonic than LBYL (if checks)","Falsy values: None, False, 0, '', [], {}, ()","Join strings with ''.join() not += in loops","enumerate() better than range(len())","any()/all() for boolean checks on iterables","Set for fast membership testing O(1)","PEP 8: snake_case for functions/variables, PascalCase for classes"],"summary":"Python interview preparation requires mastering fundamentals, understanding tricky concepts, and writing efficient, Pythonic code.\n\n**Key Tricky Concepts:**\n\n1. **Mutable Default Arguments:**\n```python\n❌ def func(items=[]):\n✅ def func(items=None):\n       if items is None: items = []\n```\n\n2. **Late Binding Closures:**\n```python\n# All print 2!\nfuncs = [lambda: i for i in range(3)]\n\n# Fix: use default argument\nfuncs = [lambda i=i: i for i in range(3)]\n```\n\n3. **Shallow vs Deep Copy:**\n```python\nshallow = list.copy()  # Copies references\ndeep = copy.deepcopy()  # Recursive copy\n```\n\n**Common Interview Problems:**\n\n```python\n# Two Sum - O(n)\ndef two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        if target - num in seen:\n            return [seen[target - num], i]\n        seen[num] = i\n\n# Valid Parentheses - Stack\ndef is_valid(s):\n    stack = []\n    pairs = {')':'(', '}':'{', ']':'['}\n    for c in s:\n        if c in pairs:\n            if not stack or stack.pop() != pairs[c]:\n                return False\n        else:\n            stack.append(c)\n    return not stack\n\n# Palindrome\ndef is_palindrome(s):\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\n```\n\n**Best Practices:**\n\n```python\n# Pythonic idioms\nsquares = [x**2 for x in range(10)]\nfor i, item in enumerate(items):\nfor a, b in zip(list1, list2):\nif any(x > 10 for x in nums):\nif all(x > 0 for x in nums):\n\n# Context managers\nwith open('file.txt') as f:\n    content = f.read()\n\n# Specific exceptions\ntry:\n    risky()\nexcept ValueError as e:\n    handle(e)\n```\n\n**Performance Tips:**\n\n```python\n# Use built-ins (fast)\nsum(numbers)\nmax(numbers)\nany(condition)\n\n# Set for membership O(1)\nif item in my_set:  # Fast\n\n# Join strings\n''.join(strings)  # Fast\nresult += string  # Slow in loop\n\n# List comprehension\n[x**2 for x in nums]  # Faster than loop\n```\n\n**Edge Cases:**\n- Empty inputs: [], '', None\n- Single element: [1]\n- Negative numbers\n- Duplicates\n- Large inputs\n- Unicode/special characters\n\n**Time Complexities:**\n| Operation | List | Dict | Set |\n|-----------|------|------|-----|\n| Access | O(1) | O(1) | N/A |\n| Search | O(n) | O(1) | O(1) |\n| Insert | O(n) | O(1) | O(1) |\n| Delete | O(n) | O(1) | O(1) |\n\n**Interview Tips:**\n1. Clarify requirements\n2. Discuss approach before coding\n3. Consider edge cases\n4. Think about time/space complexity\n5. Write clean, readable code\n6. Test with examples\n7. Optimize if asked\n\n**Common Mistakes to Avoid:**\n- ❌ Mutable default arguments\n- ❌ Modifying list while iterating\n- ❌ Using == instead of is for None\n- ❌ Bare except clauses\n- ❌ Forgetting edge cases\n\nPractice consistently and master both fundamentals and advanced concepts!"}},"__N_SSG":true}