[
    {
        "id": "amz-dsa-1",
        "title": "Merge k Sorted Lists",
        "type": "DSA",
        "category": "Linked Lists & Heaps",
        "difficulty": "Hard",
        "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
        "constraints": [
            "k == lists.length",
            "0 <= k <= 10^4",
            "0 <= lists[i].length <= 500",
            "-10^4 <= lists[i][j] <= 10^4"
        ],
        "solutionSlug": "linked-list-intro",
        "templates": {
            "javascript": {
                "initialCode": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nvar mergeKLists = function(lists) {\n    \n};"
            },
            "python": {
                "initialCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        pass"
            }
        },
        "testCases": [
            {
                "input": "[[1,4,5],[1,3,4],[2,6]]",
                "output": "[1,1,2,3,4,4,5,6]"
            },
            {
                "input": "[]",
                "output": "[]"
            },
            {
                "input": "[[]]",
                "output": "[]"
            }
        ]
    },
    {
        "id": "amz-coding-1",
        "title": "Amazon Locker System Design",
        "type": "Coding",
        "category": "Object Oriented Design",
        "difficulty": "Medium",
        "description": "Design an automated locker system for package delivery and pickup. Include class structures and key interactions.",
        "solutionSlug": "software-design-concepts",
        "language": "markdown",
        "initialCode": "# Locker System Design\n\n## Core Classes\n1. LockerLocation\n2. Locker\n3. Package\n\n## Key Methods\n- assignLocker(packageSize)\n- pickupPackage(code)",
        "testCases": []
    },
    {
        "id": "amz-dsa-2",
        "title": "Number of Islands",
        "type": "DSA",
        "category": "Graphs (BFS/DFS)",
        "difficulty": "Medium",
        "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.",
        "solutionSlug": "graph-intro",
        "language": "javascript",
        "initialCode": "/**\n * @param {character[][]} grid\n * @return {number}\n */\nvar numIslands = function(grid) {\n    \n};",
        "testCases": [
            {
                "input": "[[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
                "output": "1"
            },
            {
                "input": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
                "output": "3"
            }
        ]
    },
    {
        "id": "amz-core-1",
        "title": "Amazon DynamoDB Scaling",
        "type": "Core CS",
        "category": "Database Management",
        "difficulty": "Hard",
        "description": "Explain the concept of consistent hashing and how it enables horizontal scaling in DynamoDB.",
        "solutionSlug": "sql-intro",
        "language": "markdown",
        "initialCode": "## Consistent Hashing\n\nConsistent hashing is a distributed hashing scheme that operates independently of the number of servers...",
        "testCases": []
    },
    {
        "id": "amz-dsa-3",
        "title": "Word Ladder",
        "type": "DSA",
        "category": "Graphs",
        "difficulty": "Hard",
        "description": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words... Return the number of words in the shortest transformation sequence.",
        "solutionSlug": "graph-intro",
        "language": "javascript",
        "initialCode": "/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, wordList) {\n    \n};",
        "testCases": [
            {
                "input": "[\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]]",
                "output": "5"
            },
            {
                "input": "[\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]]",
                "output": "0"
            }
        ]
    },
    {
        "id": "amz-coding-2",
        "title": "Leadership Principal: Customer Obsession",
        "type": "Coding",
        "category": "Behavioral",
        "difficulty": "Medium",
        "description": "Describe a situation where you went above and beyond for a customer. How did it impact the final product?",
        "solutionSlug": "se-interview-prep",
        "language": "markdown",
        "initialCode": "**Situation:**\n\n**Task:**\n\n**Action:**\n\n**Result:**",
        "testCases": []
    },
    {
        "id": "amz-dsa-4",
        "title": "Optimal Utilization",
        "type": "DSA",
        "category": "Two Pointers",
        "difficulty": "Medium",
        "description": "Given two lists of pairs and a target capacity, return the pairs from each list whose sum is closest to but not exceeding the capacity.",
        "language": "javascript",
        "initialCode": "/**\n * @param {number[][]} a\n * @param {number[][]} b\n * @param {number} target\n * @return {number[][]}\n */\nvar optimalUtilization = function(a, b, target) {\n    \n};",
        "testCases": [
            {
                "input": "[[[1, 2], [2, 4], [3, 6]], [[1, 2]], 7]",
                "output": "[[2, 1]]"
            }
        ]
    },
    {
        "id": "amz-core-2",
        "title": "Microservices vs Monoliths at Amazon",
        "type": "Core CS",
        "category": "Architecture",
        "difficulty": "Medium",
        "description": "Discuss the pros and cons of migrating from a legacy monolith to a microservices architecture as seen in Amazon's infrastructure history.",
        "solutionSlug": "software-design-concepts",
        "language": "markdown",
        "initialCode": "## Monolithic Architecture\n\n## Microservices Architecture\n\n## Migration Challenges",
        "testCases": []
    }
]