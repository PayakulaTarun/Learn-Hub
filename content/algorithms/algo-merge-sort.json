{
  "title": "Merge Sort",
  "slug": "algo-merge-sort",
  "subject": "Algorithms",
  "category": "Core Computer Science",
  "level": "Intermediate",
  "estimated_read_time": "30 mins",
  "prerequisites": [
    "Divide and Conquer Strategy"
  ],
  "learning_objectives": [
    "Algorithm",
    "Merge Step",
    "O(n log n)"
  ],
  "theory": "The classic D&C Sort. \n1. Recursively split array until size 1.\n2. Merge two sorted arrays into one larger sorted array.\nConsistent O(n log n) performance.",
  "syntax": "merge(L, R)",
  "examples": [
    {
      "code": "[38, 27, 43, 3] -> [38, 27], [43, 3] -> [27, 38], [3, 43] -> [3, 27, 38, 43]",
      "output": "Sorted",
      "explanation": "Zipping two sorted lists."
    }
  ],
  "common_mistakes": [],
  "interview_questions": [
    {
      "question": "Space complexity of Merge Sort?",
      "answer": "O(n) auxiliary space for temp arrays. This is its main disadvantage vs Quick Sort.",
      "difficulty": "Medium"
    }
  ],
  "practice_problems": [],
  "real_world_use_cases": [
    {
      "scenario": "External Sort",
      "description": "Sorting huge files on disk that don't fit in RAM. Merge sort works well with streams.",
      "code": "Database"
    }
  ],
  "exam_notes": [
    "Stable sort.",
    "Predictable."
  ],
  "summary": "Reliable and stable, but memory hungry."
}