{
  "title": "Space Complexity Basics",
  "slug": "space-complexity",
  "subject": "Algorithms",
  "category": "Core Computer Science",
  "level": "Beginner",
  "estimated_read_time": "20 mins",
  "prerequisites": [
    "Time Complexity Basics"
  ],
  "learning_objectives": [
    "Memory Usage",
    "Auxiliary Space",
    "Input Space"
  ],
  "theory": "Space Complexity = Auxiliary Space + Input Space. We usually care about **Auxiliary Space** (extra memory used by the algorithm). \n- Variables: O(1).\n- Array of size n: O(n).",
  "syntax": "S(n)",
  "examples": [
    {
      "code": "def sum(arr):\n  total = 0  # O(1) space\n  for x in arr: total += x\n  return total",
      "output": "O(1) Auxiliary",
      "explanation": "Input takes O(n), but algo only needs one variable."
    }
  ],
  "common_mistakes": [],
  "interview_questions": [
    {
      "question": "What is the space complexity of recursive calls?",
      "answer": "O(depth) due to the Call Stack.",
      "difficulty": "Medium"
    }
  ],
  "practice_problems": [],
  "real_world_use_cases": [
    {
      "scenario": "Embedded Systems",
      "description": "Low RAM requires O(1) space algorithms.",
      "code": "IoT"
    }
  ],
  "exam_notes": [
    "Recursion uses Stack space.",
    "In-place means O(1) aux."
  ],
  "summary": "RAM is finite. Don't waste it."
}