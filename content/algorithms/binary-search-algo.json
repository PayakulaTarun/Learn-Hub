{
  "title": "Binary Search Algorithm",
  "slug": "binary-search-algo",
  "subject": "Algorithms",
  "category": "Core Computer Science",
  "level": "Beginner",
  "estimated_read_time": "25 mins",
  "prerequisites": [
    "Linear Search Algorithm"
  ],
  "learning_objectives": [
    "Divide and Conquer",
    "Sorted Requirement",
    "O(log n)"
  ],
  "theory": "If list is **Sorted**, we can do better. \n1. Check Middle.\n2. If Middle < Target, discard Left half.\n3. Else discard Right half.\nHalves the search space every step.",
  "syntax": "mid = l + (r-l)/2",
  "examples": [],
  "common_mistakes": [
    {
      "mistake": "Unsorted Input",
      "correction": "Binary search fails silently or loops forever on unsorted data. Ensure sort first.",
      "example": "Searching [3, 1, 2]"
    }
  ],
  "interview_questions": [
    {
      "question": "What is the max steps for 1 million items?",
      "answer": "log2(1,000,000) approx 20 steps.",
      "difficulty": "Easy"
    }
  ],
  "practice_problems": [],
  "real_world_use_cases": [
    {
      "scenario": "Phonebook",
      "description": "You don't start at 'A' to find 'Z'. You flip to the middle.",
      "code": "Dictionary"
    }
  ],
  "exam_notes": [
    "Most efficient comparison search.",
    "Requires sort."
  ],
  "summary": "Exponentially faster than linear search."
}