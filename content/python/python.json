{
  "slug": "python",
  "title": "Python Masterclass",
  "category": "python",
  "description": "Master Python internals, async programming, and advanced patterns",
  "sections": [
    {
      "id": "python-fundamentals",
      "title": "Python Fundamentals",
      "content": "**Everything is an Object**\n\nIn Python, everything—including functions, classes, and even modules—is an object. This enables powerful metaprogramming capabilities.\n\n**Dynamic Typing**\n\nPython uses duck typing: \"If it walks like a duck and quacks like a duck, it's a duck.\" Type checking happens at runtime, not compile time.\n\n**Indentation-based Syntax**\n\nPython uses indentation to define code blocks instead of braces, making code clean and readable.",
      "codeExample": "# Everything is an object\ndef greet(name):\n    return f\"Hello, {name}!\"\n\nprint(type(greet))  # <class 'function'>\nprint(greet.__name__)  # 'greet'\n\n# Dynamic typing\nx = 5\nprint(type(x))  # <class 'int'>\nx = \"Hello\"\nprint(type(x))  # <class 'str'>",
      "language": "python"
    },
    {
      "id": "memory-management",
      "title": "Memory Management & GIL",
      "content": "**Reference Counting**\n\nPython uses reference counting for memory management. Each object keeps track of how many references point to it. When the count reaches zero, the object is deallocated.\n\n**Garbage Collection**\n\nIn addition to reference counting, Python has a cyclic garbage collector to detect and clean up reference cycles.\n\n**Global Interpreter Lock (GIL)**\n\nThe GIL is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecode simultaneously. This means:\n- CPU-bound multi-threaded programs won't see performance gains\n- I/O-bound programs can still benefit from threading\n- Use multiprocessing for true parallelism",
      "codeExample": "import sys\n\n# Reference counting\nx = [1, 2, 3]\nprint(sys.getrefcount(x))  # 2 (one from x, one from getrefcount)\n\ny = x  # Create another reference\nprint(sys.getrefcount(x))  # 3\n\n# Avoiding GIL limitations\nfrom multiprocessing import Process\n\ndef cpu_intensive_task():\n    result = sum(i**2 for i in range(1000000))\n    print(result)\n\nif __name__ == '__main__':\n    processes = [Process(target=cpu_intensive_task) for _ in range(4)]\n    for p in processes:\n        p.start()\n    for p in processes:\n        p.join()",
      "language": "python"
    },
    {
      "id": "async-await",
      "title": "Async/Await & Coroutines",
      "content": "**Coroutines**\n\nCoroutines are functions that can pause execution and yield control back to the event loop, allowing other coroutines to run.\n\n**Event Loop**\n\nThe `asyncio` event loop manages the execution of coroutines, handling I/O operations efficiently without blocking.\n\n**When to Use Async**\n- I/O-bound operations (network requests, file I/O)\n- Database queries\n- API calls\n\n**When NOT to Use Async**\n- CPU-bound operations (use multiprocessing instead)\n- Simple scripts with minimal I/O",
      "codeExample": "import asyncio\nimport aiohttp\n\nasync def fetch_url(session, url):\n    async with session.get(url) as response:\n        return await response.text()\n\nasync def main():\n    urls = [\n        'https://api.github.com/users/python',\n        'https://api.github.com/users/django',\n        'https://api.github.com/users/flask',\n    ]\n    \n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch_url(session, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n        print(f\"Fetched {len(results)} URLs\")\n\n# Run the event loop\nasyncio.run(main())",
      "language": "python"
    },
    {
      "id": "decorators-metaclasses",
      "title": "Decorators & Metaclasses",
      "content": "**Decorators**\n\nDecorators are functions that modify the behavior of other functions or classes. They use the `@` syntax.\n\n**Common Use Cases**\n- Logging\n- Authentication\n- Caching\n- Timing\n\n**Metaclasses**\n\nMetaclasses are \"classes of classes\" that define how classes behave. They allow you to customize class creation.\n\n**Use Case**: ORMs like Django and SQLAlchemy use metaclasses to define model fields.",
      "codeExample": "# Decorator example\nimport functools\nimport time\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f\"{func.__name__} took {end - start:.4f} seconds\")\n        return result\n    return wrapper\n\n@timer\ndef slow_function():\n    time.sleep(1)\n    return \"Done\"\n\nslow_function()  # Prints execution time\n\n# Metaclass example\nclass Singleton(type):\n    _instances = {}\n    \n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass Database(metaclass=Singleton):\n    def __init__(self):\n        print(\"Initializing database...\")\n\ndb1 = Database()  # Prints \"Initializing database...\"\ndb2 = Database()  # No output\nprint(db1 is db2)  # True",
      "language": "python"
    }
  ],
  "order": 14
}