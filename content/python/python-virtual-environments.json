{
  "title": "Python Virtual Environments - Complete Guide",
  "slug": "python-virtual-environments",
  "subject": "Python",
  "category": "python",
  "level": "Intermediate",
  "estimated_read_time": "15 minutes",
  "prerequisites": [
    "Python installation",
    "Command line basics",
    "Understanding of pip and packages",
    "File system navigation"
  ],
  "learning_objectives": [
    "Understand what virtual environments are and why they're essential",
    "Create virtual environments using venv",
    "Activate and deactivate virtual environments on different OS",
    "Manage project dependencies independently",
    "Resolve dependency conflicts between projects",
    "Use requirements.txt for reproducible environments",
    "Apply virtual environments to real projects"
  ],
  "theory": "## What are Virtual Environments?\n\n**Virtual environment** is an isolated Python environment with its own packages, separate from the system Python.\n\n### Real-Life Analogy\n\nThink of **separate workspaces**:\n- **Global Python**: Main workshop with shared tools\n- **Virtual Environment**: Personal workspace with your own tools\n- **Different Projects**: Different workspaces with different tool versions\n\nJust like you wouldn't mix client A's files with client B's files, you don't mix Project A's packages with Project B's packages!\n\n### The Problem Without Virtual Environments\n\n**Scenario**: You have two projects:\n```\nProject A needs: Django 2.2\nProject B needs: Django 4.0\n\nGlobal Python: Can only have ONE Django version!\n```\n\n**What happens:**\n```bash\n# Install for Project A\npip install Django==2.2\n# Project A works! ✅\n\n# Install for Project B\npip install Django==4.0\n# Project A breaks! ❌ (Django 2.2 replaced)\n# Project B works! ✅\n```\n\n### The Solution: Virtual Environments\n\n```\nGlobal Python: (clean, minimal packages)\n\nProject A Environment:\n  └── Django 2.2 ✅\n  └── requests 2.25.0\n\nProject B Environment:\n  └── Django 4.0 ✅\n  └── requests 2.28.0\n\nBoth projects work! No conflicts!\n```\n\n---\n\n## Why Virtual Environments are Essential\n\n### 1. Dependency Isolation\n\n**Problem**: Different projects need different package versions.\n\n**Without venv:**\n```\nProject 1: needs requests 2.20.0\nProject 2: needs requests 2.28.0\n\nGlobal Python can only have ONE version!\nProjects conflict! ❌\n```\n\n**With venv:**\n```\nProject 1 venv: requests 2.20.0 ✅\nProject 2 venv: requests 2.28.0 ✅\n\nNo conflicts! Both work! ✅\n```\n\n### 2. Clean Global Python\n\n**Without venv**: Global Python becomes cluttered\n```bash\npip list\n# 100+ packages from all projects!\n# Hard to maintain\n# System instability\n```\n\n**With venv**: Global Python stays clean\n```bash\npip list  # In global\n# Only essential packages\n\npip list  # In project venv\n# Only this project's packages\n```\n\n### 3. Reproducibility\n\n**Team collaboration:**\n```bash\n# Developer A creates requirements.txt\npip freeze > requirements.txt\n\n# Developer B recreates exact environment\npip install -r requirements.txt\n\n# Same package versions = No \"works on my machine\" issues!\n```\n\n### 4. Testing Different Versions\n\nTest package compatibility:\n```\nvenv-python-3.9/  # Test with Python 3.9\nvenv-python-3.10/ # Test with Python 3.10\nvenv-python-3.11/ # Test with Python 3.11\n```\n\n### 5. Production Deployment\n\nDeploy exact dependencies:\n```bash\n# Development\npip freeze > requirements.txt\n\n# Production server\npip install -r requirements.txt\n# Exact same environment!\n```\n\n---\n\n## Creating Virtual Environments\n\n### Using venv (Built-in, Recommended)\n\n**Python 3.3+** includes venv module.\n\n**Syntax:**\n```bash\npython -m venv <environment_name>\n```\n\n**Examples:**\n```bash\n# Create venv named 'venv'\npython -m venv venv\n\n# Create venv named 'env'\npython -m venv env\n\n# Create venv named 'myproject_env'\npython -m venv myproject_env\n```\n\n**What it creates:**\n```\nvenv/\n    Scripts/        # Windows (executables)\n    bin/            # Mac/Linux (executables)\n    Lib/            # Windows (packages)\n    lib/            # Mac/Linux (packages)\n    Include/        # Header files\n    pyvenv.cfg      # Configuration\n```\n\n### Alternative: virtualenv\n\n**Install:**\n```bash\npip install virtualenv\n```\n\n**Create:**\n```bash\nvirtualenv venv\nvirtualenv -p python3.9 venv  # Specify Python version\n```\n\n**Note**: venv (built-in) is sufficient for most use cases.\n\n---\n\n## Activating Virtual Environments\n\nActivation changes your shell to use the virtual environment's Python.\n\n### Windows\n\n**Command Prompt:**\n```cmd\nvenv\\Scripts\\activate.bat\n```\n\n**PowerShell:**\n```powershell\nvenv\\Scripts\\Activate.ps1\n```\n\n**PowerShell Execution Policy Issue:**\n```powershell\n# If you get error, run once as admin:\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n\n# Then activate normally:\nvenv\\Scripts\\Activate.ps1\n```\n\n**Git Bash (Windows):**\n```bash\nsource venv/Scripts/activate\n```\n\n### Mac / Linux\n\n**Bash / Zsh:**\n```bash\nsource venv/bin/activate\n```\n\n**Fish:**\n```bash\nsource venv/bin/activate.fish\n```\n\n**Csh:**\n```bash\nsource venv/bin/activate.csh\n```\n\n### How to Know It's Active\n\n**Prompt changes:**\n```bash\n# Before activation\nC:\\Users\\Alice\\project>\n\n# After activation (venv name in parentheses)\n(venv) C:\\Users\\Alice\\project>\n```\n\n**Verify:**\n```bash\n# Check which Python\nwhere python    # Windows\nwhich python    # Mac/Linux\n\n# Should point to venv directory\n# Windows: C:\\project\\venv\\Scripts\\python.exe\n# Mac/Linux: /project/venv/bin/python\n```\n\n---\n\n## Deactivating Virtual Environments\n\n### All Operating Systems\n\n**Simple command:**\n```bash\ndeactivate\n```\n\n**What happens:**\n- Prompt returns to normal\n- Python returns to system Python\n- pip installs to system again (be careful!)\n\n**Example:**\n```bash\n(venv) $ deactivate\n$ # Back to system Python\n```\n\n---\n\n## Complete Workflow\n\n### Project Setup\n\n```bash\n# 1. Create project directory\nmkdir my_project\ncd my_project\n\n# 2. Create virtual environment\npython -m venv venv\n\n# 3. Activate\n# Windows:\nvenv\\Scripts\\activate\n# Mac/Linux:\nsource venv/bin/activate\n\n# 4. Install packages\n(venv) $ pip install requests pandas\n\n# 5. Save dependencies\n(venv) $ pip freeze > requirements.txt\n\n# 6. Work on project...\n(venv) $ python main.py\n\n# 7. Deactivate when done\n(venv) $ deactivate\n```\n\n### Cloning Project\n\n```bash\n# 1. Clone repository\ngit clone <repository_url>\ncd project\n\n# 2. Create virtual environment\npython -m venv venv\n\n# 3. Activate\nsource venv/bin/activate  # Mac/Linux\nvenv\\Scripts\\activate     # Windows\n\n# 4. Install dependencies\n(venv) $ pip install -r requirements.txt\n\n# 5. Run project\n(venv) $ python main.py\n```\n\n---\n\n## Managing Dependencies\n\n### requirements.txt\n\n**Create:**\n```bash\n(venv) $ pip freeze > requirements.txt\n```\n\n**Example requirements.txt:**\n```\nrequests==2.28.0\nnumpy==1.23.0\npandas==1.4.3\nmatplotlib==3.5.2\n```\n\n**Install from requirements.txt:**\n```bash\n(venv) $ pip install -r requirements.txt\n```\n\n### Version Specifiers\n\n```\npackage==1.0.0    # Exact version\npackage>=1.0.0    # Minimum version\npackage<=2.0.0    # Maximum version\npackage>=1.0,<2.0 # Range\npackage~=1.4.2    # Compatible release (>=1.4.2, <1.5.0)\npackage           # Any version (not recommended)\n```\n\n### Separate Requirements Files\n\n**requirements/base.txt:**\n```\nDjango>=3.2\nrequests>=2.25.0\n```\n\n**requirements/dev.txt:**\n```\n-r base.txt\npytest>=7.0\nblack>=22.0\n```\n\n**requirements/prod.txt:**\n```\n-r base.txt\ngunicorn>=20.0\n```\n\n**Install:**\n```bash\n# Development\npip install -r requirements/dev.txt\n\n# Production\npip install -r requirements/prod.txt\n```\n\n---\n\n## Dependency Conflicts\n\n### Example Conflict\n\n```\nPackage A requires: requests==2.20.0\nPackage B requires: requests>=2.25.0\n\nConflict! Cannot satisfy both!\n```\n\n### Resolving Conflicts\n\n**1. Update packages:**\n```bash\npip install --upgrade package-a\n# Hope new version has relaxed requirements\n```\n\n**2. Find compatible versions:**\n```bash\n# Try different versions\npip install package-a==1.0.0 package-b==2.0.0\n```\n\n**3. Use constraint files:**\n```bash\npip install -c constraints.txt package-a package-b\n```\n\n**4. Separate virtual environments:**\n```bash\n# Project A (uses package-a)\npython -m venv venv-a\nvenv-a/Scripts/activate\npip install package-a\n\n# Project B (uses package-b)\npython -m venv venv-b\nvenv-b/Scripts/activate\npip install package-b\n```\n\n### Checking for Conflicts\n\n```bash\n# Check dependency tree\npip install pipdeptree\npipdeptree\n\n# Check for conflicts\npip check\n```\n\n---\n\n## Best Practices\n\n### 1. One venv per project\n\n```\nproject-a/\n    venv/\n    src/\n    requirements.txt\n\nproject-b/\n    venv/\n    src/\n    requirements.txt\n```\n\n### 2. Never commit venv to version control\n\n**.gitignore:**\n```\nvenv/\nenv/\n.venv/\n*.pyc\n__pycache__/\n```\n\n### 3. Use descriptive venv names\n\n```bash\n# Generic (ok)\npython -m venv venv\n\n# Descriptive (better for multiple venvs)\npython -m venv django-project-env\npython -m venv data-analysis-venv\n```\n\n### 4. Document Python version\n\n**runtime.txt:**\n```\npython-3.11\n```\n\n### 5. Pin dependencies in production\n\n```\n# Development: flexible\nrequests>=2.25.0\n\n# Production: exact\nrequests==2.28.0\n```\n\n### 6. Regular updates\n\n```bash\n# Check outdated packages\npip list --outdated\n\n# Update package\npip install --upgrade package-name\n\n# Update all\npip freeze | %{$_.split('==')[0]} | %{pip install --upgrade $_}\n```\n\n---\n\n## Common Issues and Solutions\n\n### Issue 1: Activation doesn't work\n\n**Windows PowerShell:**\n```powershell\n# Error: running scripts is disabled\n# Solution: Change execution policy\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n```\n\n### Issue 2: Wrong Python version\n\n```bash\n# Specify Python version explicitly\npython3.11 -m venv venv\n\n# Or\n/usr/bin/python3.9 -m venv venv\n```\n\n### Issue 3: venv recreated accidentally\n\n**Prevention:**\n```bash\n# Don't delete venv folder\n# To reset, delete and recreate:\nrm -rf venv\npython -m venv venv\npip install -r requirements.txt\n```\n\n### Issue 4: Forgetting to activate\n\n**Indicator:**\n```bash\n# No (venv) in prompt\n$ pip install package  # Installs globally! ❌\n\n# Activate first\n$ source venv/bin/activate\n(venv) $ pip install package  # Safe ✅\n```\n\n### Issue 5: Large venv size\n\n**Solution:**\n```bash\n# Don't include data files in venv\n# Keep venv only for packages\n\n# Data files elsewhere:\nproject/\n    venv/           # Packages only\n    data/           # Data files\n    src/            # Source code\n```\n\n---\n\n## VS Code Integration\n\n### Select Python Interpreter\n\n```\n1. Ctrl+Shift+P (Cmd+Shift+P on Mac)\n2. Type: \"Python: Select Interpreter\"\n3. Choose: ./venv/Scripts/python.exe (or ./venv/bin/python)\n```\n\n### Auto-activation\n\n**settings.json:**\n```json\n{\n    \"python.terminal.activateEnvironment\": true,\n    \"python.defaultInterpreterPath\": \"${workspaceFolder}/venv/bin/python\"\n}\n```\n\n### Terminal Integration\n\nVS Code automatically activates venv when opening integrated terminal!\n\n---\n\n## Advanced: Multiple Python Versions\n\n### Using pyenv (Mac/Linux)\n\n```bash\n# Install pyenv\ncurl https://pyenv.run | bash\n\n# Install Python versions\npyenv install 3.9.0\npyenv install 3.10.0\npyenv install 3.11.0\n\n# Set project Python version\ncd my_project\npyenv local 3.11.0\n\n# Create venv with that version\npython -m venv venv\n```\n\n### Using py launcher (Windows)\n\n```bash\n# List installed Python versions\npy --list\n\n# Create venv with specific version\npy -3.9 -m venv venv39\npy -3.11 -m venv venv311\n```",
  "syntax": "# Create virtual environment\npython -m venv <venv_name>\npython -m venv venv\n\n# Activate virtual environment\n# Windows CMD:\nvenv\\Scripts\\activate.bat\n\n# Windows PowerShell:\nvenv\\Scripts\\Activate.ps1\n\n# Mac/Linux:\nsource venv/bin/activate\n\n# Deactivate (all OS):\ndeactivate\n\n# Install packages in venv:\n(venv) $ pip install package_name\n\n# Save dependencies:\n(venv) $ pip freeze > requirements.txt\n\n# Install from requirements:\n(venv) $ pip install -r requirements.txt\n\n# Check venv active:\nwhere python    # Windows\nwhich python    # Mac/Linux\n\n# Delete venv:\nrm -rf venv     # Mac/Linux\nrmdir /s venv   # Windows",
  "examples": [
    {
      "code": "# Example 1: Creating and Activating Virtual Environment\n\n# Step 1: Create project directory\n# mkdir my_project\n# cd my_project\n\n# Step 2: Create virtual environment\n# python -m venv venv\n\n# Step 3: Activate (Windows)\n# venv\\Scripts\\activate\n\n# Or activate (Mac/Linux)\n# source venv/bin/activate\n\n# Step 4: Verify activation\nimport sys\nprint(f\"Python executable: {sys.executable}\")\nprint(f\"Python version: {sys.version}\")\n\n# Should show venv path:\n# Windows: C:\\project\\venv\\Scripts\\python.exe\n# Mac/Linux: /project/venv/bin/python",
      "output": "Python executable: C:\\my_project\\venv\\Scripts\\python.exe\nPython version: 3.11.0 (main, Oct 24 2022, 18:26:48) [MSC v.1933 64 bit (AMD64)]",
      "explanation": "Virtual environment isolates Python and packages. After activation, sys.executable points to venv Python, not system Python. All pip installs go to venv, not global."
    },
    {
      "code": "# Example 2: Installing Packages in Virtual Environment\n\n# Activate venv first (venv should show in prompt)\n# (venv) $\n\n# Install packages\n# pip install requests\n# pip install pandas numpy\n\n# List installed packages (venv only)\nimport subprocess\nresult = subprocess.run(['pip', 'list'], capture_output=True, text=True)\nprint(\"Packages in virtual environment:\")\nprint(result.stdout)\n\n# Compare with global\nprint(\"\nPackages isolated to this project!\")",
      "output": "Packages in virtual environment:\nPackage    Version\n---------- -------\npip        23.0.1\nrequests   2.28.0\npandas     1.5.0\nnumpy      1.23.0\n\nPackages isolated to this project!",
      "explanation": "Packages installed in active venv are isolated to that project. Doesn't affect global Python or other projects. Each venv has independent package list."
    },
    {
      "code": "# Example 3: requirements.txt Workflow\n\n# After installing packages in venv\n# (venv) $ pip install requests pandas numpy\n\n# Save dependencies\nimport subprocess\n\n# Create requirements.txt\nwith open('requirements.txt', 'w') as f:\n    result = subprocess.run(['pip', 'freeze'], capture_output=True, text=True)\n    f.write(result.stdout)\n\nprint(\"requirements.txt created:\")\nwith open('requirements.txt', 'r') as f:\n    print(f.read())\n\n# Later: Recreate environment\n# python -m venv new_venv\n# new_venv\\Scripts\\activate\n# pip install -r requirements.txt",
      "output": "requirements.txt created:\nnumpy==1.23.0\npandas==1.5.0\npython-dateutil==2.8.2\npytz==2022.1\nrequests==2.28.0\nsix==1.16.0\nurllib3==1.26.12",
      "explanation": "pip freeze captures all installed packages with exact versions. requirements.txt allows others (or future you) to recreate exact environment. Essential for collaboration and deployment."
    },
    {
      "code": "# Example 4: Dependency Conflict Scenario\n\n# Scenario: Two projects need different package versions\nprint(\"Without virtual environments:\")\nprint(\"Project A needs: Django 2.2\")\nprint(\"Project B needs: Django 4.0\")\nprint(\"Global Python can only have ONE!\n\")\n\nprint(\"With virtual environments:\")\nprint(\"Project A venv: Django 2.2 ✓\")\nprint(\"Project B venv: Django 4.0 ✓\")\nprint(\"Both work independently!\n\")\n\n# Demonstration\nprojects = {\n    'Project A': {'name': 'Blog', 'django': '2.2'},\n    'Project B': {'name': 'E-commerce', 'django': '4.0'}\n}\n\nfor project, info in projects.items():\n    print(f\"{project} ({info['name']}):\")\n    print(f\"  Virtual env: {project.lower().replace(' ', '_')}_venv\")\n    print(f\"  Django version: {info['django']}\")\n    print(f\"  Status: Running ✓\n\")",
      "output": "Without virtual environments:\nProject A needs: Django 2.2\nProject B needs: Django 4.0\nGlobal Python can only have ONE!\n\nWith virtual environments:\nProject A venv: Django 2.2 ✓\nProject B venv: Django 4.0 ✓\nBoth work independently!\n\nProject A (Blog):\n  Virtual env: project_a_venv\n  Django version: 2.2\n  Status: Running ✓\n\nProject B (E-commerce):\n  Virtual env: project_b_venv\n  Django version: 4.0\n  Status: Running ✓",
      "explanation": "Virtual environments solve dependency conflicts. Each project has isolated packages. Different versions of same package can coexist. No conflicts between projects!"
    },
    {
      "code": "# Example 5: Checking Virtual Environment Status\n\nimport sys\nimport os\n\ndef check_venv_status():\n    \"\"\"Check if running in virtual environment\"\"\"\n    in_venv = sys.prefix != sys.base_prefix\n    \n    print(\"Virtual Environment Status:\")\n    print(f\"In virtual environment: {in_venv}\")\n    print(f\"\nPython executable: {sys.executable}\")\n    print(f\"Prefix: {sys.prefix}\")\n    print(f\"Base prefix: {sys.base_prefix}\")\n    \n    if in_venv:\n        venv_name = os.path.basename(sys.prefix)\n        print(f\"\nActive venv: {venv_name}\")\n        print(\"✓ Packages will install here\")\n    else:\n        print(\"\n⚠ Not in virtual environment\")\n        print(\"Packages will install globally!\")\n\ncheck_venv_status()",
      "output": "Virtual Environment Status:\nIn virtual environment: True\n\nPython executable: C:\\project\\venv\\Scripts\\python.exe\nPrefix: C:\\project\\venv\nBase prefix: C:\\Python311\n\nActive venv: venv\n✓ Packages will install here",
      "explanation": "sys.prefix != sys.base_prefix indicates virtual environment. sys.prefix points to venv, base_prefix to system Python. Useful for scripts to verify they're running in correct environment."
    },
    {
      "code": "# Example 6: OS-Specific Activation Commands\n\nimport platform\n\ndef get_activation_command():\n    \"\"\"Get OS-specific activation command\"\"\"\n    system = platform.system()\n    venv_name = \"venv\"\n    \n    commands = {\n        'Windows': {\n            'CMD': f'{venv_name}\\\\Scripts\\\\activate.bat',\n            'PowerShell': f'{venv_name}\\\\Scripts\\\\Activate.ps1',\n            'Git Bash': f'source {venv_name}/Scripts/activate'\n        },\n        'Darwin': {  # macOS\n            'Bash/Zsh': f'source {venv_name}/bin/activate',\n            'Fish': f'source {venv_name}/bin/activate.fish'\n        },\n        'Linux': {\n            'Bash/Zsh': f'source {venv_name}/bin/activate',\n            'Fish': f'source {venv_name}/bin/activate.fish'\n        }\n    }\n    \n    print(f\"Operating System: {system}\n\")\n    print(\"Activation commands:\")\n    \n    os_commands = commands.get(system, {})\n    for shell, cmd in os_commands.items():\n        print(f\"  {shell}: {cmd}\")\n\nget_activation_command()",
      "output": "Operating System: Windows\n\nActivation commands:\n  CMD: venv\\Scripts\\activate.bat\n  PowerShell: venv\\Scripts\\Activate.ps1\n  Git Bash: source venv/Scripts/activate",
      "explanation": "Activation command differs by OS and shell. Windows uses Scripts folder, Mac/Linux use bin. Script type varies: .bat for CMD, .ps1 for PowerShell, no extension for bash."
    },
    {
      "code": "# Example 7: Complete Project Workflow\n\ndef project_setup_workflow():\n    \"\"\"Complete workflow for project setup\"\"\"\n    steps = [\n        {\n            'step': 1,\n            'action': 'Create project directory',\n            'command': 'mkdir my_project && cd my_project'\n        },\n        {\n            'step': 2,\n            'action': 'Create virtual environment',\n            'command': 'python -m venv venv'\n        },\n        {\n            'step': 3,\n            'action': 'Activate venv',\n            'command': 'venv\\\\Scripts\\\\activate (Windows) or source venv/bin/activate (Mac/Linux)'\n        },\n        {\n            'step': 4,\n            'action': 'Upgrade pip',\n            'command': 'pip install --upgrade pip'\n        },\n        {\n            'step': 5,\n            'action': 'Install project packages',\n            'command': 'pip install requests pandas numpy'\n        },\n        {\n            'step': 6,\n            'action': 'Save dependencies',\n            'command': 'pip freeze > requirements.txt'\n        },\n        {\n            'step': 7,\n            'action': 'Create .gitignore',\n            'command': 'echo venv/ >> .gitignore'\n        },\n        {\n            'step': 8,\n            'action': 'Work on project',\n            'command': 'python main.py'\n        },\n        {\n            'step': 9,\n            'action': 'Deactivate when done',\n            'command': 'deactivate'\n        }\n    ]\n    \n    print(\"Complete Virtual Environment Workflow:\n\")\n    for item in steps:\n        print(f\"Step {item['step']}: {item['action']}\")\n        print(f\"  $ {item['command']}\n\")\n\nproject_setup_workflow()",
      "output": "Complete Virtual Environment Workflow:\n\nStep 1: Create project directory\n  $ mkdir my_project && cd my_project\n\nStep 2: Create virtual environment\n  $ python -m venv venv\n\nStep 3: Activate venv\n  $ venv\\Scripts\\activate (Windows) or source venv/bin/activate (Mac/Linux)\n\nStep 4: Upgrade pip\n  $ pip install --upgrade pip\n\nStep 5: Install project packages\n  $ pip install requests pandas numpy\n\nStep 6: Save dependencies\n  $ pip freeze > requirements.txt\n\nStep 7: Create .gitignore\n  $ echo venv/ >> .gitignore\n\nStep 8: Work on project\n  $ python main.py\n\nStep 9: Deactivate when done\n  $ deactivate",
      "explanation": "Standard workflow for professional Python projects. Create venv, activate, install packages, save requirements, work, deactivate. Following this ensures isolated, reproducible environments."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Installing packages without activating venv",
      "correction": "Always activate venv before pip install",
      "example": "❌ pip install requests  # No (venv) in prompt - installs globally!\n\n✅ source venv/bin/activate\n(venv) $ pip install requests  # Installs in venv"
    },
    {
      "mistake": "Committing venv folder to Git",
      "correction": "Add venv/ to .gitignore, commit requirements.txt instead",
      "example": "❌ git add venv/  # Huge, unnecessary files\n\n✅ # .gitignore\nvenv/\nenv/\n*.pyc\n\n✅ git add requirements.txt  # Small, portable"
    },
    {
      "mistake": "Using same venv for multiple projects",
      "correction": "One venv per project for isolation",
      "example": "❌ shared_venv/  # Used by Project A and B\n                   # Conflicts inevitable!\n\n✅ project_a/venv/  # Project A packages\n✅ project_b/venv/  # Project B packages"
    },
    {
      "mistake": "Forgetting to create requirements.txt",
      "correction": "Always pip freeze > requirements.txt after installing packages",
      "example": "❌ pip install requests pandas\n   # No record of dependencies!\n\n✅ pip install requests pandas\n   pip freeze > requirements.txt\n   git add requirements.txt"
    },
    {
      "mistake": "Not specifying Python version in venv creation",
      "correction": "Specify Python version explicitly when needed",
      "example": "❌ python -m venv venv  # Uses default python\n\n✅ python3.11 -m venv venv  # Explicit version\n✅ py -3.9 -m venv venv     # Windows py launcher"
    }
  ],
  "interview_questions": [
    {
      "question": "What is a virtual environment and why is it important?",
      "difficulty": "Easy",
      "answer": "Virtual environment is isolated Python environment with its own packages, separate from system Python. Important for: dependency isolation (different projects can have different package versions), keeping global Python clean, reproducibility (requirements.txt), and avoiding conflicts."
    },
    {
      "question": "How do you create a virtual environment?",
      "difficulty": "Easy",
      "answer": "Use python -m venv <name>. Example: python -m venv venv. Creates directory with isolated Python installation and packages. Activate with: venv\\Scripts\\activate (Windows) or source venv/bin/activate (Mac/Linux)."
    },
    {
      "question": "What's the difference between venv and virtualenv?",
      "difficulty": "Medium",
      "answer": "venv: built into Python 3.3+, standard library, sufficient for most cases. virtualenv: third-party package, more features, supports older Python. For modern Python, use venv (no installation needed)."
    },
    {
      "question": "How do you know if a virtual environment is activated?",
      "difficulty": "Easy",
      "answer": "1) Prompt shows (venv) prefix. 2) 'which python' or 'where python' points to venv directory. 3) In Python: sys.prefix != sys.base_prefix returns True. 4) pip list shows only venv packages."
    },
    {
      "question": "Explain dependency conflicts and how venv solves them.",
      "difficulty": "Medium",
      "answer": "Conflict: Project A needs Django 2.2, Project B needs Django 4.0. Global Python can only have one version. Solution: Separate venvs - each project has isolated packages. Project A venv has Django 2.2, Project B venv has Django 4.0. No conflict!"
    },
    {
      "question": "What is requirements.txt and how is it used?",
      "difficulty": "Easy",
      "answer": "requirements.txt lists project dependencies with versions. Create: pip freeze > requirements.txt. Install: pip install -r requirements.txt. Ensures reproducible environments - everyone gets same package versions."
    },
    {
      "question": "Should you commit venv folder to version control? Why or why not?",
      "difficulty": "Medium",
      "answer": "No! Reasons: 1) Large size (100s of MB), 2) OS-specific (Windows venv won't work on Mac), 3) Unnecessary (recreate with requirements.txt). Instead: add venv/ to .gitignore, commit requirements.txt."
    },
    {
      "question": "How do you deactivate a virtual environment?",
      "difficulty": "Easy",
      "answer": "Simply run: deactivate (works on all OS). Returns to system Python. Prompt loses (venv) prefix. Always deactivate before deleting venv folder or switching projects."
    },
    {
      "question": "Can you have multiple virtual environments for one project?",
      "difficulty": "Hard",
      "answer": "Yes, useful for testing. Example: venv-py39 (Python 3.9), venv-py311 (Python 3.11) to test compatibility. Or: venv-dev (development packages), venv-prod (production only). But typically one venv per project is standard."
    },
    {
      "question": "What happens if you delete a virtual environment folder?",
      "difficulty": "Medium",
      "answer": "All packages installed in that venv are lost. Python interpreter in venv is gone. Easy to recreate: python -m venv venv, then pip install -r requirements.txt (if you have it). This is why requirements.txt is essential!"
    }
  ],
  "practice_problems": [
    {
      "difficulty": "Beginner",
      "problem": "Create a virtual environment named 'myenv', activate it, and install the 'requests' package.",
      "hint": "Use python -m venv, activate, then pip install",
      "solution": "# Create venv\npython -m venv myenv\n\n# Activate (Windows)\nmyenv\\Scripts\\activate\n\n# Or activate (Mac/Linux)\nsource myenv/bin/activate\n\n# Install package\n(myenv) $ pip install requests\n\n# Verify\n(myenv) $ pip list"
    },
    {
      "difficulty": "Beginner",
      "problem": "Create requirements.txt with packages you installed in your venv.",
      "hint": "Use pip freeze command",
      "solution": "# Activate venv first\nsource venv/bin/activate\n\n# Install some packages\npip install requests pandas numpy\n\n# Create requirements.txt\npip freeze > requirements.txt\n\n# View contents\ncat requirements.txt"
    },
    {
      "difficulty": "Intermediate",
      "problem": "Clone a project, create venv, and install dependencies from requirements.txt.",
      "hint": "Create venv, activate, pip install -r",
      "solution": "# Clone project (simulation)\nmkdir project\ncd project\n\n# Create requirements.txt (simulation)\necho 'requests==2.28.0\npandas==1.5.0' > requirements.txt\n\n# Create venv\npython -m venv venv\n\n# Activate\nsource venv/bin/activate  # or venv\\Scripts\\activate on Windows\n\n# Install dependencies\npip install -r requirements.txt\n\n# Verify\npip list"
    },
    {
      "difficulty": "Intermediate",
      "problem": "Create Python script that checks if it's running in a virtual environment.",
      "hint": "Use sys.prefix and sys.base_prefix",
      "solution": "import sys\n\ndef is_venv():\n    return sys.prefix != sys.base_prefix\n\ndef check_environment():\n    if is_venv():\n        print(\"✓ Running in virtual environment\")\n        print(f\"Venv location: {sys.prefix}\")\n    else:\n        print(\"⚠ Running in global Python\")\n        print(\"Consider using a virtual environment!\")\n\nif __name__ == \"__main__\":\n    check_environment()"
    },
    {
      "difficulty": "Advanced",
      "problem": "Write script to set up new project with venv, install packages, create requirements.txt and .gitignore.",
      "hint": "Use subprocess module to run commands",
      "solution": "import subprocess\nimport os\n\ndef setup_project(project_name, packages):\n    # Create directory\n    os.makedirs(project_name, exist_ok=True)\n    os.chdir(project_name)\n    \n    # Create venv\n    subprocess.run(['python', '-m', 'venv', 'venv'])\n    \n    # Determine pip path\n    if os.name == 'nt':  # Windows\n        pip = 'venv\\\\Scripts\\\\pip'\n    else:  # Mac/Linux\n        pip = 'venv/bin/pip'\n    \n    # Install packages\n    for package in packages:\n        subprocess.run([pip, 'install', package])\n    \n    # Create requirements.txt\n    result = subprocess.run([pip, 'freeze'], capture_output=True, text=True)\n    with open('requirements.txt', 'w') as f:\n        f.write(result.stdout)\n    \n    # Create .gitignore\n    with open('.gitignore', 'w') as f:\n        f.write('venv/\n*.pyc\n__pycache__/\n')\n    \n    print(f\"Project '{project_name}' set up successfully!\")\n\n# Usage\nsetup_project('my_project', ['requests', 'pandas'])"
    }
  ],
  "real_world_use_cases": [
    {
      "scenario": "Team Development Workflow",
      "description": "Consistent environment across team members",
      "code": "# Developer A sets up project\n'''\n# 1. Create project\nmkdir team_project\ncd team_project\n\n# 2. Create venv\npython -m venv venv\nsource venv/bin/activate\n\n# 3. Install dependencies\npip install Django requests pandas\n\n# 4. Save requirements\npip freeze > requirements.txt\n\n# 5. Create .gitignore\necho \"venv/\n*.pyc\n__pycache__/\" > .gitignore\n\n# 6. Commit to Git\ngit init\ngit add .\ngit commit -m \"Initial setup\"\ngit push origin main\n'''\n\n# Developer B joins project\n'''\n# 1. Clone repository\ngit clone <repo_url>\ncd team_project\n\n# 2. Create virtual environment\npython -m venv venv\n\n# 3. Activate venv\nsource venv/bin/activate  # Mac/Linux\n# or: venv\\Scripts\\activate  # Windows\n\n# 4. Install exact dependencies\npip install -r requirements.txt\n\n# 5. Start working\npython manage.py runserver\n'''\n\nprint(\"Both developers have identical environments!\")\nprint(\"No 'works on my machine' issues!\")"
    },
    {
      "scenario": "Multiple Project Management",
      "description": "Managing different projects with different dependencies",
      "code": "import os\n\nprojects = {\n    'django_blog': {\n        'path': 'projects/django_blog',\n        'venv': 'venv',\n        'packages': ['Django==3.2', 'Pillow', 'psycopg2']\n    },\n    'flask_api': {\n        'path': 'projects/flask_api',\n        'venv': 'venv',\n        'packages': ['Flask==2.0', 'SQLAlchemy', 'marshmallow']\n    },\n    'data_analysis': {\n        'path': 'projects/data_analysis',\n        'venv': 'venv',\n        'packages': ['pandas', 'numpy', 'matplotlib', 'jupyter']\n    }\n}\n\ndef show_project_structure():\n    print(\"Project Structure with Isolated Environments:\n\")\n    \n    for project, info in projects.items():\n        print(f\"{project}/\")\n        print(f\"  ├── {info['venv']}/  (virtual environment)\")\n        print(f\"  ├── src/\")\n        print(f\"  ├── requirements.txt\")\n        print(\"  └── Packages:\")\n        for pkg in info['packages']:\n            print(f\"      - {pkg}\")\n        print()\n\nshow_project_structure()\n\nprint(\"Benefits:\")\nprint(\"✓ Each project has independent packages\")\nprint(\"✓ No version conflicts between projects\")\nprint(\"✓ Easy to switch between projects\")\nprint(\"✓ Clean global Python installation\")"
    },
    {
      "scenario": "CI/CD Pipeline Integration",
      "description": "Automated testing and deployment with venv",
      "code": "# .github/workflows/ci.yml (GitHub Actions)\n'''\nname: CI Pipeline\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v2\n    \n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: 3.11\n    \n    - name: Create virtual environment\n      run: |\n        python -m venv venv\n        source venv/bin/activate\n    \n    - name: Install dependencies\n      run: |\n        source venv/bin/activate\n        pip install --upgrade pip\n        pip install -r requirements.txt\n    \n    - name: Run tests\n      run: |\n        source venv/bin/activate\n        pytest tests/\n    \n    - name: Check code style\n      run: |\n        source venv/bin/activate\n        flake8 src/\n'''\n\n# Benefits demonstration\nci_benefits = [\n    \"Reproducible environment for every test run\",\n    \"Guaranteed dependency versions\",\n    \"Isolated from system packages\",\n    \"Fast setup from requirements.txt\",\n    \"Consistent across all CI runs\"\n]\n\nprint(\"CI/CD with Virtual Environments:\n\")\nfor i, benefit in enumerate(ci_benefits, 1):\n    print(f\"{i}. {benefit}\")\n\nprint(\"\n✓ Every build starts with clean, identical environment\")"
    },
    {
      "scenario": "Development vs Production Environments",
      "description": "Separate requirements for different environments",
      "code": "# Project structure\n'''\nproject/\n    requirements/\n        base.txt       # Shared dependencies\n        dev.txt        # Development only\n        prod.txt       # Production only\n        test.txt       # Testing only\n    venv-dev/          # Development venv\n    venv-prod/         # Production venv (for testing)\n'''\n\n# requirements/base.txt\nbase_requirements = '''\nDjango>=4.0\nrequests>=2.28.0\npython-dateutil>=2.8.0\n'''\n\n# requirements/dev.txt\ndev_requirements = '''\n-r base.txt\n\n# Development tools\npytest>=7.0\nblack>=22.0\nflake8>=5.0\nipython>=8.0\ndjango-debug-toolbar>=3.0\n'''\n\n# requirements/prod.txt\nprod_requirements = '''\n-r base.txt\n\n# Production only\ngunicorn>=20.0\npsycopg2-binary>=2.9\nwhitenoise>=6.0\n'''\n\nprint(\"Environment Setup:\n\")\n\nprint(\"Development:\")\nprint(\"  $ python -m venv venv-dev\")\nprint(\"  $ source venv-dev/bin/activate\")\nprint(\"  $ pip install -r requirements/dev.txt\")\nprint(\"  Includes: Django, pytest, black, ipython, debug-toolbar\n\")\n\nprint(\"Production:\")\nprint(\"  $ python -m venv venv-prod\")\nprint(\"  $ source venv-prod/bin/activate\")\nprint(\"  $ pip install -r requirements/prod.txt\")\nprint(\"  Includes: Django, gunicorn, psycopg2, whitenoise\n\")\n\nprint(\"Benefits:\")\nprint(\"✓ Development has debugging tools\")\nprint(\"✓ Production is lightweight (no dev tools)\")\nprint(\"✓ Shared base dependencies in base.txt\")\nprint(\"✓ Clear separation of concerns\")"
    }
  ],
  "exam_notes": [
    "Virtual environment: isolated Python environment with own packages",
    "Create venv: python -m venv <name>",
    "Activate Windows: venv\\Scripts\\activate or venv\\Scripts\\Activate.ps1",
    "Activate Mac/Linux: source venv/bin/activate",
    "Deactivate (all OS): deactivate",
    "Check if active: (venv) shows in prompt, or sys.prefix != sys.base_prefix",
    "Install in venv: activate first, then pip install package",
    "Save dependencies: pip freeze > requirements.txt",
    "Install from requirements: pip install -r requirements.txt",
    "One venv per project (isolation)",
    "Never commit venv/ to Git (add to .gitignore)",
    "Dependency conflict: different projects need different package versions",
    "venv solves conflicts: each project has isolated packages",
    "Built-in venv (Python 3.3+) vs third-party virtualenv",
    "requirements.txt ensures reproducible environments",
    "Venv location: project/venv/ (convention)",
    "Delete venv: delete folder, recreate with requirements.txt",
    "PowerShell issue: Set-ExecutionPolicy RemoteSigned if activation fails",
    "Check Python path: which python (Mac/Linux), where python (Windows)",
    "Virtual environment is project-specific, not system-wide"
  ],
  "summary": "Virtual environments are essential for professional Python development - they isolate project dependencies and prevent conflicts.\n\n**What is Virtual Environment:**\n- Isolated Python installation with own packages\n- Separate from system Python\n- One venv per project\n- Prevents dependency conflicts\n\n**Why Essential:**\n```\nWithout venv:\n  Project A: Django 2.2\n  Project B: Django 4.0\n  Global Python: Only ONE version! ❌\n  \nWith venv:\n  Project A venv: Django 2.2 ✅\n  Project B venv: Django 4.0 ✅\n  Both work! No conflicts! ✅\n```\n\n**Create Virtual Environment:**\n```bash\npython -m venv venv\n```\n\n**Activate:**\n```bash\n# Windows CMD\nvenv\\Scripts\\activate.bat\n\n# Windows PowerShell\nvenv\\Scripts\\Activate.ps1\n\n# Mac/Linux\nsource venv/bin/activate\n\n# Activated: (venv) shows in prompt\n```\n\n**Deactivate:**\n```bash\ndeactivate\n```\n\n**Complete Workflow:**\n```bash\n# 1. Create project\nmkdir my_project && cd my_project\n\n# 2. Create venv\npython -m venv venv\n\n# 3. Activate\nsource venv/bin/activate  # or Windows equivalent\n\n# 4. Install packages\n(venv) $ pip install requests pandas\n\n# 5. Save dependencies\n(venv) $ pip freeze > requirements.txt\n\n# 6. Work on project\n(venv) $ python main.py\n\n# 7. Deactivate\n(venv) $ deactivate\n```\n\n**requirements.txt:**\n```bash\n# Create\npip freeze > requirements.txt\n\n# Install\npip install -r requirements.txt\n\n# Ensures same packages across team/deployments\n```\n\n**Check if Active:**\n1. Prompt shows `(venv)`\n2. `which python` → points to venv\n3. Python: `sys.prefix != sys.base_prefix`\n\n**Best Practices:**\n- ✅ One venv per project\n- ✅ Add venv/ to .gitignore\n- ✅ Commit requirements.txt\n- ✅ Activate before pip install\n- ✅ Use descriptive venv names\n- ❌ Never commit venv folder\n- ❌ Never install in global Python\n\n**.gitignore:**\n```\nvenv/\nenv/\n*.pyc\n__pycache__/\n```\n\n**OS-Specific Commands:**\n\n| OS | Create | Activate |\n|----|--------|----------|\n| Windows CMD | `python -m venv venv` | `venv\\Scripts\\activate.bat` |\n| Windows PS | `python -m venv venv` | `venv\\Scripts\\Activate.ps1` |\n| Mac/Linux | `python -m venv venv` | `source venv/bin/activate` |\n\n**Common Issues:**\n\n**PowerShell:**\n```powershell\n# Error: running scripts disabled\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n```\n\n**Forgot to activate:**\n```bash\n# ❌ No (venv) in prompt\n$ pip install package  # Installs globally!\n\n# ✅ Activate first\n$ source venv/bin/activate\n(venv) $ pip install package  # Safe\n```\n\n**Benefits:**\n1. **Isolation**: Each project independent\n2. **No conflicts**: Different package versions\n3. **Clean global**: System Python uncluttered\n4. **Reproducible**: requirements.txt recreates environment\n5. **Testing**: Test different Python/package versions\n6. **Deployment**: Exact dependencies in production\n\n**Remember:**\n- Always use virtual environments\n- Never commit venv/ folder\n- Always create requirements.txt\n- One venv = one project\n- Activate before installing\n\nMaster virtual environments for professional Python development!",
  "order": 2
}