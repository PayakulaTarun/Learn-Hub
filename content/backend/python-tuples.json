{
    "title": "Python Tuples - Complete Guide",
    "slug": "python-tuples",
    "subject": "Python",
    "category": "backend",
    "level": "Beginner",
    "estimated_read_time": "13 minutes",
    "prerequisites": [
        "Python variables and data types",
        "Python lists",
        "Understanding of mutability vs immutability",
        "Basic Python syntax"
    ],
    "learning_objectives": [
        "Understand what tuples are and when to use them",
        "Create tuples using different methods",
        "Understand immutability and its implications",
        "Master tuple packing and unpacking",
        "Compare tuples with lists effectively",
        "Use tuples for multiple return values",
        "Understand when to choose tuples over lists"
    ],
    "theory": "## What is a Tuple?\n\nA **tuple** is an ordered, immutable collection that can store multiple items.\n\n### Real-Life Analogy\n\nThink of **GPS coordinates** (latitude, longitude):\n- Once a location is defined, coordinates don't change\n- Fixed at (40.7128, -74.0060) for New York City\n- You can READ the values, but can't MODIFY them\n- Order matters (latitude first, longitude second)\n\nTuples are like that - fixed, ordered collections.\n\n### Tuple vs List\n\n**The Key Difference: IMMUTABILITY**\n\n| Feature | List | Tuple |\n|---------|------|-------|\n| **Mutability** | Mutable (can change) | **Immutable (cannot change)** |\n| **Syntax** | `[1, 2, 3]` | `(1, 2, 3)` |\n| **Speed** | Slower | **Faster** |\n| **Memory** | More | **Less** |\n| **Methods** | Many (append, remove, etc.) | Few (count, index) |\n| **Use Case** | Data that changes | **Data that shouldn't change** |\n\n**Visual Comparison:**\n```python\n# List (mutable)\nmy_list = [1, 2, 3]\nmy_list[0] = 10  # ✅ Works\nmy_list.append(4)  # ✅ Works\n\n# Tuple (immutable)\nmy_tuple = (1, 2, 3)\nmy_tuple[0] = 10  # ❌ TypeError!\nmy_tuple.append(4)  # ❌ AttributeError!\n```\n\n### Why Use Tuples?\n\n1. **Data Integrity**: Values can't be accidentally modified\n2. **Performance**: Faster than lists\n3. **Memory**: Use less memory\n4. **Dictionary Keys**: Tuples can be dict keys, lists cannot\n5. **Multiple Returns**: Functions can return multiple values as tuple\n6. **Intention**: Signals \"this data is constant\"\n\n---\n\n## Creating Tuples\n\n### Method 1: Parentheses ()\n\n```python\n# Empty tuple\nempty = ()\n\n# Tuple with values\ncoordinates = (40.7128, -74.0060)\nfruits = (\"apple\", \"banana\", \"cherry\")\n\n# Mixed types\nmixed = (1, \"hello\", 3.14, True)\n\n# Nested tuples\nmatrix = ((1, 2), (3, 4), (5, 6))\n```\n\n### Method 2: Without Parentheses (Tuple Packing)\n\n```python\n# Parentheses are optional!\ncoordinates = 40.7128, -74.0060  # Still a tuple\nrgb = 255, 0, 128\n\nprint(type(coordinates))  # <class 'tuple'>\n```\n\n### Method 3: tuple() Constructor\n\n```python\n# From list\nmy_list = [1, 2, 3]\nmy_tuple = tuple(my_list)  # (1, 2, 3)\n\n# From string\nletters = tuple(\"Python\")  # ('P', 'y', 't', 'h', 'o', 'n')\n\n# From range\nnumbers = tuple(range(5))  # (0, 1, 2, 3, 4)\n```\n\n### Single Element Tuple (Tricky!)\n\n**IMPORTANT**: Need trailing comma for single element!\n\n```python\n# ❌ NOT a tuple (just an integer)\nsingle = (5)  \nprint(type(single))  # <class 'int'>\n\n# ✅ Correct: single element tuple\nsingle = (5,)  # Note the comma!\nprint(type(single))  # <class 'tuple'>\n\n# Also works without parentheses\nsingle = 5,\nprint(type(single))  # <class 'tuple'>\n```\n\n**Why?** Parentheses are used for many things in Python (math, grouping, etc.). The comma makes it a tuple.\n\n---\n\n## Accessing Tuple Elements\n\n### Indexing (Same as Lists)\n\n```python\nfruits = (\"apple\", \"banana\", \"cherry\", \"date\")\n\nprint(fruits[0])   # apple\nprint(fruits[2])   # cherry\nprint(fruits[-1])  # date (last)\nprint(fruits[-2])  # cherry (second from end)\n```\n\n### Slicing (Same as Lists)\n\n```python\nnumbers = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n\nprint(numbers[2:5])    # (2, 3, 4)\nprint(numbers[:5])     # (0, 1, 2, 3, 4)\nprint(numbers[5:])     # (5, 6, 7, 8, 9)\nprint(numbers[::2])    # (0, 2, 4, 6, 8)\nprint(numbers[::-1])   # (9, 8, 7, 6, 5, 4, 3, 2, 1, 0)\n```\n\n### Nested Tuple Access\n\n```python\nmatrix = ((1, 2, 3), (4, 5, 6), (7, 8, 9))\n\nprint(matrix[0])     # (1, 2, 3)\nprint(matrix[1][2])  # 6\nprint(matrix[2][0])  # 7\n```\n\n---\n\n## Immutability in Detail\n\n### What You CANNOT Do\n\n```python\nmy_tuple = (1, 2, 3)\n\n# ❌ Cannot modify element\nmy_tuple[0] = 10  # TypeError: 'tuple' does not support item assignment\n\n# ❌ Cannot add elements\nmy_tuple.append(4)  # AttributeError: no 'append' method\n\n# ❌ Cannot remove elements\nmy_tuple.remove(2)  # AttributeError: no 'remove' method\n\n# ❌ Cannot sort in place\nmy_tuple.sort()  # AttributeError: no 'sort' method\n```\n\n### What You CAN Do\n\n```python\nmy_tuple = (1, 2, 3)\n\n# ✅ Access elements\nprint(my_tuple[0])  # 1\n\n# ✅ Slice (creates new tuple)\nsliced = my_tuple[1:3]  # (2, 3)\n\n# ✅ Concatenate (creates new tuple)\nnew_tuple = my_tuple + (4, 5)  # (1, 2, 3, 4, 5)\n\n# ✅ Repeat (creates new tuple)\nrepeated = my_tuple * 2  # (1, 2, 3, 1, 2, 3)\n\n# ✅ Count occurrences\ncount = my_tuple.count(2)  # 1\n\n# ✅ Find index\nindex = my_tuple.index(2)  # 1\n\n# ✅ Iterate\nfor item in my_tuple:\n    print(item)\n```\n\n### Immutability Doesn't Mean Unchangeable Variables\n\n```python\nmy_tuple = (1, 2, 3)\nprint(my_tuple)  # (1, 2, 3)\n\n# Can reassign variable to NEW tuple\nmy_tuple = (4, 5, 6)  # Creates new tuple\nprint(my_tuple)  # (4, 5, 6)\n\n# Original tuple still can't be modified\n# But variable can point to different tuple\n```\n\n### Mutable Objects Inside Tuples\n\n**Important**: Tuple itself is immutable, but can contain mutable objects!\n\n```python\nmy_tuple = (1, 2, [3, 4])\n\n# ❌ Cannot modify tuple\nmy_tuple[0] = 10  # TypeError!\n\n# ✅ BUT can modify mutable object inside!\nmy_tuple[2].append(5)  # Works!\nprint(my_tuple)  # (1, 2, [3, 4, 5])\n\n# Tuple structure unchanged, but list inside changed\n```\n\n---\n\n## Tuple Packing and Unpacking\n\n### Tuple Packing\n\n**Packing**: Assigning multiple values to single variable creates tuple.\n\n```python\n# Parentheses optional\ncoordinates = 40.7128, -74.0060\nprint(coordinates)  # (40.7128, -74.0060)\nprint(type(coordinates))  # <class 'tuple'>\n\nperson = \"Alice\", 25, \"NYC\"\nprint(person)  # ('Alice', 25, 'NYC')\n```\n\n### Tuple Unpacking\n\n**Unpacking**: Assigning tuple values to multiple variables.\n\n```python\n# Basic unpacking\ncoordinates = (40.7128, -74.0060)\nlatitude, longitude = coordinates\n\nprint(latitude)   # 40.7128\nprint(longitude)  # -74.0060\n\n# Direct unpacking\nname, age, city = \"Alice\", 25, \"NYC\"\nprint(name)  # Alice\nprint(age)   # 25\nprint(city)  # NYC\n```\n\n### Unpacking Rules\n\n**Number must match!**\n\n```python\nmy_tuple = (1, 2, 3)\n\n# ❌ Too few variables\na, b = my_tuple  # ValueError: too many values to unpack\n\n# ❌ Too many variables\na, b, c, d = my_tuple  # ValueError: not enough values to unpack\n\n# ✅ Exact match\na, b, c = my_tuple  # Works!\n```\n\n### Extended Unpacking (Python 3+)\n\nUse `*` to capture multiple values.\n\n```python\n# * captures remaining values as list\nfirst, *middle, last = (1, 2, 3, 4, 5)\nprint(first)   # 1\nprint(middle)  # [2, 3, 4] (list!)\nprint(last)    # 5\n\n# All to one variable\nfirst, *rest = (1, 2, 3, 4, 5)\nprint(first)  # 1\nprint(rest)   # [2, 3, 4, 5]\n\n# Ignore values with _\nname, _, age = (\"Alice\", \"unused\", 25)\nprint(name)  # Alice\nprint(age)   # 25\n```\n\n### Swapping Variables\n\nElegant Python idiom using tuple packing/unpacking:\n\n```python\na = 5\nb = 10\n\n# Traditional swap (other languages)\ntemp = a\na = b\nb = temp\n\n# Python way (tuple unpacking)\na, b = b, a\nprint(a)  # 10\nprint(b)  # 5\n```\n\n### Function Returns\n\nFunctions use tuples to return multiple values:\n\n```python\ndef get_min_max(numbers):\n    return min(numbers), max(numbers)  # Returns tuple\n\nnums = [45, 12, 78, 23, 91]\nminimum, maximum = get_min_max(nums)  # Unpacking\n\nprint(f\"Min: {minimum}, Max: {maximum}\")  # Min: 12, Max: 91\n```\n\n---\n\n## Tuple Methods and Operations\n\n### Only 2 Methods!\n\nTuples have only **2 methods** (because they're immutable).\n\n**1. count(x)**: Count occurrences\n```python\nmy_tuple = (1, 2, 3, 2, 4, 2, 5)\ncount = my_tuple.count(2)\nprint(count)  # 3\n```\n\n**2. index(x)**: Find first index\n```python\nmy_tuple = (10, 20, 30, 40, 50)\nindex = my_tuple.index(30)\nprint(index)  # 2\n\n# ValueError if not found\nindex = my_tuple.index(100)  # ValueError!\n```\n\n### Built-in Functions\n\n```python\nmy_tuple = (3, 1, 4, 1, 5, 9, 2, 6)\n\n# Length\nprint(len(my_tuple))  # 8\n\n# Min/Max\nprint(min(my_tuple))  # 1\nprint(max(my_tuple))  # 9\n\n# Sum (numeric tuples)\nprint(sum(my_tuple))  # 31\n\n# Sorted (returns list!)\nsorted_result = sorted(my_tuple)\nprint(sorted_result)  # [1, 1, 2, 3, 4, 5, 6, 9] (list!)\n\n# Any/All\nprint(any(my_tuple))  # True (at least one truthy)\nprint(all(my_tuple))  # True (all truthy)\n```\n\n### Tuple Operations\n\n**Concatenation (+)**:\n```python\ntuple1 = (1, 2, 3)\ntuple2 = (4, 5, 6)\ncombined = tuple1 + tuple2\nprint(combined)  # (1, 2, 3, 4, 5, 6)\n```\n\n**Repetition (*)**:\n```python\nmy_tuple = (1, 2)\nrepeated = my_tuple * 3\nprint(repeated)  # (1, 2, 1, 2, 1, 2)\n```\n\n**Membership (in)**:\n```python\nfruits = (\"apple\", \"banana\", \"cherry\")\nprint(\"apple\" in fruits)      # True\nprint(\"grape\" not in fruits)  # True\n```\n\n**Iteration**:\n```python\nfor fruit in fruits:\n    print(fruit)\n\n# With enumerate\nfor i, fruit in enumerate(fruits):\n    print(f\"{i}: {fruit}\")\n```\n\n---\n\n## When to Use Tuples vs Lists\n\n### Use TUPLES when:\n\n✅ **Data shouldn't change**: GPS coordinates, RGB colors, dates\n✅ **Fixed structure**: Database row, function return values\n✅ **Performance matters**: Large dataset, frequent reads\n✅ **Dictionary keys**: Need hashable type\n✅ **Data integrity**: Prevent accidental modification\n\n**Examples:**\n```python\n# Coordinates (never change)\nlocation = (40.7128, -74.0060)\n\n# RGB color (fixed values)\nred = (255, 0, 0)\n\n# Date (shouldn't change)\nbirthday = (1990, 5, 15)  # Year, Month, Day\n\n# Database record\nstudent = (\"Alice\", 25, \"Computer Science\")\n```\n\n### Use LISTS when:\n\n✅ **Data needs to change**: Shopping cart, to-do list\n✅ **Add/remove items**: Dynamic collections\n✅ **Need list methods**: append, remove, sort, etc.\n✅ **Order may change**: Sorted results\n\n**Examples:**\n```python\n# Shopping cart (items added/removed)\ncart = [\"laptop\", \"mouse\"]\ncart.append(\"keyboard\")\n\n# To-do list (tasks completed)\ntasks = [\"homework\", \"groceries\"]\ntasks.remove(\"homework\")\n\n# Scores (may be sorted)\nscores = [85, 92, 78]\nscores.sort()\n```\n\n### Comparison Table\n\n| Scenario | Use |\n|----------|-----|\n| GPS coordinates | Tuple |\n| Shopping cart items | List |\n| RGB color values | Tuple |\n| Student grades (may change) | List |\n| Function returns | Tuple |\n| Data from user input | List |\n| Configuration settings | Tuple |\n| Game inventory | List |\n| Date (year, month, day) | Tuple |\n| Search results | List |",
    "syntax": "# Create tuple\nmy_tuple = (item1, item2, item3)\nempty = ()\nsingle = (item,)  # Note comma!\n\n# Without parentheses (packing)\nmy_tuple = item1, item2, item3\n\n# tuple() constructor\nmy_tuple = tuple(iterable)\n\n# Access\nfirst = my_tuple[0]\nlast = my_tuple[-1]\n\n# Slice\nsubset = my_tuple[start:stop:step]\n\n# Unpacking\na, b, c = my_tuple\nfirst, *rest, last = my_tuple\n\n# Methods\nmy_tuple.count(value)\nmy_tuple.index(value)\n\n# Operations\ntuple1 + tuple2      # Concatenate\ntuple1 * 3           # Repeat\nvalue in my_tuple    # Membership\nlen(my_tuple)        # Length\nmin(my_tuple)        # Minimum\nmax(my_tuple)        # Maximum\nsum(my_tuple)        # Sum\nsorted(my_tuple)     # Return sorted list",
    "examples": [
        {
            "code": "# Example 1: Creating Tuples\n# With parentheses\ncoordinates = (40.7128, -74.0060)\nfruits = (\"apple\", \"banana\", \"cherry\")\n\n# Without parentheses (tuple packing)\nrgb = 255, 0, 128\n\n# Single element (needs comma!)\nsingle_wrong = (5)     # This is int!\nsingle_correct = (5,)  # This is tuple!\n\nprint(\"Coordinates:\", coordinates, type(coordinates))\nprint(\"RGB:\", rgb, type(rgb))\nprint(\"Single wrong:\", single_wrong, type(single_wrong))\nprint(\"Single correct:\", single_correct, type(single_correct))",
            "output": "Coordinates: (40.7128, -74.006) <class 'tuple'>\nRGB: (255, 0, 128) <class 'tuple'>\nSingle wrong: 5 <class 'int'>\nSingle correct: (5,) <class 'tuple'>",
            "explanation": "Tuples use parentheses (). Parentheses optional for packing. Single element tuple MUST have trailing comma (5,) otherwise Python treats it as expression in parentheses, not tuple."
        },
        {
            "code": "# Example 2: Immutability\nmy_tuple = (1, 2, 3, 4, 5)\nprint(\"Original:\", my_tuple)\n\n# ✅ Can access\nprint(\"First:\", my_tuple[0])\nprint(\"Slice:\", my_tuple[1:4])\n\n# ❌ Cannot modify (would cause error)\n# my_tuple[0] = 10  # TypeError!\n# my_tuple.append(6)  # AttributeError!\n\n# ✅ But can create new tuple\nnew_tuple = my_tuple + (6, 7)\nprint(\"New tuple:\", new_tuple)\nprint(\"Original unchanged:\", my_tuple)",
            "output": "Original: (1, 2, 3, 4, 5)\nFirst: 1\nSlice: (2, 3, 4)\nNew tuple: (1, 2, 3, 4, 5, 6, 7)\nOriginal unchanged: (1, 2, 3, 4, 5)",
            "explanation": "Tuples are IMMUTABLE - once created, cannot be changed. Cannot modify elements, add, or remove. BUT can create NEW tuples using concatenation (+), slicing, etc. Original tuple remains unchanged."
        },
        {
            "code": "# Example 3: Tuple Unpacking\n# Basic unpacking\nperson = (\"Alice\", 25, \"New York\")\nname, age, city = person\n\nprint(f\"Name: {name}\")\nprint(f\"Age: {age}\")\nprint(f\"City: {city}\")\n\n# Extended unpacking with *\nnumbers = (1, 2, 3, 4, 5, 6)\nfirst, second, *rest, last = numbers\n\nprint(f\"\\nFirst: {first}\")\nprint(f\"Second: {second}\")\nprint(f\"Rest: {rest}\")     # List!\nprint(f\"Last: {last}\")",
            "output": "Name: Alice\nAge: 25\nCity: New York\n\nFirst: 1\nSecond: 2\nRest: [3, 4, 5]\nLast: 6",
            "explanation": "Unpacking assigns tuple values to variables. Number of variables must match tuple length. Extended unpacking (*rest) captures remaining values as list. Very useful for function returns."
        },
        {
            "code": "# Example 4: Swapping with Tuples\na = 5\nb = 10\nprint(f\"Before swap: a={a}, b={b}\")\n\n# Python's elegant swap using tuple unpacking\na, b = b, a\n\nprint(f\"After swap: a={a}, b={b}\")\n\n# How it works:\n# Right side: (b, a) creates tuple (10, 5)\n# Left side: a, b unpacks to a=10, b=5",
            "output": "Before swap: a=5, b=10\nAfter swap: a=10, b=5",
            "explanation": "Python's tuple unpacking enables elegant variable swapping without temporary variable. Right side packs values into tuple, left side unpacks. Very Pythonic!"
        },
        {
            "code": "# Example 5: Tuple Methods\nmy_tuple = (1, 2, 3, 2, 4, 2, 5)\n\n# count() - count occurrences\ncount_2 = my_tuple.count(2)\nprint(f\"Number of 2s: {count_2}\")\n\n# index() - find first index\nindex_3 = my_tuple.index(3)\nprint(f\"Index of 3: {index_3}\")\n\n# Built-in functions\nprint(f\"Length: {len(my_tuple)}\")\nprint(f\"Min: {min(my_tuple)}\")\nprint(f\"Max: {max(my_tuple)}\")\nprint(f\"Sum: {sum(my_tuple)}\")",
            "output": "Number of 2s: 3\nIndex of 3: 2\nLength: 7\nMin: 1\nMax: 5\nSum: 20",
            "explanation": "Tuples have only 2 methods: count() and index(). But built-in functions like len(), min(), max(), sum() work fine. Limited methods because tuples are immutable."
        },
        {
            "code": "# Example 6: Multiple Return Values\ndef get_student_info():\n    \"\"\"Return student data as tuple\"\"\"\n    name = \"Alice\"\n    age = 20\n    grade = 'A'\n    subjects = [\"Math\", \"Science\"]\n    return name, age, grade, subjects  # Tuple packing\n\n# Unpack returned tuple\nstudent_name, student_age, student_grade, student_subjects = get_student_info()\n\nprint(f\"Name: {student_name}\")\nprint(f\"Age: {student_age}\")\nprint(f\"Grade: {student_grade}\")\nprint(f\"Subjects: {student_subjects}\")",
            "output": "Name: Alice\nAge: 20\nGrade: A\nSubjects: ['Math', 'Science']",
            "explanation": "Functions commonly return multiple values as tuple. Parentheses optional when returning. Caller unpacks values. Clean way to return structured data without creating class."
        },
        {
            "code": "# Example 7: Tuple vs List Comparison\nimport sys\n\n# Same data\nmy_list = [1, 2, 3, 4, 5]\nmy_tuple = (1, 2, 3, 4, 5)\n\nprint(\"Memory usage:\")\nprint(f\"List: {sys.getsizeof(my_list)} bytes\")\nprint(f\"Tuple: {sys.getsizeof(my_tuple)} bytes\")\n\nprint(\"\\nAvailable methods:\")\nlist_methods = [m for m in dir(my_list) if not m.startswith('_')]\ntuple_methods = [m for m in dir(my_tuple) if not m.startswith('_')]\nprint(f\"List: {len(list_methods)} methods\")\nprint(f\"Tuple: {len(tuple_methods)} methods\")\n\nprint(\"\\nMutability:\")\nmy_list[0] = 10  # Works\nprint(f\"Modified list: {my_list}\")\n# my_tuple[0] = 10  # Would error!\nprint(f\"Tuple unchanged: {my_tuple}\")",
            "output": "Memory usage:\nList: 104 bytes\nTuple: 88 bytes\n\nAvailable methods:\nList: 11 methods\nTuple: 2 methods\n\nMutability:\nModified list: [10, 2, 3, 4, 5]\nTuple unchanged: (1, 2, 3, 4, 5)",
            "explanation": "Tuples use less memory and have fewer methods than lists. Lists are mutable with many methods. Tuples are immutable with just count() and index(). Choose based on whether data should change."
        }
    ],
    "common_mistakes": [
        {
            "mistake": "Forgetting comma for single element tuple",
            "correction": "Always include trailing comma: (item,)",
            "example": "❌ single = (5)  # This is int 5, not tuple!\n   print(type(single))  # <class 'int'>\n\n✅ single = (5,)  # Comma makes it tuple\n   print(type(single))  # <class 'tuple'>"
        },
        {
            "mistake": "Trying to modify tuple elements",
            "correction": "Remember tuples are immutable, create new tuple instead",
            "example": "❌ my_tuple = (1, 2, 3)\n   my_tuple[0] = 10  # TypeError!\n\n✅ my_tuple = (10,) + my_tuple[1:]  # Create new\n   # or\n✅ my_tuple = (10, 2, 3)  # Reassign to new tuple"
        },
        {
            "mistake": "Wrong number of variables when unpacking",
            "correction": "Ensure variables match tuple length or use * for extended unpacking",
            "example": "❌ a, b = (1, 2, 3)  # ValueError!\n❌ a, b, c = (1, 2)  # ValueError!\n\n✅ a, b, c = (1, 2, 3)  # Exact match\n✅ a, *rest = (1, 2, 3)  # Extended unpacking"
        },
        {
            "mistake": "Expecting sorted() to return tuple",
            "correction": "sorted() always returns list, use tuple() to convert",
            "example": "my_tuple = (3, 1, 4, 1, 5)\n\n❌ result = sorted(my_tuple)  # Returns LIST!\n   print(type(result))  # <class 'list'>\n\n✅ result = tuple(sorted(my_tuple))  # Returns tuple\n   print(type(result))  # <class 'tuple'>"
        },
        {
            "mistake": "Using tuple methods that don't exist (like append)",
            "correction": "Remember tuples have only count() and index() methods",
            "example": "❌ my_tuple.append(4)  # AttributeError!\n❌ my_tuple.remove(2)  # AttributeError!\n❌ my_tuple.sort()     # AttributeError!\n\n✅ my_tuple.count(2)   # Works\n✅ my_tuple.index(3)   # Works"
        }
    ],
    "interview_questions": [
        {
            "question": "What is the main difference between tuple and list?",
            "difficulty": "Easy",
            "answer": "Tuples are IMMUTABLE (cannot be changed after creation), lists are MUTABLE (can be modified). Tuples use (), lists use []. Tuples are faster, use less memory, have fewer methods. Use tuples for fixed data, lists for changing data."
        },
        {
            "question": "How do you create a single element tuple?",
            "difficulty": "Easy",
            "answer": "Use trailing comma: single = (5,). Without comma, (5) is just integer 5 in parentheses, not tuple. The comma is what makes it tuple, not parentheses."
        },
        {
            "question": "Can you modify a tuple? If yes, how? If no, why?",
            "difficulty": "Medium",
            "answer": "No, tuples are immutable - cannot modify elements. TypeError if you try. This ensures data integrity and allows tuples to be hashable (usable as dict keys). Can reassign variable to new tuple, or create new tuple from existing: new = old[:2] + (5,)."
        },
        {
            "question": "Explain tuple packing and unpacking with examples.",
            "difficulty": "Medium",
            "answer": "Packing: combining values into tuple: coords = 10, 20 (parentheses optional). Unpacking: extracting values to variables: x, y = coords. Number must match or use * for extended: first, *rest, last = (1,2,3,4,5). Used for swapping: a, b = b, a."
        },
        {
            "question": "What methods does tuple have?",
            "difficulty": "Easy",
            "answer": "Only 2 methods: count(value) - count occurrences, index(value) - find first index. Few methods because tuples are immutable. Built-in functions like len(), min(), max(), sum() still work."
        },
        {
            "question": "Can tuples be used as dictionary keys? Why or why not?",
            "difficulty": "Medium",
            "answer": "Yes, tuples can be dict keys because they're IMMUTABLE and HASHABLE. Lists cannot be keys because they're mutable. Example: locations = {(40.7, -74.0): 'NYC', (34.0, -118.2): 'LA'}. Useful for composite keys."
        },
        {
            "question": "What happens when you add two tuples?",
            "difficulty": "Easy",
            "answer": "Creates NEW tuple with elements from both. (1,2) + (3,4) returns (1,2,3,4). Doesn't modify originals (tuples are immutable). Concatenation is one way to 'add' to tuple."
        },
        {
            "question": "Can a tuple contain mutable objects? What are the implications?",
            "difficulty": "Hard",
            "answer": "Yes, tuple can contain list/dict: t = (1, [2,3]). Tuple structure is immutable (can't change t[0]=5), but list inside can be modified: t[1].append(4) works. Makes tuple unhashable if it contains mutable objects."
        },
        {
            "question": "When should you use tuple instead of list?",
            "difficulty": "Medium",
            "answer": "Use tuple when: 1) Data shouldn't change (coordinates, RGB), 2) Performance matters (faster), 3) Need dict key (hashable), 4) Function returns (common pattern), 5) Signal intent (constant data). Use list for dynamic data."
        },
        {
            "question": "What is the output of: a, b = b, a where a=5, b=10?",
            "difficulty": "Easy",
            "answer": "a becomes 10, b becomes 5 (swapped). Right side packs to tuple (10, 5), then unpacks to a, b. Python evaluates right side completely before assignment, so no temp variable needed."
        }
    ],
    "practice_problems": [
        {
            "difficulty": "Beginner",
            "problem": "Create a tuple with 5 numbers, access first and last elements, and print length.",
            "hint": "Use indexing [0] and [-1]",
            "solution": "my_tuple = (10, 20, 30, 40, 50)\n\nprint(\"Tuple:\", my_tuple)\nprint(\"First:\", my_tuple[0])\nprint(\"Last:\", my_tuple[-1])\nprint(\"Length:\", len(my_tuple))"
        },
        {
            "difficulty": "Beginner",
            "problem": "Create tuple (1, 2, 3, 2, 4, 2, 5). Count how many times 2 appears and find its first index.",
            "hint": "Use count() and index() methods",
            "solution": "my_tuple = (1, 2, 3, 2, 4, 2, 5)\n\ncount_2 = my_tuple.count(2)\nindex_2 = my_tuple.index(2)\n\nprint(f\"Number of 2s: {count_2}\")\nprint(f\"First index of 2: {index_2}\")"
        },
        {
            "difficulty": "Intermediate",
            "problem": "Swap two variables using tuple unpacking. Start with a=100, b=200.",
            "hint": "Use: a, b = b, a",
            "solution": "a = 100\nb = 200\n\nprint(f\"Before: a={a}, b={b}\")\n\na, b = b, a\n\nprint(f\"After: a={a}, b={b}\")"
        },
        {
            "difficulty": "Intermediate",
            "problem": "Write function that returns min, max, and average of a list as tuple.",
            "hint": "Use min(), max(), sum()/len() and return multiple values",
            "solution": "def analyze(numbers):\n    minimum = min(numbers)\n    maximum = max(numbers)\n    average = sum(numbers) / len(numbers)\n    return minimum, maximum, average\n\n# Test\nnums = [45, 12, 78, 23, 91, 34]\nmin_val, max_val, avg_val = analyze(nums)\n\nprint(f\"Min: {min_val}\")\nprint(f\"Max: {max_val}\")\nprint(f\"Average: {avg_val:.2f}\")"
        },
        {
            "difficulty": "Advanced",
            "problem": "Convert list [('Alice', 85), ('Bob', 92), ('Charlie', 78)] to two separate lists: names and scores.",
            "hint": "Use unpacking in loop or zip with unpacking",
            "solution": "students = [('Alice', 85), ('Bob', 92), ('Charlie', 78)]\n\n# Method 1: Loop with unpacking\nnames = []\nscores = []\nfor name, score in students:\n    names.append(name)\n    scores.append(score)\n\n# Method 2: Zip with unpacking (elegant!)\nnames, scores = zip(*students)\nnames = list(names)\nscores = list(scores)\n\nprint(\"Names:\", names)\nprint(\"Scores:\", scores)"
        }
    ],
    "real_world_use_cases": [
        {
            "scenario": "GPS Coordinates Storage",
            "description": "Store and work with geographical locations",
            "code": "# Famous locations as (latitude, longitude)\nlocations = {\n    \"New York\": (40.7128, -74.0060),\n    \"London\": (51.5074, -0.1278),\n    \"Tokyo\": (35.6762, 139.6503),\n    \"Paris\": (48.8566, 2.3522)\n}\n\ndef distance_info(loc1_name, loc2_name):\n    \"\"\"Get coordinates for two cities\"\"\"\n    loc1 = locations[loc1_name]\n    loc2 = locations[loc2_name]\n    \n    lat1, lon1 = loc1  # Unpacking\n    lat2, lon2 = loc2\n    \n    print(f\"{loc1_name}: ({lat1}, {lon1})\")\n    print(f\"{loc2_name}: ({lat2}, {lon2})\")\n\ndistance_info(\"New York\", \"London\")"
        },
        {
            "scenario": "RGB Color Management",
            "description": "Define and use color values",
            "code": "# Colors as (R, G, B) tuples\nCOLORS = {\n    'RED': (255, 0, 0),\n    'GREEN': (0, 255, 0),\n    'BLUE': (0, 0, 255),\n    'WHITE': (255, 255, 255),\n    'BLACK': (0, 0, 0),\n    'YELLOW': (255, 255, 0)\n}\n\ndef mix_colors(color1, color2):\n    \"\"\"Average two colors\"\"\"\n    r1, g1, b1 = color1\n    r2, g2, b2 = color2\n    \n    r = (r1 + r2) // 2\n    g = (g1 + g2) // 2\n    b = (b1 + b2) // 2\n    \n    return (r, g, b)\n\nresult = mix_colors(COLORS['RED'], COLORS['BLUE'])\nprint(f\"Red + Blue = RGB{result}\")\n# Output: Red + Blue = RGB(127, 0, 127) - Purple!"
        },
        {
            "scenario": "Database Query Results",
            "description": "Represent database rows as tuples",
            "code": "# Simulate database results (each row as tuple)\nemployees = [\n    (1, \"Alice Smith\", \"Engineering\", 95000),\n    (2, \"Bob Johnson\", \"Marketing\", 75000),\n    (3, \"Charlie Brown\", \"Engineering\", 85000),\n    (4, \"Diana Prince\", \"HR\", 70000)\n]\n\ndef find_by_department(dept):\n    \"\"\"Filter employees by department\"\"\"\n    results = []\n    for employee in employees:\n        emp_id, name, department, salary = employee\n        if department == dept:\n            results.append((name, salary))\n    return results\n\neng_employees = find_by_department(\"Engineering\")\nprint(\"Engineering Employees:\")\nfor name, salary in eng_employees:\n    print(f\"  {name}: ${salary:,}\")"
        },
        {
            "scenario": "Configuration Settings",
            "description": "Store immutable configuration",
            "code": "# Application configuration (shouldn't change during runtime)\nCONFIG = {\n    'DATABASE': ('localhost', 5432, 'myapp_db'),\n    'API_ENDPOINT': ('api.example.com', 443, '/v1'),\n    'CACHE': ('127.0.0.1', 6379, 0),\n    'WINDOW_SIZE': (1920, 1080),\n    'VERSION': (2, 1, 4)  # Major, Minor, Patch\n}\n\ndef get_db_connection():\n    \"\"\"Get database connection details\"\"\"\n    host, port, database = CONFIG['DATABASE']\n    print(f\"Connecting to {database} on {host}:{port}\")\n    return host, port, database\n\ndef get_version_string():\n    \"\"\"Format version as string\"\"\"\n    major, minor, patch = CONFIG['VERSION']\n    return f\"{major}.{minor}.{patch}\"\n\nget_db_connection()\nprint(f\"App Version: {get_version_string()}\")"
        }
    ],
    "exam_notes": [
        "Tuple: ordered, immutable collection, allows duplicates",
        "Syntax: (item1, item2, item3) or item1, item2, item3",
        "Single element tuple needs trailing comma: (5,)",
        "Tuples are IMMUTABLE - cannot modify after creation",
        "Can access with indexing: tuple[0], tuple[-1]",
        "Slicing works same as lists: tuple[start:stop:step]",
        "Only 2 methods: count() and index()",
        "Parentheses optional when creating (tuple packing)",
        "Unpacking: extracting values to variables",
        "Number of variables must match tuple length in unpacking",
        "Extended unpacking: first, *rest, last = tuple",
        "Can use * to capture multiple values as list",
        "Functions return multiple values as tuple",
        "Swapping: a, b = b, a uses tuple packing/unpacking",
        "Tuples faster and use less memory than lists",
        "Tuples can be dict keys (immutable), lists cannot",
        "sorted(tuple) returns list, not tuple",
        "Concatenation creates new tuple: tuple1 + tuple2",
        "Tuples can contain mutable objects (list, dict)",
        "Use tuples for fixed data, lists for changing data"
    ],
    "summary": "Tuples are Python's immutable, ordered collections - perfect for data that shouldn't change.\n\n**Key Characteristics:**\n\n✅ **Ordered**: Items maintain position\n✅ **Immutable**: Cannot be changed after creation\n✅ **Hashable**: Can be dict keys\n✅ **Fast**: Faster than lists\n✅ **Memory efficient**: Use less memory\n\n**Creation:**\n```python\nmy_tuple = (1, 2, 3)    # With parentheses\nmy_tuple = 1, 2, 3      # Without (packing)\nsingle = (5,)           # Trailing comma!\nempty = ()\n```\n\n**Tuple vs List:**\n\n| Feature | Tuple | List |\n|---------|-------|------|\n| Syntax | `()` | `[]` |\n| Mutable | ❌ No | ✅ Yes |\n| Speed | ✅ Fast | Slower |\n| Memory | ✅ Less | More |\n| Methods | 2 | 11+ |\n| Dict key | ✅ Yes | ❌ No |\n\n**Methods (Only 2!):**\n```python\nmy_tuple.count(value)   # Count occurrences\nmy_tuple.index(value)   # Find first index\n```\n\n**Packing & Unpacking:**\n```python\n# Packing\ncoords = 10, 20  # Creates (10, 20)\n\n# Unpacking\nx, y = coords    # x=10, y=20\n\n# Extended\nfirst, *rest, last = (1,2,3,4,5)\n# first=1, rest=[2,3,4], last=5\n\n# Swapping\na, b = b, a\n```\n\n**When to Use:**\n\n**Use Tuples:**\n- GPS coordinates: `(lat, lon)`\n- RGB colors: `(255, 0, 0)`\n- Database rows\n- Function returns\n- Fixed configuration\n- Dictionary keys\n\n**Use Lists:**\n- Shopping cart (add/remove)\n- To-do list (modify)\n- User input\n- Sorted results\n\n**Important:**\n```python\n# ❌ Cannot modify\nmy_tuple[0] = 10  # TypeError!\n\n# ✅ Can create new\nnew = my_tuple + (10,)\n\n# ❌ Single element\nsingle = (5)  # int!\n\n# ✅ Correct\nsingle = (5,)  # tuple\n```\n\n**Common Patterns:**\n```python\n# Multiple returns\ndef func():\n    return x, y, z\n\na, b, c = func()\n\n# Coordinate pairs\nlocations = [(x1,y1), (x2,y2)]\n\n# Swap\na, b = b, a\n```\n\n**Remember:**\n- Tuples = immutable, faster, hashable\n- Lists = mutable, flexible\n- Use tuples for data that won't change\n- Trailing comma for single element!\n\nChoose tuples for data integrity and performance!"
}