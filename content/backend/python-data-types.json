{
    "title": "Python Data Types - Complete Guide",
    "slug": "python-data-types",
    "subject": "Python",
    "category": "backend",
    "level": "Beginner",
    "estimated_read_time": "15 minutes",
    "prerequisites": [
        "Python installed and working",
        "Understanding of variables",
        "Basic Python syntax knowledge"
    ],
    "learning_objectives": [
        "Understand all Python built-in data types",
        "Learn the difference between mutable and immutable types",
        "Master numeric types: int, float, complex",
        "Understand sequence types: str, list, tuple",
        "Learn set and dictionary data structures",
        "Use type() function to check data types",
        "Perform type conversion between different types"
    ],
    "theory": "## What are Data Types?\n\n**Data types** define what kind of value a variable can hold and what operations can be performed on it.\n\n### Python Built-in Data Types\n\nPython has **14 built-in data types** grouped into categories:\n\n## 1. Numeric Types\n\n### Integer (int)\n**Whole numbers** without decimal point.\n- Can be positive, negative, or zero\n- No size limit (limited by memory)\n\n```python\nage = 25\ntemperature = -10\nbig_number = 999999999999999999\n```\n\n### Float (float)\n**Numbers with decimal point**.\n- Can represent fractions\n- Limited precision (~15-17 decimal places)\n\n```python\nheight = 5.9\npi = 3.14159\ntemperature = -273.15\n```\n\n### Complex (complex)\n**Complex numbers** with real and imaginary parts.\n- Format: `a + bj` where j = √-1\n- Used in scientific computing\n\n```python\nz = 3 + 4j\nw = 5j\n```\n\n**Comparison Table:**\n\n| Type | Example | Description | Use Case |\n|------|---------|-------------|----------|\n| int | 100, -5, 0 | Whole numbers | Counts, IDs, ages |\n| float | 3.14, -0.5 | Decimal numbers | Measurements, prices |\n| complex | 3+4j | Complex numbers | Math, engineering |\n\n## 2. Text Type\n\n### String (str)\n**Sequence of characters** enclosed in quotes.\n- Single quotes: `'hello'`\n- Double quotes: `\"hello\"`\n- Triple quotes: `'''hello'''` or `\"\"\"hello\"\"\"` (multiline)\n\n```python\nname = \"Alice\"\nmessage = 'Hello, World!'\ndescription = '''This is a\nmultiline string'''\n```\n\n**String Operations:**\n```python\n\"Hello\" + \" World\"  # Concatenation: \"Hello World\"\n\"Hi\" * 3            # Repetition: \"HiHiHi\"\nlen(\"Python\")       # Length: 6\n\"HELLO\".lower()     # Convert: \"hello\"\n```\n\n## 3. Sequence Types\n\n### List (list)\n**Ordered, mutable** collection.\n- Can contain different data types\n- Enclosed in square brackets `[]`\n- Can be modified after creation\n\n```python\nnumbers = [1, 2, 3, 4, 5]\nmixed = [1, \"hello\", 3.14, True]\nempty = []\n```\n\n### Tuple (tuple)\n**Ordered, immutable** collection.\n- Cannot be modified after creation\n- Enclosed in parentheses `()`\n- Faster than lists\n\n```python\ncoordinates = (10, 20)\ncolors = (\"red\", \"green\", \"blue\")\nsingle = (5,)  # Comma needed for single element\n```\n\n### Set (set)\n**Unordered, unique** collection.\n- No duplicate values\n- Enclosed in curly braces `{}`\n- Mutable but elements must be immutable\n\n```python\nunique_numbers = {1, 2, 3, 3, 3}  # Stores {1, 2, 3}\nfruits = {\"apple\", \"banana\", \"orange\"}\n```\n\n**Comparison Table:**\n\n| Type | Ordered | Mutable | Duplicates | Syntax |\n|------|---------|---------|------------|--------|\n| list | ✅ Yes | ✅ Yes | ✅ Allowed | `[1, 2, 3]` |\n| tuple | ✅ Yes | ❌ No | ✅ Allowed | `(1, 2, 3)` |\n| set | ❌ No | ✅ Yes | ❌ Not allowed | `{1, 2, 3}` |\n\n## 4. Mapping Type\n\n### Dictionary (dict)\n**Key-value pairs**, unordered (Python 3.7+ maintains insertion order).\n- Keys must be unique and immutable\n- Values can be any type\n- Enclosed in curly braces with colon `{key: value}`\n\n```python\nperson = {\n    \"name\": \"Alice\",\n    \"age\": 25,\n    \"city\": \"New York\"\n}\n\nscores = {\"math\": 90, \"science\": 85}\n```\n\n## 5. Boolean Type\n\n### Boolean (bool)\n**True or False** values.\n- Used in conditions and comparisons\n- Only two values: `True` and `False` (capital T and F)\n\n```python\nis_active = True\nhas_license = False\n\n# From comparisons\nresult = (5 > 3)  # True\nequal = (10 == 5)  # False\n```\n\n**Truthy and Falsy Values:**\n\n**Falsy** (evaluate to False):\n- `False`\n- `None`\n- `0`, `0.0`\n- Empty collections: `''`, `[]`, `()`, `{}`, `set()`\n\n**Truthy** (evaluate to True):\n- Everything else!\n- Non-zero numbers\n- Non-empty collections\n\n## 6. None Type\n\n**NoneType** represents absence of value.\n- Only one value: `None`\n- Similar to null in other languages\n\n```python\nresult = None\noptional_value = None\n```\n\n## Mutable vs Immutable\n\n### Immutable Types\n**Cannot be changed** after creation. Modifying creates a new object.\n\n**Immutable types:**\n- int, float, complex\n- str\n- tuple\n- bool\n- frozenset\n\n```python\nx = \"hello\"\nx = x + \" world\"  # Creates NEW string, doesn't modify original\n```\n\n### Mutable Types\n**Can be changed** after creation. Modifications happen in-place.\n\n**Mutable types:**\n- list\n- dict\n- set\n\n```python\nmy_list = [1, 2, 3]\nmy_list.append(4)  # Modifies existing list\nprint(my_list)  # [1, 2, 3, 4]\n```\n\n**Why It Matters:**\n```python\n# Immutable (creates new object)\nx = 5\ny = x\nx = 10\nprint(y)  # 5 (unchanged)\n\n# Mutable (same object)\nlist1 = [1, 2, 3]\nlist2 = list1\nlist1.append(4)\nprint(list2)  # [1, 2, 3, 4] (changed!)\n```\n\n## Type Checking with type()\n\nUse `type()` function to check data type:\n\n```python\ntype(100)         # <class 'int'>\ntype(3.14)        # <class 'float'>\ntype(\"hello\")     # <class 'str'>\ntype([1, 2, 3])   # <class 'list'>\ntype({\"a\": 1})    # <class 'dict'>\n```\n\nCheck if variable is specific type:\n```python\nx = 100\nif type(x) == int:\n    print(\"x is an integer\")\n\n# Better way (recommended):\nif isinstance(x, int):\n    print(\"x is an integer\")\n```\n\n## Type Conversion (Type Casting)\n\n### Explicit Conversion\n\n**Convert between types using constructor functions:**\n\n```python\nint(\"123\")      # String to int: 123\nfloat(\"3.14\")   # String to float: 3.14\nstr(100)        # Int to string: \"100\"\nbool(1)         # Int to bool: True\nlist(\"abc\")     # String to list: ['a', 'b', 'c']\ntuple([1,2,3])  # List to tuple: (1, 2, 3)\nset([1,2,2,3])  # List to set: {1, 2, 3}\n```\n\n**Conversion Table:**\n\n| From → To | Function | Example | Result |\n|-----------|----------|---------|--------|\n| str → int | `int()` | `int(\"123\")` | `123` |\n| str → float | `float()` | `float(\"3.14\")` | `3.14` |\n| int → str | `str()` | `str(100)` | `\"100\"` |\n| float → int | `int()` | `int(3.7)` | `3` (truncates) |\n| list → tuple | `tuple()` | `tuple([1,2])` | `(1, 2)` |\n| list → set | `set()` | `set([1,1,2])` | `{1, 2}` |\n\n### Implicit Conversion\n\nPython automatically converts types in some operations:\n\n```python\nx = 5       # int\ny = 2.5     # float\nz = x + y   # z becomes float: 7.5\n\nresult = True + 5  # True converts to 1: result = 6\n```\n\n## Common Type Operations\n\n### Getting Size/Length\n```python\nlen(\"Python\")      # 6\nlen([1, 2, 3])     # 3\nlen({\"a\": 1})      # 1\n```\n\n### Checking Membership\n```python\n5 in [1, 2, 3, 4, 5]         # True\n\"hello\" in \"hello world\"     # True\n\"x\" not in {\"a\", \"b\", \"c\"}  # True\n```\n\n### Getting Min/Max\n```python\nmax([1, 5, 3])     # 5\nmin([1, 5, 3])     # 1\nmax(\"python\")      # 'y' (by ASCII value)\n```",
    "syntax": "# Numeric types\nint_var = 100\nfloat_var = 3.14\ncomplex_var = 3 + 4j\n\n# String\nstring_var = \"Hello\"\n\n# List (mutable)\nlist_var = [1, 2, 3, 4]\n\n# Tuple (immutable)\ntuple_var = (1, 2, 3)\n\n# Set (unique, unordered)\nset_var = {1, 2, 3}\n\n# Dictionary (key-value pairs)\ndict_var = {\"name\": \"Alice\", \"age\": 25}\n\n# Boolean\nbool_var = True\n\n# None\nnone_var = None\n\n# Check type\nprint(type(variable))\n\n# Type conversion\nint(\"123\")        # String to integer\nfloat(100)        # Integer to float\nstr(3.14)         # Float to string\nlist(\"abc\")       # String to list\ntuple([1, 2])     # List to tuple",
    "examples": [
        {
            "code": "# Example 1: Numeric Types\ninteger = 100\nfloating = 3.14\ncomplex_num = 3 + 4j\n\nprint(\"Integer:\", integer, \"Type:\", type(integer))\nprint(\"Float:\", floating, \"Type:\", type(floating))\nprint(\"Complex:\", complex_num, \"Type:\", type(complex_num))",
            "output": "Integer: 100 Type: <class 'int'>\nFloat: 3.14 Type: <class 'float'>\nComplex: (3+4j) Type: <class 'complex'>",
            "explanation": "Python has three numeric types. int for whole numbers, float for decimals, and complex for complex numbers (a+bj format). Use type() to verify the data type of any variable."
        },
        {
            "code": "# Example 2: Strings\nsingle = 'Hello'\ndouble = \"World\"\nmultiline = '''This is\na multiline\nstring'''\n\nprint(single)\nprint(double)\nprint(len(single))  # Length\nprint(single + \" \" + double)  # Concatenation\nprint(\"Hi\" * 3)  # Repetition",
            "output": "Hello\nWorld\n5\nHello World\nHiHiHi",
            "explanation": "Strings can use single, double, or triple quotes. len() gets string length. + concatenates strings. * repeats strings. Strings are immutable - operations create new strings."
        },
        {
            "code": "# Example 3: List (Mutable)\nnumbers = [1, 2, 3, 4, 5]\nmixed = [1, \"hello\", 3.14, True]\n\nprint(\"Original:\", numbers)\nnumbers.append(6)  # Add element\nprint(\"After append:\", numbers)\n\nnumbers[0] = 100  # Modify element\nprint(\"After modify:\", numbers)\n\nprint(\"Mixed list:\", mixed)",
            "output": "Original: [1, 2, 3, 4, 5]\nAfter append: [1, 2, 3, 4, 5, 6]\nAfter modify: [100, 2, 3, 4, 5, 6]\nMixed list: [1, 'hello', 3.14, True]",
            "explanation": "Lists are mutable - can be modified after creation. append() adds elements. Square brackets modify elements. Lists can hold mixed data types. Lists use square brackets []."
        },
        {
            "code": "# Example 4: Tuple (Immutable)\ncoordinates = (10, 20)\ncolors = (\"red\", \"green\", \"blue\")\n\nprint(\"Coordinates:\", coordinates)\nprint(\"First color:\", colors[0])\nprint(\"Length:\", len(colors))\n\n# This would cause error:\n# coordinates[0] = 15  # TypeError: tuple doesn't support item assignment",
            "output": "Coordinates: (10, 20)\nFirst color: red\nLength: 3",
            "explanation": "Tuples are immutable - cannot be changed after creation. Use parentheses (). Can access elements with indexing. Attempting to modify raises TypeError. Tuples are faster than lists."
        },
        {
            "code": "# Example 5: Set (Unique Values)\nnumbers = {1, 2, 3, 3, 3, 2, 1}  # Duplicates removed\nfruits = {\"apple\", \"banana\", \"orange\"}\n\nprint(\"Numbers:\", numbers)  # {1, 2, 3}\nfruits.add(\"grape\")\nprint(\"After add:\", fruits)\n\nprint(\"Is 'apple' in fruits?\", \"apple\" in fruits)",
            "output": "Numbers: {1, 2, 3}\nAfter add: {'apple', 'grape', 'banana', 'orange'}\nIs 'apple' in fruits? True",
            "explanation": "Sets automatically remove duplicates and store unique values only. Use curly braces {}. Sets are unordered - order may vary. add() adds elements. 'in' checks membership."
        },
        {
            "code": "# Example 6: Dictionary\nperson = {\n    \"name\": \"Alice\",\n    \"age\": 25,\n    \"city\": \"New York\"\n}\n\nprint(\"Name:\", person[\"name\"])\nprint(\"Age:\", person[\"age\"])\n\nperson[\"age\"] = 26  # Modify value\nperson[\"email\"] = \"alice@example.com\"  # Add new key\n\nprint(\"Updated:\", person)",
            "output": "Name: Alice\nAge: 25\nUpdated: {'name': 'Alice', 'age': 26, 'city': 'New York', 'email': 'alice@example.com'}",
            "explanation": "Dictionaries store key-value pairs. Access values using keys: dict[key]. Modify values by reassignment. Add new keys by assigning to new key. Keys must be unique and immutable."
        },
        {
            "code": "# Example 7: Type Conversion\n# String to number\nage_str = \"25\"\nage_int = int(age_str)\nprint(\"String to int:\", age_int, type(age_int))\n\n# Number to string\nnum = 100\nnum_str = str(num)\nprint(\"Int to string:\", num_str, type(num_str))\n\n# List to tuple\nmy_list = [1, 2, 3]\nmy_tuple = tuple(my_list)\nprint(\"List to tuple:\", my_tuple, type(my_tuple))\n\n# Float to int (truncates decimal)\nfloat_num = 3.7\nint_num = int(float_num)\nprint(\"Float to int:\", int_num)",
            "output": "String to int: 25 <class 'int'>\nInt to string: 100 <class 'str'>\nList to tuple: (1, 2, 3) <class 'tuple'>\nFloat to int: 3",
            "explanation": "Type conversion uses constructor functions: int(), float(), str(), list(), tuple(), set(). Converting float to int truncates (removes decimal). Always verify types after conversion using type()."
        }
    ],
    "common_mistakes": [
        {
            "mistake": "Trying to modify immutable types (strings, tuples)",
            "correction": "Immutable types cannot be changed. Create a new object instead.",
            "example": "❌ text = \"hello\"\n❌ text[0] = \"H\"  # TypeError!\n\n✅ text = \"hello\"\n✅ text = \"H\" + text[1:]  # Creates new string \"Hello\""
        },
        {
            "mistake": "Forgetting comma in single-element tuple",
            "correction": "Single-element tuples need trailing comma: (5,) not (5)",
            "example": "❌ single = (5)      # This is just int 5\n❌ print(type(single))  # <class 'int'>\n\n✅ single = (5,)     # This is tuple\n✅ print(type(single))  # <class 'tuple'>"
        },
        {
            "mistake": "Converting invalid strings to numbers",
            "correction": "Ensure string contains valid numeric value before conversion",
            "example": "❌ int(\"hello\")  # ValueError: invalid literal\n❌ float(\"abc\")  # ValueError\n\n✅ int(\"123\")    # 123\n✅ float(\"3.14\") # 3.14\n\n# Check before converting:\nif text.isdigit():\n    num = int(text)"
        },
        {
            "mistake": "Assuming set/dict maintain order (Python < 3.7)",
            "correction": "Sets are unordered. Dicts maintain insertion order in Python 3.7+",
            "example": "# Sets are always unordered\nmy_set = {3, 1, 2}\nprint(my_set)  # Order may vary: {1, 2, 3}\n\n# Dicts maintain order in Python 3.7+\nmy_dict = {\"c\": 3, \"a\": 1, \"b\": 2}\nprint(my_dict)  # {'c': 3, 'a': 1, 'b': 2}"
        },
        {
            "mistake": "Using mutable default arguments in functions",
            "correction": "Use None as default, then create mutable object inside function",
            "example": "❌ def add_item(item, items=[]):\n    items.append(item)\n    return items\n# Problem: list persists between calls!\n\n✅ def add_item(item, items=None):\n    if items is None:\n        items = []\n    items.append(item)\n    return items"
        },
        {
            "mistake": "Confusing = (assignment) with == (comparison)",
            "correction": "= assigns value, == checks equality",
            "example": "❌ if x = 5:  # SyntaxError\n\n✅ if x == 5:  # Compares x with 5\n✅ x = 5  # Assigns 5 to x"
        }
    ],
    "interview_questions": [
        {
            "question": "What are the main data types in Python?",
            "difficulty": "Easy",
            "answer": "Python has several built-in types: Numeric (int, float, complex), Text (str), Sequence (list, tuple, range), Mapping (dict), Set (set, frozenset), Boolean (bool), Binary (bytes, bytearray), and None type. Most common: int, float, str, list, tuple, dict, set, bool."
        },
        {
            "question": "What is the difference between list and tuple?",
            "difficulty": "Easy",
            "answer": "Lists are mutable (can be changed) and use square brackets []. Tuples are immutable (cannot be changed) and use parentheses (). Lists: [1,2,3], Tuples: (1,2,3). Tuples are faster and memory-efficient. Use lists when data changes, tuples when data is constant."
        },
        {
            "question": "What is the difference between mutable and immutable types?",
            "difficulty": "Medium",
            "answer": "Mutable types can be modified after creation (list, dict, set). Immutable types cannot be changed (int, float, str, tuple). Modifying immutable types creates new objects. Example: str concatenation creates new string; list.append() modifies existing list."
        },
        {
            "question": "How do you check the data type of a variable?",
            "difficulty": "Easy",
            "answer": "Use type() function: type(variable) returns the class/type. Example: type(5) returns <class 'int'>. Use isinstance(variable, type) to check if variable is specific type: isinstance(5, int) returns True."
        },
        {
            "question": "What is the difference between set and list?",
            "difficulty": "Easy",
            "answer": "Lists are ordered and allow duplicates: [1,2,2,3]. Sets are unordered and store only unique values: {1,2,3}. Lists use [], sets use {}. Lists maintain insertion order and allow indexing. Sets don't support indexing but have faster membership testing."
        },
        {
            "question": "How do you convert a string to an integer in Python?",
            "difficulty": "Easy",
            "answer": "Use int() function: int('123') returns 123. If string contains invalid characters, raises ValueError. For strings with decimal, convert to float first: int(float('3.14')). Can specify base: int('FF', 16) converts hexadecimal."
        },
        {
            "question": "What happens when you convert float to int?",
            "difficulty": "Easy",
            "answer": "Decimal part is truncated (removed), not rounded. int(3.7) returns 3, int(3.2) returns 3. For rounding, use round() first: int(round(3.7)) returns 4. Negative numbers: int(-3.7) returns -3."
        },
        {
            "question": "What is a dictionary in Python?",
            "difficulty": "Easy",
            "answer": "Dictionary is a collection of key-value pairs. Keys must be unique and immutable (strings, numbers, tuples). Values can be any type. Syntax: {'key': 'value'}. Access: dict['key']. Fast lookups by key. Python 3.7+ maintains insertion order."
        },
        {
            "question": "Explain truthy and falsy values in Python.",
            "difficulty": "Medium",
            "answer": "Falsy values evaluate to False in boolean context: False, None, 0, 0.0, empty collections ('', [], {}, ()). Everything else is truthy. Used in conditions: if my_list: executes only if list is not empty. bool() converts to True/False."
        },
        {
            "question": "What is the output of: list1 = [1,2,3]; list2 = list1; list1.append(4); print(list2)?",
            "difficulty": "Hard",
            "answer": "[1, 2, 3, 4]. Because lists are mutable, list2 = list1 creates a reference to the same list object, not a copy. Changes to list1 affect list2. To create independent copy: list2 = list1.copy() or list2 = list1[:]. Then changes don't affect each other."
        }
    ],
    "practice_problems": [
        {
            "difficulty": "Beginner",
            "problem": "Create variables of each data type (int, float, str, list, tuple, dict, bool) and print their types.",
            "hint": "Use type() function to check types",
            "solution": "integer = 100\nfloating = 3.14\nstring = \"Hello\"\nmy_list = [1, 2, 3]\nmy_tuple = (1, 2, 3)\nmy_dict = {\"name\": \"Alice\"}\nboolean = True\n\nprint(type(integer))   # <class 'int'>\nprint(type(floating))  # <class 'float'>\nprint(type(string))    # <class 'str'>\nprint(type(my_list))   # <class 'list'>\nprint(type(my_tuple))  # <class 'tuple'>\nprint(type(my_dict))   # <class 'dict'>\nprint(type(boolean))   # <class 'bool'>"
        },
        {
            "difficulty": "Beginner",
            "problem": "Convert the string '123' to integer, then add 50 to it.",
            "hint": "Use int() to convert string to integer",
            "solution": "num_str = '123'\nnum_int = int(num_str)\nresult = num_int + 50\nprint(result)  # 173"
        },
        {
            "difficulty": "Intermediate",
            "problem": "Create a list of numbers with duplicates. Convert it to a set to remove duplicates.",
            "hint": "Use set() constructor",
            "solution": "numbers = [1, 2, 2, 3, 3, 3, 4, 5, 5]\nprint(\"Original list:\", numbers)\n\nunique = set(numbers)\nprint(\"Unique values:\", unique)  # {1, 2, 3, 4, 5}\n\n# Convert back to list if needed:\nunique_list = list(unique)\nprint(\"Back to list:\", unique_list)"
        },
        {
            "difficulty": "Intermediate",
            "problem": "Create a dictionary with student names as keys and their scores as values. Print each student's name and score.",
            "hint": "Use dictionary and loop through items()",
            "solution": "students = {\n    \"Alice\": 85,\n    \"Bob\": 92,\n    \"Charlie\": 78\n}\n\nfor name, score in students.items():\n    print(f\"{name}: {score}\")\n\n# Output:\n# Alice: 85\n# Bob: 92\n# Charlie: 78"
        },
        {
            "difficulty": "Advanced",
            "problem": "Explain why list1=[1,2]; list2=list1; list1.append(3) affects list2, but x=5; y=x; x=10 doesn't affect y.",
            "hint": "Think about mutable vs immutable types",
            "solution": "# Lists are MUTABLE (stored by reference)\nlist1 = [1, 2]\nlist2 = list1  # Both point to SAME list object\nlist1.append(3)\nprint(list2)  # [1, 2, 3] - changed!\n\n# Integers are IMMUTABLE (stored by value)\nx = 5\ny = x  # y gets a COPY of value\nx = 10  # x now points to NEW integer object\nprint(y)  # 5 - unchanged!\n\n# To copy list independently:\nlist1 = [1, 2]\nlist2 = list1.copy()  # Creates new list\nlist1.append(3)\nprint(list2)  # [1, 2] - unchanged!"
        }
    ],
    "real_world_use_cases": [
        {
            "scenario": "User Profile Storage",
            "description": "Storing user information in a dictionary",
            "code": "user = {\n    \"id\": 1001,\n    \"username\": \"alice_wonder\",\n    \"email\": \"alice@example.com\",\n    \"is_active\": True,\n    \"login_count\": 45,\n    \"roles\": [\"user\", \"editor\"]\n}\n\nprint(f\"Welcome back, {user['username']}!\")\nprint(f\"You've logged in {user['login_count']} times\")\n\n# Update data\nuser['login_count'] += 1\nuser['last_login'] = \"2024-01-15\""
        },
        {
            "scenario": "Product Inventory Management",
            "description": "Using lists and dictionaries to manage inventory",
            "code": "products = [\n    {\"id\": 101, \"name\": \"Laptop\", \"price\": 999.99, \"stock\": 15},\n    {\"id\": 102, \"name\": \"Mouse\", \"price\": 29.99, \"stock\": 50},\n    {\"id\": 103, \"name\": \"Keyboard\", \"price\": 79.99, \"stock\": 30}\n]\n\n# Calculate total inventory value\ntotal_value = sum(p['price'] * p['stock'] for p in products)\nprint(f\"Total inventory value: ${total_value:.2f}\")\n\n# Find low stock items\nlow_stock = [p['name'] for p in products if p['stock'] < 20]\nprint(f\"Low stock: {low_stock}\")"
        },
        {
            "scenario": "Email Validation",
            "description": "Removing duplicate emails using set",
            "code": "email_list = [\n    \"alice@example.com\",\n    \"bob@example.com\",\n    \"alice@example.com\",  # Duplicate\n    \"charlie@example.com\",\n    \"bob@example.com\"  # Duplicate\n]\n\nprint(f\"Total emails: {len(email_list)}\")\n\n# Remove duplicates\nunique_emails = set(email_list)\nprint(f\"Unique emails: {len(unique_emails)}\")\nprint(unique_emails)"
        },
        {
            "scenario": "Temperature Data Analysis",
            "description": "Using numeric types and type conversion",
            "code": "# Temperature readings (strings from sensor)\nreadings = [\"23.5\", \"25.0\", \"22.8\", \"24.2\", \"26.1\"]\n\n# Convert to float for calculations\ntemperatures = [float(temp) for temp in readings]\n\naverage = sum(temperatures) / len(temperatures)\nmax_temp = max(temperatures)\nmin_temp = min(temperatures)\n\nprint(f\"Average: {average:.2f}°C\")\nprint(f\"Max: {max_temp}°C\")\nprint(f\"Min: {min_temp}°C\")"
        }
    ],
    "exam_notes": [
        "Data types define what kind of value a variable can hold",
        "Numeric types: int (whole numbers), float (decimals), complex (a+bj)",
        "Text type: str (string) - sequence of characters in quotes",
        "Sequence types: list (mutable, []), tuple (immutable, ()), set (unique, {})",
        "Mapping type: dict (key-value pairs, {key: value})",
        "Boolean type: bool (True or False only)",
        "None type: represents absence of value",
        "Mutable types: list, dict, set (can be modified after creation)",
        "Immutable types: int, float, str, tuple, bool (cannot be modified)",
        "type() function returns data type: type(variable)",
        "isinstance(var, type) checks if variable is specific type",
        "Type conversion: int(), float(), str(), list(), tuple(), set(), dict(), bool()",
        "String to int: int('123') → 123",
        "Float to int truncates: int(3.7) → 3 (doesn't round)",
        "Empty collections are falsy: '', [], (), {}, set()",
        "Zero and None are falsy: 0, 0.0, None",
        "Lists allow duplicates and indexing, sets don't",
        "Tuples require trailing comma for single element: (5,)",
        "Dictionary keys must be immutable (str, int, tuple)",
        "len() returns length/size of sequence or collection"
    ],
    "summary": "Python has rich built-in data types for different purposes. Understanding them is crucial for effective programming.\n\n**Main Data Types:**\n\n✅ **Numeric**: int, float, complex\n✅ **Text**: str (strings)\n✅ **Sequence**: list (mutable), tuple (immutable), set (unique)\n✅ **Mapping**: dict (key-value pairs)\n✅ **Boolean**: bool (True/False)\n✅ **None**: None (absence of value)\n\n**Mutable vs Immutable:**\n\n**Mutable** (can change): list, dict, set\n**Immutable** (cannot change): int, float, str, tuple, bool\n\n**Type Checking & Conversion:**\n```python\ntype(variable)          # Get type\nisinstance(var, int)    # Check type\nint('123')              # Convert to int\nfloat(100)              # Convert to float\nstr(3.14)               # Convert to string\n```\n\n**Quick Reference:**\n\n| Type | Example | Mutable | Ordered | Duplicates |\n|------|---------|---------|---------|------------|\n| int | 100 | ❌ | N/A | N/A |\n| float | 3.14 | ❌ | N/A | N/A |\n| str | \"hello\" | ❌ | ✅ | ✅ |\n| list | [1,2,3] | ✅ | ✅ | ✅ |\n| tuple | (1,2,3) | ❌ | ✅ | ✅ |\n| set | {1,2,3} | ✅ | ❌ | ❌ |\n| dict | {\"a\":1} | ✅ | ✅* | Keys: ❌ |\n\n*Python 3.7+ maintains insertion order\n\n**Remember:**\n- Use lists for changeable ordered data\n- Use tuples for constant ordered data\n- Use sets for unique values\n- Use dicts for labeled data (key-value)\n\nMaster these types to write efficient, bug-free Python code!"
}