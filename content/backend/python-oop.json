{
    "title": "Python Object-Oriented Programming (OOP) - Complete Guide",
    "slug": "python-oop",
    "subject": "Python",
    "category": "backend",
    "level": "Intermediate",
    "estimated_read_time": "22 minutes",
    "prerequisites": [
        "Python functions",
        "Python data structures (lists, dictionaries)",
        "Understanding of code organization",
        "Python exception handling (helpful)"
    ],
    "learning_objectives": [
        "Understand Object-Oriented Programming paradigm",
        "Create classes and instantiate objects",
        "Use constructors and instance methods",
        "Implement inheritance to reuse code",
        "Apply polymorphism and method overriding",
        "Practice encapsulation with private attributes",
        "Understand abstraction and abstract classes",
        "Design real-world systems using OOP principles"
    ],
    "theory": "## What is Object-Oriented Programming?\n\n**OOP** is a programming paradigm that organizes code around **objects** (data + behavior) rather than functions and logic.\n\n### Real-World Analogy\n\nThink of **car manufacturing**:\n- **Blueprint (Class)**: Car design specifications\n- **Actual Car (Object)**: Physical car built from blueprint\n- **Properties (Attributes)**: Color, brand, speed\n- **Actions (Methods)**: start(), accelerate(), brake()\n\nMultiple cars (objects) can be created from same blueprint (class), each with different properties.\n\n### Four Pillars of OOP\n\n1. **Encapsulation**: Bundle data and methods together\n2. **Abstraction**: Hide complex implementation details\n3. **Inheritance**: Reuse code from existing classes\n4. **Polymorphism**: Same interface, different implementations\n\n### Procedural vs OOP\n\n**Procedural (Functions):**\n```python\n# Data separated from functions\ncar1_brand = \"Toyota\"\ncar1_speed = 0\n\ndef accelerate_car1():\n    global car1_speed\n    car1_speed += 10\n```\n\n**OOP (Classes):**\n```python\n# Data and functions together\nclass Car:\n    def __init__(self, brand):\n        self.brand = brand\n        self.speed = 0\n    \n    def accelerate(self):\n        self.speed += 10\n\ncar1 = Car(\"Toyota\")\ncar1.accelerate()\n```\n\n---\n\n## Classes and Objects\n\n### Class (Blueprint)\n\n**Class** is a template/blueprint for creating objects.\n\n```python\nclass Car:\n    # Class definition\n    pass\n```\n\n**Analogy**: Cookie cutter is the class, cookies are objects.\n\n### Object (Instance)\n\n**Object** is a specific instance created from a class.\n\n```python\n# Create objects from class\ncar1 = Car()  # Object 1\ncar2 = Car()  # Object 2\n```\n\n### Visual Representation\n\n```\nClass: Car (Blueprint)\n  ├── Attributes: brand, color, speed\n  └── Methods: start(), stop(), accelerate()\n\nObjects (Instances):\n  Car1: brand=\"Toyota\", color=\"Red\", speed=0\n  Car2: brand=\"Honda\", color=\"Blue\", speed=0\n  Car3: brand=\"Tesla\", color=\"White\", speed=0\n```\n\n### Basic Class Example\n\n```python\nclass Dog:\n    # Class attribute (shared by all dogs)\n    species = \"Canis familiaris\"\n    \n    # Instance method\n    def bark(self):\n        return \"Woof!\"\n\n# Create objects\ndog1 = Dog()\ndog2 = Dog()\n\nprint(dog1.species)  # Canis familiaris\nprint(dog1.bark())   # Woof!\n```\n\n---\n\n## Constructor (__init__)\n\n**Constructor** is a special method that initializes object state when created.\n\n### Syntax\n\n```python\nclass ClassName:\n    def __init__(self, parameters):\n        # Initialize instance attributes\n        self.attribute = value\n```\n\n### The 'self' Parameter\n\n**self** refers to the current instance.\n\n```python\nclass Person:\n    def __init__(self, name, age):\n        self.name = name  # Instance attribute\n        self.age = age    # Instance attribute\n    \n    def introduce(self):\n        return f\"Hi, I'm {self.name}, {self.age} years old\"\n\n# Create objects\nperson1 = Person(\"Alice\", 25)\nperson2 = Person(\"Bob\", 30)\n\nprint(person1.introduce())  # Hi, I'm Alice, 25 years old\nprint(person2.introduce())  # Hi, I'm Bob, 30 years old\n```\n\n### Class vs Instance Attributes\n\n```python\nclass Employee:\n    # Class attribute (shared by all)\n    company = \"TechCorp\"\n    \n    def __init__(self, name, salary):\n        # Instance attributes (unique to each)\n        self.name = name\n        self.salary = salary\n\nemp1 = Employee(\"Alice\", 50000)\nemp2 = Employee(\"Bob\", 60000)\n\nprint(emp1.company)  # TechCorp (class attribute)\nprint(emp1.name)     # Alice (instance attribute)\nprint(emp2.name)     # Bob (different instance)\n```\n\n---\n\n## Instance Methods\n\nMethods that operate on instance data.\n\n```python\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.balance = balance\n    \n    def deposit(self, amount):\n        self.balance += amount\n        return f\"Deposited ${amount}. New balance: ${self.balance}\"\n    \n    def withdraw(self, amount):\n        if amount > self.balance:\n            return \"Insufficient funds\"\n        self.balance -= amount\n        return f\"Withdrew ${amount}. New balance: ${self.balance}\"\n\naccount = BankAccount(\"Alice\", 1000)\nprint(account.deposit(500))   # Deposited $500. New balance: $1500\nprint(account.withdraw(200))  # Withdrew $200. New balance: $1300\n```\n\n---\n\n## Inheritance\n\n**Inheritance** allows a class to inherit attributes and methods from another class.\n\n### Syntax\n\n```python\nclass ParentClass:\n    # Parent class definition\n    pass\n\nclass ChildClass(ParentClass):\n    # Child class inherits from parent\n    pass\n```\n\n### Visual Hierarchy\n\n```\n        Animal (Parent)\n       /      |      \\\n     Dog    Cat    Bird (Children)\n```\n\n### Basic Inheritance\n\n```python\n# Parent class\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n    \n    def speak(self):\n        return \"Some sound\"\n\n# Child class\nclass Dog(Animal):\n    def speak(self):  # Override parent method\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):  # Override parent method\n        return \"Meow!\"\n\n# Create objects\ndog = Dog(\"Buddy\")\ncat = Cat(\"Whiskers\")\n\nprint(dog.name)    # Buddy (inherited from Animal)\nprint(dog.speak()) # Woof! (overridden in Dog)\nprint(cat.speak()) # Meow! (overridden in Cat)\n```\n\n### super() Function\n\nCall parent class methods:\n\n```python\nclass Vehicle:\n    def __init__(self, brand, year):\n        self.brand = brand\n        self.year = year\n    \n    def info(self):\n        return f\"{self.brand} ({self.year})\"\n\nclass Car(Vehicle):\n    def __init__(self, brand, year, doors):\n        super().__init__(brand, year)  # Call parent constructor\n        self.doors = doors\n    \n    def info(self):\n        parent_info = super().info()  # Call parent method\n        return f\"{parent_info}, {self.doors} doors\"\n\ncar = Car(\"Toyota\", 2024, 4)\nprint(car.info())  # Toyota (2024), 4 doors\n```\n\n### Multiple Inheritance\n\nInherit from multiple parents:\n\n```python\nclass Flyable:\n    def fly(self):\n        return \"Flying...\"\n\nclass Swimmable:\n    def swim(self):\n        return \"Swimming...\"\n\nclass Duck(Flyable, Swimmable):\n    def quack(self):\n        return \"Quack!\"\n\nduck = Duck()\nprint(duck.fly())   # Flying... (from Flyable)\nprint(duck.swim())  # Swimming... (from Swimmable)\nprint(duck.quack()) # Quack! (own method)\n```\n\n---\n\n## Polymorphism\n\n**Polymorphism** means \"many forms\" - same interface, different implementations.\n\n### Method Overriding\n\nChild class redefines parent method:\n\n```python\nclass Shape:\n    def area(self):\n        return 0\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):  # Override\n        return self.width * self.height\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):  # Override\n        return 3.14 * self.radius ** 2\n\n# Polymorphic behavior\nshapes = [Rectangle(5, 10), Circle(7)]\n\nfor shape in shapes:\n    print(f\"Area: {shape.area()}\")  # Different implementations\n```\n\n### Duck Typing\n\nIf it walks like a duck and quacks like a duck, it's a duck.\n\n```python\nclass Dog:\n    def speak(self):\n        return \"Woof!\"\n\nclass Cat:\n    def speak(self):\n        return \"Meow!\"\n\nclass Robot:\n    def speak(self):\n        return \"Beep!\"\n\ndef make_speak(thing):\n    # Don't care about type, just that it has speak()\n    return thing.speak()\n\nprint(make_speak(Dog()))    # Woof!\nprint(make_speak(Cat()))    # Meow!\nprint(make_speak(Robot()))  # Beep!\n```\n\n---\n\n## Encapsulation\n\n**Encapsulation** bundles data and methods, hiding internal implementation.\n\n### Public, Protected, Private\n\n```python\nclass BankAccount:\n    def __init__(self, owner, balance):\n        self.owner = owner           # Public\n        self._account_number = \"1234\"  # Protected (convention)\n        self.__pin = \"0000\"           # Private (name mangling)\n    \n    def get_pin(self):  # Public method to access private\n        return \"Cannot show PIN\"\n    \n    def __validate_pin(self, pin):  # Private method\n        return pin == self.__pin\n\naccount = BankAccount(\"Alice\", 1000)\nprint(account.owner)           # Public - OK\nprint(account._account_number) # Protected - works but discouraged\n# print(account.__pin)         # Private - AttributeError!\nprint(account.get_pin())       # Access via public method\n```\n\n**Naming Conventions:**\n- `public`: Normal attribute/method\n- `_protected`: Single underscore (convention, not enforced)\n- `__private`: Double underscore (name mangling)\n\n### Getters and Setters\n\n```python\nclass Person:\n    def __init__(self, name, age):\n        self._name = name\n        self._age = age\n    \n    # Getter\n    @property\n    def age(self):\n        return self._age\n    \n    # Setter\n    @age.setter\n    def age(self, value):\n        if value < 0:\n            raise ValueError(\"Age cannot be negative\")\n        self._age = value\n\nperson = Person(\"Alice\", 25)\nprint(person.age)  # Uses getter: 25\n\nperson.age = 26    # Uses setter\nprint(person.age)  # 26\n\n# person.age = -5  # ValueError!\n```\n\n### Why Encapsulation?\n\n1. **Data Protection**: Control access to data\n2. **Validation**: Validate before setting values\n3. **Flexibility**: Change implementation without breaking code\n4. **Abstraction**: Hide complexity\n\n---\n\n## Abstraction\n\n**Abstraction** hides implementation details, shows only essential features.\n\n### Abstract Base Classes\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):  # Abstract class\n    @abstractmethod\n    def speak(self):\n        pass  # Must be implemented by child\n    \n    @abstractmethod\n    def move(self):\n        pass  # Must be implemented by child\n\n# Cannot instantiate abstract class\n# animal = Animal()  # TypeError!\n\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\n    \n    def move(self):\n        return \"Running\"\n\n# Must implement all abstract methods\ndog = Dog()\nprint(dog.speak())  # Woof!\nprint(dog.move())   # Running\n```\n\n### Interface-like Design\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass PaymentProcessor(ABC):\n    @abstractmethod\n    def process_payment(self, amount):\n        pass\n\nclass CreditCardProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        return f\"Processing ${amount} via Credit Card\"\n\nclass PayPalProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        return f\"Processing ${amount} via PayPal\"\n\ndef checkout(processor, amount):\n    return processor.process_payment(amount)\n\nprint(checkout(CreditCardProcessor(), 100))\nprint(checkout(PayPalProcessor(), 50))\n```\n\n---\n\n## Special Methods (Magic Methods)\n\n### __str__ and __repr__\n\n```python\nclass Book:\n    def __init__(self, title, author):\n        self.title = title\n        self.author = author\n    \n    def __str__(self):  # User-friendly string\n        return f\"{self.title} by {self.author}\"\n    \n    def __repr__(self):  # Developer-friendly representation\n        return f\"Book('{self.title}', '{self.author}')\"\n\nbook = Book(\"Python Guide\", \"Alice\")\nprint(str(book))   # Python Guide by Alice\nprint(repr(book))  # Book('Python Guide', 'Alice')\n```\n\n### Operator Overloading\n\n```python\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __add__(self, other):  # + operator\n        return Vector(self.x + other.x, self.y + other.y)\n    \n    def __str__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\nv1 = Vector(2, 3)\nv2 = Vector(4, 5)\nv3 = v1 + v2  # Calls __add__\nprint(v3)  # Vector(6, 8)\n```\n\n### Other Magic Methods\n\n```python\nclass MyList:\n    def __init__(self, items):\n        self.items = items\n    \n    def __len__(self):  # len()\n        return len(self.items)\n    \n    def __getitem__(self, index):  # []\n        return self.items[index]\n    \n    def __contains__(self, item):  # in\n        return item in self.items\n\nmy_list = MyList([1, 2, 3, 4, 5])\nprint(len(my_list))    # 5\nprint(my_list[2])      # 3\nprint(3 in my_list)    # True\n```\n\n---\n\n## Class Methods and Static Methods\n\n### Class Methods\n\n```python\nclass Employee:\n    company = \"TechCorp\"\n    \n    def __init__(self, name):\n        self.name = name\n    \n    @classmethod\n    def change_company(cls, new_company):\n        cls.company = new_company\n\n# Call on class\nEmployee.change_company(\"NewCorp\")\nprint(Employee.company)  # NewCorp\n```\n\n### Static Methods\n\n```python\nclass MathUtils:\n    @staticmethod\n    def add(a, b):\n        return a + b\n    \n    @staticmethod\n    def multiply(a, b):\n        return a * b\n\n# Call without instance\nprint(MathUtils.add(5, 3))       # 8\nprint(MathUtils.multiply(4, 7))  # 28\n```\n\n### Comparison\n\n| Type | Access | Use Case |\n|------|--------|----------|\n| Instance method | `self` | Operate on instance data |\n| Class method | `cls` | Operate on class data |\n| Static method | Neither | Utility functions |\n\n---\n\n## Composition\n\nComposition: \"has-a\" relationship (alternative to inheritance).\n\n```python\nclass Engine:\n    def start(self):\n        return \"Engine started\"\n\nclass Car:\n    def __init__(self, brand):\n        self.brand = brand\n        self.engine = Engine()  # Car HAS an Engine\n    \n    def start(self):\n        return f\"{self.brand}: {self.engine.start()}\"\n\ncar = Car(\"Toyota\")\nprint(car.start())  # Toyota: Engine started\n```\n\n**When to use:**\n- Inheritance: \"is-a\" (Dog IS an Animal)\n- Composition: \"has-a\" (Car HAS an Engine)",
    "syntax": "# Define class\nclass ClassName:\n    # Constructor\n    def __init__(self, parameters):\n        self.attribute = value\n    \n    # Instance method\n    def method(self):\n        return self.attribute\n\n# Create object\nobj = ClassName(arguments)\n\n# Inheritance\nclass Child(Parent):\n    def __init__(self, params):\n        super().__init__(parent_params)\n\n# Abstract class\nfrom abc import ABC, abstractmethod\n\nclass AbstractClass(ABC):\n    @abstractmethod\n    def method(self):\n        pass\n\n# Property decorator\n@property\ndef attribute(self):\n    return self._attribute\n\n@attribute.setter\ndef attribute(self, value):\n    self._attribute = value\n\n# Class method\n@classmethod\ndef method(cls):\n    pass\n\n# Static method\n@staticmethod\ndef method():\n    pass",
    "examples": [
        {
            "code": "# Example 1: Basic Class and Object\nclass Car:\n    def __init__(self, brand, color, year):\n        self.brand = brand\n        self.color = color\n        self.year = year\n        self.speed = 0\n    \n    def accelerate(self):\n        self.speed += 10\n        return f\"{self.brand} accelerating. Speed: {self.speed} km/h\"\n    \n    def brake(self):\n        self.speed = max(0, self.speed - 10)\n        return f\"{self.brand} braking. Speed: {self.speed} km/h\"\n\n# Create objects\ncar1 = Car(\"Toyota\", \"Red\", 2024)\ncar2 = Car(\"Honda\", \"Blue\", 2023)\n\nprint(car1.accelerate())\nprint(car1.accelerate())\nprint(car1.brake())\nprint(f\"Car: {car1.brand}, Color: {car1.color}\")",
            "output": "Toyota accelerating. Speed: 10 km/h\nToyota accelerating. Speed: 20 km/h\nToyota braking. Speed: 10 km/h\nCar: Toyota, Color: Red",
            "explanation": "Class is blueprint with __init__ constructor. Objects car1 and car2 are instances with unique attributes. Methods operate on instance data (self). Each object maintains its own state."
        },
        {
            "code": "# Example 2: Inheritance\nclass Animal:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def speak(self):\n        return \"Some sound\"\n    \n    def info(self):\n        return f\"{self.name} is {self.age} years old\"\n\nclass Dog(Animal):\n    def speak(self):  # Override\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):  # Override\n        return \"Meow!\"\n\ndog = Dog(\"Buddy\", 3)\ncat = Cat(\"Whiskers\", 2)\n\nprint(dog.info())   # Inherited from Animal\nprint(dog.speak())  # Overridden in Dog\nprint(cat.speak())  # Overridden in Cat",
            "output": "Buddy is 3 years old\nWoof!\nMeow!",
            "explanation": "Dog and Cat inherit from Animal. They inherit __init__ and info() but override speak(). Each child provides specific implementation. super() could be used to call parent methods."
        },
        {
            "code": "# Example 3: Encapsulation with Properties\nclass BankAccount:\n    def __init__(self, owner, balance):\n        self.owner = owner\n        self.__balance = balance  # Private\n    \n    @property\n    def balance(self):  # Getter\n        return self.__balance\n    \n    def deposit(self, amount):\n        if amount > 0:\n            self.__balance += amount\n            return f\"Deposited ${amount}\"\n        return \"Invalid amount\"\n    \n    def withdraw(self, amount):\n        if 0 < amount <= self.__balance:\n            self.__balance -= amount\n            return f\"Withdrew ${amount}\"\n        return \"Invalid or insufficient funds\"\n\naccount = BankAccount(\"Alice\", 1000)\nprint(f\"Balance: ${account.balance}\")\nprint(account.deposit(500))\nprint(account.withdraw(200))\nprint(f\"Final balance: ${account.balance}\")\n# account.__balance = 0  # Won't work (private)",
            "output": "Balance: $1000\nDeposited $500\nWithdrew $200\nFinal balance: $1300",
            "explanation": "Private attribute __balance protects data. @property decorator creates getter for read access. Methods deposit/withdraw provide controlled modification. Direct access to __balance is prevented."
        },
        {
            "code": "# Example 4: Polymorphism with Shapes\nclass Shape:\n    def area(self):\n        return 0\n    \n    def perimeter(self):\n        return 0\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return 3.14 * self.radius ** 2\n    \n    def perimeter(self):\n        return 2 * 3.14 * self.radius\n\n# Polymorphic behavior\nshapes = [Rectangle(5, 10), Circle(7), Rectangle(3, 4)]\n\nfor shape in shapes:\n    print(f\"Area: {shape.area():.2f}, Perimeter: {shape.perimeter():.2f}\")",
            "output": "Area: 50.00, Perimeter: 30.00\nArea: 153.86, Perimeter: 43.96\nArea: 12.00, Perimeter: 14.00",
            "explanation": "Same method names (area, perimeter) but different implementations. Loop treats all shapes uniformly. Each shape calculates correctly based on its type. This is polymorphism in action."
        },
        {
            "code": "# Example 5: Abstract Base Class\nfrom abc import ABC, abstractmethod\n\nclass Vehicle(ABC):\n    @abstractmethod\n    def start(self):\n        pass\n    \n    @abstractmethod\n    def stop(self):\n        pass\n\nclass Car(Vehicle):\n    def start(self):\n        return \"Car started\"\n    \n    def stop(self):\n        return \"Car stopped\"\n\nclass Bike(Vehicle):\n    def start(self):\n        return \"Bike started\"\n    \n    def stop(self):\n        return \"Bike stopped\"\n\n# vehicle = Vehicle()  # TypeError! Can't instantiate abstract class\n\ncar = Car()\nbike = Bike()\n\nprint(car.start())\nprint(bike.start())\nprint(car.stop())",
            "output": "Car started\nBike started\nCar stopped",
            "explanation": "Abstract class Vehicle defines interface (start, stop must exist). Cannot create Vehicle directly. Car and Bike must implement all abstract methods. Ensures consistent interface across subclasses."
        },
        {
            "code": "# Example 6: Composition (HAS-A relationship)\nclass Engine:\n    def __init__(self, horsepower):\n        self.horsepower = horsepower\n    \n    def start(self):\n        return f\"Engine ({self.horsepower}HP) started\"\n\nclass Car:\n    def __init__(self, brand, horsepower):\n        self.brand = brand\n        self.engine = Engine(horsepower)  # Car HAS an Engine\n    \n    def start(self):\n        engine_msg = self.engine.start()\n        return f\"{self.brand}: {engine_msg}\"\n\ncar = Car(\"Toyota\", 200)\nprint(car.start())\nprint(f\"Brand: {car.brand}, Power: {car.engine.horsepower}HP\")",
            "output": "Toyota: Engine (200HP) started\nBrand: Toyota, Power: 200HP",
            "explanation": "Composition: Car HAS an Engine (not IS an Engine). More flexible than inheritance. Engine is independent object. Car delegates start to its engine. Easier to change/extend behavior."
        },
        {
            "code": "# Example 7: Magic Methods and Operator Overloading\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __str__(self):\n        return f\"Point({self.x}, {self.y})\"\n    \n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n    \n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n    \n    def distance_from_origin(self):\n        return (self.x**2 + self.y**2)**0.5\n\np1 = Point(3, 4)\np2 = Point(1, 2)\np3 = p1 + p2  # Uses __add__\n\nprint(p1)  # Uses __str__\nprint(p3)\nprint(f\"Distance: {p1.distance_from_origin():.2f}\")\nprint(f\"p1 == p2: {p1 == p2}\")  # Uses __eq__",
            "output": "Point(3, 4)\nPoint(4, 6)\nDistance: 5.00\np1 == p2: False",
            "explanation": "Magic methods customize object behavior. __str__ for printing, __add__ for + operator, __eq__ for == operator. Makes objects behave like built-in types. Very Pythonic!"
        }
    ],
    "common_mistakes": [
        {
            "mistake": "Forgetting 'self' in instance methods",
            "correction": "First parameter of instance method must be 'self'",
            "example": "❌ class Car:\n       def start():  # Missing self!\n           pass\n\n✅ class Car:\n       def start(self):  # Correct\n           pass"
        },
        {
            "mistake": "Not calling parent __init__ in child class",
            "correction": "Use super().__init__() to initialize parent",
            "example": "❌ class Dog(Animal):\n       def __init__(self, name, breed):\n           self.breed = breed  # Parent attributes not initialized!\n\n✅ class Dog(Animal):\n       def __init__(self, name, breed):\n           super().__init__(name)  # Initialize parent\n           self.breed = breed"
        },
        {
            "mistake": "Trying to modify private attributes directly",
            "correction": "Use public methods or properties to access private data",
            "example": "class Account:\n    def __init__(self):\n        self.__balance = 0\n\n❌ account.__balance = 1000  # Won't work!\n\n✅ # Provide setter method or property\n   @property\n   def balance(self):\n       return self.__balance"
        },
        {
            "mistake": "Using mutable default arguments in __init__",
            "correction": "Use None as default, create mutable inside __init__",
            "example": "❌ def __init__(self, items=[]):\n       self.items = items  # Shared across instances!\n\n✅ def __init__(self, items=None):\n       self.items = items if items else []"
        },
        {
            "mistake": "Not implementing all abstract methods",
            "correction": "Child of abstract class must implement all abstract methods",
            "example": "from abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def speak(self):\n        pass\n\n❌ class Dog(Animal):\n       pass  # TypeError! No speak() implementation\n\n✅ class Dog(Animal):\n       def speak(self):\n           return \"Woof!\""
        }
    ],
    "interview_questions": [
        {
            "question": "What is the difference between a class and an object?",
            "difficulty": "Easy",
            "answer": "Class is a blueprint/template defining structure and behavior. Object is a specific instance created from class. Like: Car is class (blueprint), my_car is object (actual car with specific color, brand)."
        },
        {
            "question": "Explain the four pillars of OOP.",
            "difficulty": "Medium",
            "answer": "1) Encapsulation: Bundle data and methods, hide implementation. 2) Abstraction: Hide complexity, show essentials. 3) Inheritance: Reuse code from parent class. 4) Polymorphism: Same interface, different implementations."
        },
        {
            "question": "What is the purpose of 'self' in Python?",
            "difficulty": "Easy",
            "answer": "'self' refers to current instance of class. Allows access to instance attributes and methods. Must be first parameter of instance methods. Python passes it automatically when calling methods."
        },
        {
            "question": "What's the difference between instance and class variables?",
            "difficulty": "Medium",
            "answer": "Instance variables: unique to each object, defined in __init__. Class variables: shared by all objects, defined at class level. Example: each car has own color (instance), all cars have same species='vehicle' (class)."
        },
        {
            "question": "How does inheritance work in Python?",
            "difficulty": "Easy",
            "answer": "Child class inherits attributes/methods from parent. Use class Child(Parent). super() calls parent methods. Allows code reuse and specialization. Child can override parent methods for different behavior."
        },
        {
            "question": "What is method overriding vs method overloading?",
            "difficulty": "Hard",
            "answer": "Overriding: Child redefines parent method (Python supports). Overloading: Same method name, different parameters (Python doesn't support directly, use default args/kwargs). Overriding is polymorphism."
        },
        {
            "question": "Explain the difference between public, protected, and private attributes.",
            "difficulty": "Medium",
            "answer": "Public: no underscore, accessible everywhere. Protected: single _ (convention, not enforced). Private: double __ (name mangling, harder to access). Example: self.public, self._protected, self.__private."
        },
        {
            "question": "What are abstract classes and when to use them?",
            "difficulty": "Hard",
            "answer": "Abstract classes (ABC) define interface but can't be instantiated. Force subclasses to implement methods. Use when: want common interface, ensure methods exist in children. Example: Shape with abstract area() method."
        },
        {
            "question": "What is the difference between inheritance and composition?",
            "difficulty": "Medium",
            "answer": "Inheritance: IS-A relationship (Dog IS an Animal). Composition: HAS-A relationship (Car HAS an Engine). Composition more flexible, easier to change. Prefer composition over deep inheritance hierarchies."
        },
        {
            "question": "Explain @property decorator.",
            "difficulty": "Medium",
            "answer": "@property creates getter for attribute access. @attribute.setter creates setter. Allows validation/computation while using simple attribute syntax. Example: person.age (calls getter) vs person.age = 25 (calls setter with validation)."
        }
    ],
    "practice_problems": [
        {
            "difficulty": "Beginner",
            "problem": "Create a Rectangle class with width, height, and methods to calculate area and perimeter.",
            "hint": "Use __init__, create area() and perimeter() methods",
            "solution": "class Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\nrect = Rectangle(5, 10)\nprint(f\"Area: {rect.area()}\")\nprint(f\"Perimeter: {rect.perimeter()}\")"
        },
        {
            "difficulty": "Intermediate",
            "problem": "Create Employee and Manager classes. Manager inherits from Employee and has additional team_size attribute.",
            "hint": "Use inheritance and super()",
            "solution": "class Employee:\n    def __init__(self, name, salary):\n        self.name = name\n        self.salary = salary\n    \n    def info(self):\n        return f\"{self.name}: ${self.salary}\"\n\nclass Manager(Employee):\n    def __init__(self, name, salary, team_size):\n        super().__init__(name, salary)\n        self.team_size = team_size\n    \n    def info(self):\n        return f\"{super().info()}, Team: {self.team_size}\"\n\nmanager = Manager(\"Alice\", 80000, 5)\nprint(manager.info())"
        },
        {
            "difficulty": "Intermediate",
            "problem": "Create BankAccount class with private balance and methods deposit, withdraw with validation.",
            "hint": "Use __ for private, validate amounts",
            "solution": "class BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance\n    \n    @property\n    def balance(self):\n        return self.__balance\n    \n    def deposit(self, amount):\n        if amount <= 0:\n            return \"Amount must be positive\"\n        self.__balance += amount\n        return f\"Deposited ${amount}\"\n    \n    def withdraw(self, amount):\n        if amount <=0:\n            return \"Amount must be positive\"\n        if amount > self.__balance:\n            return \"Insufficient funds\"\n        self.__balance -= amount\n        return f\"Withdrew ${amount}\"\n\naccount = BankAccount(\"Alice\", 1000)\nprint(account.deposit(500))\nprint(account.withdraw(200))\nprint(f\"Balance: ${account.balance}\")"
        },
        {
            "difficulty": "Advanced",
            "problem": "Create abstract Animal class with speak() method. Create Dog and Cat subclasses.",
            "hint": "Use ABC and abstractmethod",
            "solution": "from abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    def __init__(self, name):\n        self.name = name\n    \n    @abstractmethod\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return f\"{self.name}: Woof!\"\n\nclass Cat(Animal):\n    def speak(self):\n        return f\"{self.name}: Meow!\"\n\ndog = Dog(\"Buddy\")\ncat = Cat(\"Whiskers\")\nprint(dog.speak())\nprint(cat.speak())"
        },
        {
            "difficulty": "Advanced",
            "problem": "Create Vector class with __add__, __sub__, and __str__ magic methods.",
            "hint": "Implement magic methods for operators",
            "solution": "class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n    \n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n    \n    def __str__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\nv1 = Vector(3, 4)\nv2 = Vector(1, 2)\nv3 = v1 + v2\nv4 = v1 - v2\nprint(v3)  # Vector(4, 6)\nprint(v4)  # Vector(2, 2)"
        }
    ],
    "real_world_use_cases": [
        {
            "scenario": "E-commerce Product System",
            "description": "Product hierarchy with inheritance and polymorphism",
            "code": "class Product:\n    def __init__(self, name, price):\n        self.name = name\n        self.price = price\n    \n    def get_total(self, quantity=1):\n        return self.price * quantity\n    \n    def __str__(self):\n        return f\"{self.name}: ${self.price}\"\n\nclass DigitalProduct(Product):\n    def __init__(self, name, price, file_size):\n        super().__init__(name, price)\n        self.file_size = file_size\n    \n    def download_info(self):\n        return f\"File size: {self.file_size}MB\"\n\nclass PhysicalProduct(Product):\n    def __init__(self, name, price, weight):\n        super().__init__(name, price)\n        self.weight = weight\n    \n    def shipping_cost(self):\n        return self.weight * 0.5  # $0.50 per kg\n    \n    def get_total(self, quantity=1):\n        product_cost = super().get_total(quantity)\n        return product_cost + self.shipping_cost()\n\n# Usage\nebook = DigitalProduct(\"Python Guide\", 29.99, 5)\nlaptop = PhysicalProduct(\"Laptop\", 999.99, 2)\n\nprint(ebook)\nprint(ebook.download_info())\nprint(f\"Total: ${ebook.get_total()}\")\n\nprint(f\"\\n{laptop}\")\nprint(f\"Shipping: ${laptop.shipping_cost()}\")\nprint(f\"Total: ${laptop.get_total():.2f}\")"
        },
        {
            "scenario": "User Authentication System",
            "description": "User management with encapsulation",
            "code": "import hashlib\n\nclass User:\n    def __init__(self, username, password):\n        self.username = username\n        self.__password_hash = self.__hash_password(password)\n        self.__is_active = True\n    \n    def __hash_password(self, password):\n        return hashlib.sha256(password.encode()).hexdigest()\n    \n    def verify_password(self, password):\n        return self.__hash_password(password) == self.__password_hash\n    \n    def change_password(self, old_password, new_password):\n        if not self.verify_password(old_password):\n            return \"Incorrect current password\"\n        self.__password_hash = self.__hash_password(new_password)\n        return \"Password changed successfully\"\n    \n    @property\n    def is_active(self):\n        return self.__is_active\n    \n    def deactivate(self):\n        self.__is_active = False\n        return f\"User {self.username} deactivated\"\n\n# Usage\nuser = User(\"alice\", \"secret123\")\nprint(f\"Username: {user.username}\")\nprint(f\"Password correct: {user.verify_password('secret123')}\")\nprint(f\"Wrong password: {user.verify_password('wrong')}\")\nprint(user.change_password(\"secret123\", \"newsecret\"))\nprint(f\"Active: {user.is_active}\")\nprint(user.deactivate())"
        },
        {
            "scenario": "Shape Drawing System",
            "description": "Abstract shapes with polymorphism",
            "code": "from abc import ABC, abstractmethod\nimport math\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n    \n    @abstractmethod\n    def perimeter(self):\n        pass\n    \n    def display(self):\n        return f\"{self.__class__.__name__}: Area={self.area():.2f}, Perimeter={self.perimeter():.2f}\"\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return math.pi * self.radius ** 2\n    \n    def perimeter(self):\n        return 2 * math.pi * self.radius\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\nclass Triangle(Shape):\n    def __init__(self, a, b, c):\n        self.a = a\n        self.b = b\n        self.c = c\n    \n    def area(self):\n        s = (self.a + self.b + self.c) / 2\n        return math.sqrt(s * (s - self.a) * (s - self.b) * (s - self.c))\n    \n    def perimeter(self):\n        return self.a + self.b + self.c\n\n# Polymorphic usage\nshapes = [\n    Circle(5),\n    Rectangle(4, 6),\n    Triangle(3, 4, 5)\n]\n\nfor shape in shapes:\n    print(shape.display())"
        },
        {
            "scenario": "Library Management System",
            "description": "Book and member management with composition",
            "code": "from datetime import datetime, timedelta\n\nclass Book:\n    def __init__(self, title, author, isbn):\n        self.title = title\n        self.author = author\n        self.isbn = isbn\n        self.is_available = True\n    \n    def __str__(self):\n        status = \"Available\" if self.is_available else \"Borrowed\"\n        return f\"{self.title} by {self.author} ({status})\"\n\nclass Member:\n    def __init__(self, name, member_id):\n        self.name = name\n        self.member_id = member_id\n        self.borrowed_books = []\n    \n    def borrow_book(self, book):\n        if not book.is_available:\n            return f\"{book.title} is not available\"\n        book.is_available = False\n        due_date = datetime.now() + timedelta(days=14)\n        self.borrowed_books.append({\n            'book': book,\n            'due_date': due_date\n        })\n        return f\"{self.name} borrowed {book.title}. Due: {due_date.strftime('%Y-%m-%d')}\"\n    \n    def return_book(self, book):\n        for item in self.borrowed_books:\n            if item['book'] == book:\n                book.is_available = True\n                self.borrowed_books.remove(item)\n                return f\"{self.name} returned {book.title}\"\n        return f\"{book.title} not in borrowed list\"\n\nclass Library:\n    def __init__(self, name):\n        self.name = name\n        self.books = []\n        self.members = []\n    \n    def add_book(self, book):\n        self.books.append(book)\n        return f\"Added: {book.title}\"\n    \n    def register_member(self, member):\n        self.members.append(member)\n        return f\"Registered: {member.name}\"\n    \n    def show_available_books(self):\n        available = [book for book in self.books if book.is_available]\n        return \"\\n\".join(str(book) for book in available)\n\n# Usage\nlibrary = Library(\"City Library\")\n\nbook1 = Book(\"Python Guide\", \"Alice\", \"123\")\nbook2 = Book(\"Java Basics\", \"Bob\", \"456\")\n\nprint(library.add_book(book1))\nprint(library.add_book(book2))\n\nmember = Member(\"John\", \"M001\")\nprint(library.register_member(member))\n\nprint(f\"\\n{member.borrow_book(book1)}\")\nprint(f\"\\nAvailable books:\\n{library.show_available_books()}\")\nprint(f\"\\n{member.return_book(book1)}\")\nprint(f\"\\nAvailable books:\\n{library.show_available_books()}\")"
        }
    ],
    "exam_notes": [
        "OOP: programming paradigm organizing code around objects (data + methods)",
        "Class: blueprint/template for creating objects",
        "Object: specific instance created from class",
        "__init__: constructor method, initializes object state",
        "self: reference to current instance, first parameter of instance methods",
        "Instance variables: unique to each object (self.variable)",
        "Class variables: shared by all instances (defined at class level)",
        "Encapsulation: bundle data and methods, hide implementation",
        "Private attributes: double underscore __ (name mangling)",
        "Protected attributes: single underscore _ (convention only)",
        "@property: decorator to create getter for attribute",
        "@attribute.setter: decorator to create setter with validation",
        "Inheritance: child class inherits from parent (class Child(Parent))",
        "super(): call parent class methods",
        "Method overriding: child redefines parent method",
        "Polymorphism: same interface, different implementations",
        "Abstract class: cannot be instantiated, defines interface (ABC)",
        "@abstractmethod: forces child to implement method",
        "Composition: HAS-A relationship (Car has Engine)",
        "Magic methods: __str__, __add__, __eq__ customize object behavior"
    ],
    "summary": "Object-Oriented Programming organizes code around objects - combining data and behavior in reusable, maintainable structures.\n\n**Core Concepts:**\n\n**Class & Object:**\n```python\nclass Car:  # Blueprint\n    def __init__(self, brand):\n        self.brand = brand  # Instance variable\n    \n    def start(self):  # Instance method\n        return f\"{self.brand} started\"\n\ncar = Car(\"Toyota\")  # Object (instance)\n```\n\n**Four Pillars:**\n\n1. **Encapsulation**\n```python\nclass Account:\n    def __init__(self, balance):\n        self.__balance = balance  # Private\n    \n    @property\n    def balance(self):  # Controlled access\n        return self.__balance\n```\n\n2. **Inheritance**\n```python\nclass Animal:\n    def speak(self):\n        pass\n\nclass Dog(Animal):  # Dog IS-A Animal\n    def speak(self):\n        return \"Woof!\"\n```\n\n3. **Polymorphism**\n```python\n# Same method, different implementations\nfor animal in [Dog(), Cat()]:\n    print(animal.speak())  # Different outputs\n```\n\n4. **Abstraction**\n```python\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):  # Must implement\n        pass\n```\n\n**Key Features:**\n\n| Feature | Purpose |\n|---------|----------|\n| `__init__` | Constructor |\n| `self` | Current instance |\n| `super()` | Call parent method |\n| `@property` | Getter |\n| `@setter` | Setter with validation |\n| `@classmethod` | Operate on class |\n| `@staticmethod` | Utility function |\n\n**Inheritance:**\n```python\nclass Parent:\n    def __init__(self, x):\n        self.x = x\n\nclass Child(Parent):\n    def __init__(self, x, y):\n        super().__init__(x)  # Call parent\n        self.y = y\n```\n\n**Encapsulation Levels:**\n```python\nclass MyClass:\n    def __init__(self):\n        self.public = 1      # Public\n        self._protected = 2  # Protected (convention)\n        self.__private = 3   # Private (name mangling)\n```\n\n**Magic Methods:**\n```python\nclass Point:\n    def __str__(self):  # print()\n        return f\"Point({self.x}, {self.y})\"\n    \n    def __add__(self, other):  # +\n        return Point(self.x + other.x, self.y + other.y)\n    \n    def __eq__(self, other):  # ==\n        return self.x == other.x and self.y == other.y\n```\n\n**Inheritance vs Composition:**\n```python\n# Inheritance: IS-A\nclass Dog(Animal):  # Dog IS-A Animal\n    pass\n\n# Composition: HAS-A\nclass Car:\n    def __init__(self):\n        self.engine = Engine()  # Car HAS-A Engine\n```\n\n**When to Use OOP:**\n✅ Complex systems with related entities\n✅ Code reuse through inheritance\n✅ Data protection with encapsulation\n✅ Modeling real-world objects\n✅ Large codebases needing organization\n\n**Best Practices:**\n- Keep classes focused (single responsibility)\n- Favor composition over deep inheritance\n- Use properties for controlled access\n- Document with docstrings\n- Follow naming conventions\n- Make attributes private when needed\n\n**Common Patterns:**\n```python\n# Singleton\nclass Singleton:\n    _instance = None\n    \n    def __new__(cls):\n        if not cls._instance:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n# Factory\nclass ShapeFactory:\n    @staticmethod\n    def create(shape_type):\n        if shape_type == 'circle':\n            return Circle()\n        elif shape_type == 'rectangle':\n            return Rectangle()\n```\n\nMaster OOP for scalable, maintainable code!"
}