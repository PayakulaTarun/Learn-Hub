{
  "title": "State Management Basics",
  "slug": "react-state-management",
  "subject": "React",
  "category": "Frontend Framework",
  "level": "Intermediate",
  "estimated_read_time": "15 mins",
  "prerequisites": [
    "useContext",
    "useReducer"
  ],
  "learning_objectives": [
    "Prop Drilling limits",
    "Context limits",
    "When to use a Library"
  ],
  "theory": "## Scaling Up\nWhen app state becomes complex (shared across many disconnected components), `useState` and `Context` might not be enough.\n\n### The Problem\n* **Prop Drilling**: Passing data 10 levels down.\n* **Context Performance**: Updating a Context re-renders ALL consumers, which can be slow for rapidly changing data.\n\n### Solutions\n1. **Local State**: Keep it if possible.\n2. **Context**: Low frequency updates (Theme, User).\n3. **Library (Redux/Zustand)**: Complex, frequent, global state.",
  "syntax": "N/A",
  "examples": [],
  "common_mistakes": [],
  "interview_questions": [],
  "practice_problems": [],
  "real_world_use_cases": [],
  "exam_notes": [
    "Lifting State -> Context -> Redux.",
    "Don't over-engineer early."
  ],
  "summary": "Choosing the right state strategy is an architectural decision.",
  "order": 4
}