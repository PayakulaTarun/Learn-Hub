{
  "title": "Memoization (React.memo, useMemo)",
  "slug": "react-memoization",
  "subject": "React",
  "category": "Frontend Framework",
  "level": "Intermediate",
  "estimated_read_time": "15 mins",
  "prerequisites": [
    "Performance Optimization Basics"
  ],
  "learning_objectives": [
    "React.memo",
    "useMemo Hook",
    "Expensive Calculations"
  ],
  "theory": "## Caching Results\n\n### React.memo\nA Higher Order Component to wrap a functional component. It checks if props have changed. If not, it skips re-rendering the component.\n`const Memoized = React.memo(MyComponent);`\n\n### useMemo\nCaches the *result* of a function calculation.\n`const value = useMemo(() => expensiveMath(a, b), [a, b]);`",
  "syntax": "useMemo(() => compute(a), [a])",
  "examples": [
    {
      "code": "const sortedList = useMemo(() => {\n  return items.sort((a, b) => a.value - b.value);\n}, [items]);",
      "output": "Only re-sorts when 'items' changes.",
      "explanation": "Prevents expensive interaction lag."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Memoizing everything.",
      "correction": "Memoization has a cost (memory + comparison). Don't use it for simple calculations or cheap components.",
      "example": "N/A"
    }
  ],
  "interview_questions": [],
  "practice_problems": [],
  "real_world_use_cases": [
    {
      "scenario": "Data Visualization",
      "description": "Filtering 10,000 rows for a Chart. Essential to use useMemo.",
      "code": "N/A"
    }
  ],
  "exam_notes": [
    "React.memo = Component level.",
    "useMemo = Value level.",
    "Referential equality traps (objects)."
  ],
  "summary": "Memoization forces React to remember previous results to save CPU cycles.",
  "order": 33
}