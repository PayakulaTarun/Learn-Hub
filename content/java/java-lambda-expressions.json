{
  "title": "Java Lambda Expressions",
  "slug": "java-lambda-expressions",
  "subject": "Java",
  "category": "Programming Language",
  "level": "Advanced",
  "estimated_read_time": "15 mins",
  "prerequisites": [
    "Interfaces",
    "Java Intefaces"
  ],
  "learning_objectives": [
    "Functional Interfaces",
    "Lambda Syntax (->)",
    "Method References (::)",
    "Why Lambdas?"
  ],
  "theory": "Introduced in Java 8. Detailed way to represent a method using an expression.\n\n*   **Functional Interface**: Interface with ONE abstract method (e.g. Runnable, Comparable).\n*   **Syntax**: `(parameter) -> { body }`",
  "syntax": "List<String> list = ...\nlist.forEach(n -> System.out.println(n));",
  "examples": [
    {
      "code": "Runnable r = () -> System.out.println(\"running\");\nr.run();",
      "output": "running",
      "explanation": "No need to creating anonymous class `new Runnable(){...}`."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Variable Capture",
      "correction": "Local variables used inside lambda must be final or effectively final.",
      "example": ""
    }
  ],
  "interview_questions": [
    {
      "question": "What is @FunctionalInterface annotation?",
      "answer": "Ensures the interface has exactly one abstract method. Compiler error otherwise.",
      "difficulty": "Medium"
    }
  ],
  "practice_problems": [
    {
      "problem": "Sort list using Lambda.",
      "hint": "list.sort((a,b)->a-b)",
      "solution": "...",
      "difficulty": "Medium"
    }
  ],
  "real_world_use_cases": [
    {
      "scenario": "Event Listeners",
      "description": "button.addActionListener(e -> handle());",
      "code": ""
    }
  ],
  "exam_notes": [
    "Code is concise.",
    "Enables functional programming."
  ],
  "summary": "Lambdas reduced boilerplate code in Java significantly.",
  "order": 24
}