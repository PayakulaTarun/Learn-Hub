{
  "title": "Java Security Basics",
  "slug": "java-security",
  "subject": "Java",
  "category": "Programming Language",
  "level": "Advanced",
  "estimated_read_time": "15 mins",
  "prerequisites": [
    "Java File Handling"
  ],
  "learning_objectives": [
    "Security Manager",
    "Cryptography Architecture (JCA)",
    "Hashing & Encryption",
    "Secure Coding Practices"
  ],
  "theory": "Java is designed to be secure.\n\n*   **Bytecode Verifier**: Checks code before execution.\n*   **Security Manager**: Restricts file I/O, network access (sandbox).\n*   **JCA**: APIs for AES, RSA, SHA-256.",
  "syntax": "MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\nbyte[] hash = md.digest(password.getBytes());",
  "examples": [
    {
      "code": "// Storing passwords",
      "output": "",
      "explanation": "Never store plain text. Store hashed (Salted SHA-256 or BCrypt)."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using Random instead of SecureRandom",
      "correction": "Standard Random is predictable. Use `SecureRandom` for crypto keys.",
      "example": ""
    }
  ],
  "interview_questions": [
    {
      "question": "What is SQL Injection prevention in Java?",
      "answer": "Use PreparedStatement instead of Statement to separate code from data.",
      "difficulty": "Important"
    }
  ],
  "practice_problems": [
    {
      "problem": "Hash a string \"hello\".",
      "hint": "MessageDigest",
      "solution": "...",
      "difficulty": "Medium"
    }
  ],
  "real_world_use_cases": [
    {
      "scenario": "HTTPS",
      "description": "Java SSLSocket factories manage secure connections.",
      "code": ""
    }
  ],
  "exam_notes": [
    "Java sandbox allows running untrusted code safely.",
    "Public keys vs Private keys."
  ],
  "summary": "Security is not an add-on.",
  "order": 4
}