{
  "title": "Quick Sort",
  "slug": "quick-sort",
  "subject": "Data Structures",
  "category": "Core Computer Science",
  "level": "Advanced",
  "estimated_read_time": "35 mins",
  "prerequisites": [
    "Divide and Conquer Strategy"
  ],
  "learning_objectives": [
    "Partitioning",
    "Pivot Selection",
    "Worst Case"
  ],
  "theory": "Pick a **Pivot**. Partition array so Left < Pivot < Right. Recursively sort parts. \nTime: O(n log n) avg. O(n^2) worst (if bad pivot). \nSpace: O(log n) stack.",
  "syntax": "partition(arr, low, high)",
  "examples": [],
  "common_mistakes": [
    {
      "mistake": "Bad Pivot",
      "correction": "Picking first element on sorted array leads to O(n^2). Pick random pivot or median-of-3.",
      "example": "sorted Input."
    }
  ],
  "interview_questions": [
    {
      "question": "Why is QuickSort faster than MergeSort usually?",
      "answer": "Better cache locality and inner loop is simpler. No O(n) auxiliary space.",
      "difficulty": "Advanced"
    }
  ],
  "practice_problems": [],
  "real_world_use_cases": [
    {
      "scenario": "C++ std::sort",
      "description": "Uses Introsort (QuickSort, switches to HeapSort if depth exceeds limit).",
      "code": "Hybrid"
    }
  ],
  "exam_notes": [
    "Unstable.",
    "Fastest in practice."
  ],
  "summary": "The default sorting choice for primitives."
}