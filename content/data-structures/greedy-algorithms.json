{
  "title": "Greedy Algorithms",
  "slug": "greedy-algorithms",
  "subject": "Data Structures",
  "category": "Core Computer Science",
  "level": "Intermediate",
  "estimated_read_time": "25 mins",
  "prerequisites": [
    "Sorting Algorithms"
  ],
  "learning_objectives": [
    "Local Optimum",
    "Global Optimum",
    "Interval Scheduling"
  ],
  "theory": "Make the locally optimal choice at each step hoping to find global optimum. Fast, but doesn't always work (e.g., Coin Change for some currencies). works for MST (Prim/Kruskal).",
  "syntax": "sort(options, by=value); pick_best();",
  "examples": [
    {
      "code": "Activity Selection:\n1. Sort by finish time.\n2. Pick first that doesn't overlap.",
      "output": "Max activities",
      "explanation": "Greedy choice works here."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Trusting Greedy blindly",
      "correction": "Greedy works only if problem has 'Greedy Choice Property'. Counter-example: Knapsack 0/1 (Requires DP).",
      "example": "N/A"
    }
  ],
  "interview_questions": [],
  "practice_problems": [],
  "real_world_use_cases": [
    {
      "scenario": "Huffman Coding",
      "description": "Compression algorithm assigns shorter bits to frequent chars.",
      "code": "Compression"
    }
  ],
  "exam_notes": [
    "Proving correctness is hard.",
    "Fast."
  ],
  "summary": "Greedy is shortsighted but effective for specific classes of problems."
}