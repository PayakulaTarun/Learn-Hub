{
  "title": "Dynamic Programming Introduction",
  "slug": "dp-intro",
  "subject": "Data Structures",
  "category": "Core Computer Science",
  "level": "Advanced",
  "estimated_read_time": "30 mins",
  "prerequisites": [
    "Recursion"
  ],
  "learning_objectives": [
    "Overlapping Subproblems",
    "Optimal Substructure",
    "Memoization",
    "Tabulation"
  ],
  "theory": "Optimization of plain recursion. If you solve the same subproblem twice, save the result (**Memoization**). Or build up from base case (**Tabulation**).",
  "syntax": "cache = {}",
  "examples": [
    {
      "code": "Fib(n):\n if n in cache: return cache[n]\n res = Fib(n-1) + Fib(n-2)\n cache[n] = res",
      "output": "O(n)",
      "explanation": "Without cache, it's O(2^n)."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Thinking DP is Magic",
      "correction": "It's just 'Recursion + Cache'.",
      "example": "N/A"
    }
  ],
  "interview_questions": [],
  "practice_problems": [],
  "real_world_use_cases": [],
  "exam_notes": [
    "Top-down vs Bottom-up."
  ],
  "summary": "Trading Space for Time to solve exponential problems."
}