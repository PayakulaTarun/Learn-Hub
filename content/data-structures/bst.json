{
  "title": "Binary Search Tree",
  "slug": "bst",
  "subject": "Data Structures",
  "category": "Core Computer Science",
  "level": "Intermediate",
  "estimated_read_time": "30 mins",
  "prerequisites": [
    "Binary Tree",
    "Binary Search"
  ],
  "learning_objectives": [
    "BST Property",
    "Search/Insert/Delete",
    "Complexity"
  ],
  "theory": "A Binary Tree with a rule:\n- **Left** subtree values < Root.\n- **Right** subtree values > Root.\nEnables Search/Insert/Delete in O(log n) (if balanced).",
  "syntax": "if val < root.val: go_left()",
  "examples": [
    {
      "code": "Search 10:\n1. 10 < 20 (Root) -> Left\n2. 10 > 5 -> Right\n3. Match 10.",
      "output": "Found",
      "explanation": "Path length = Height."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Unbalanced Insertions",
      "correction": "Inserting 1, 2, 3, 4, 5 creates a line (skewed). Search becomes O(n). Solution: AVL/Red-Black Trees.",
      "example": "Degenerate tree."
    }
  ],
  "interview_questions": [
    {
      "question": "Is Inorder Traversal of BST sorted?",
      "answer": "Yes, Inorder traversal of a BST always yields sorted values.",
      "difficulty": "Easy"
    }
  ],
  "practice_problems": [],
  "real_world_use_cases": [
    {
      "scenario": "Auto-complete",
      "description": "Prefix trees (Tries) are n-ary search trees.",
      "code": "Search"
    }
  ],
  "exam_notes": [
    "No duplicates usually.",
    "O(h) ops."
  ],
  "summary": "Efficiently maintains sorted data.",
  "order": 34
}