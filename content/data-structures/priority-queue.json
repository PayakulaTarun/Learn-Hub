{
  "title": "Priority Queue",
  "slug": "priority-queue",
  "subject": "Data Structures",
  "category": "Core Computer Science",
  "level": "Intermediate",
  "estimated_read_time": "25 mins",
  "prerequisites": [
    "Queue Data Structure"
  ],
  "learning_objectives": [
    "Priority vs Fifo",
    "Min-Heap implementation",
    "Complexity"
  ],
  "theory": "In a PQ, elements come out based on **Priority** (e.g., Smallest number first), not arrival time. \nImplementation: Array (Slow insertions), Heap (Fast O(log n)).",
  "syntax": "pq.poll() // Returns specific element",
  "examples": [
    {
      "code": "pq.add(10)\npq.add(5)\npq.poll() // Returns 5 (if Min Heap)",
      "output": "Highest Priority",
      "explanation": "Order is determined by value."
    }
  ],
  "common_mistakes": [],
  "interview_questions": [
    {
      "question": "Time complexity of Insertion in PQ?",
      "answer": "O(log n) if using Binary Heap. O(1) or O(n) if using Arrays/Lists.",
      "difficulty": "Medium"
    }
  ],
  "practice_problems": [],
  "real_world_use_cases": [
    {
      "scenario": "Dijkstra's Algorithm",
      "description": "Graph shortest path uses PQ to explore closest nodes first.",
      "code": "Shortest Path"
    }
  ],
  "exam_notes": [
    "Max-PQ vs Min-PQ.",
    "Usually backed by Heap."
  ],
  "summary": "Essential for many greedy algorithms.",
  "order": 46
}