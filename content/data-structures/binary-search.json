{
  "title": "Binary Search",
  "slug": "binary-search",
  "subject": "Data Structures",
  "category": "Core Computer Science",
  "level": "Beginner",
  "estimated_read_time": "25 mins",
  "prerequisites": [
    "Linear Search"
  ],
  "learning_objectives": [
    "Divide and Conquer",
    "O(log n)",
    "Sorted Requirement"
  ],
  "theory": "Efficient search on **Sorted Arrays**. Compare target with middle element.\n- If Match: Found.\n- If < Mid: Search Left half.\n- If > Mid: Search Right half.\nRepeats typically reducing search space by half.",
  "syntax": "mid = (low + high) // 2",
  "examples": [
    {
      "code": "Arr = [10, 20, 30, 40, 50], Target=40\n1. Mid=30. 40 > 30. Go Right.\n2. Arr=[40, 50]. Mid=40. Match.",
      "output": "Found",
      "explanation": "2 steps instead of 4."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Mid Calculation Overflow",
      "correction": "`(low + high) / 2` can overflow integer. Use `low + (high - low) / 2`.",
      "example": "Integer Max limit."
    }
  ],
  "interview_questions": [
    {
      "question": "Can Binary Search work on Linked Lists?",
      "answer": "No/Inefficient. Random access to 'middle' is O(n) in linked list, negating the O(log n) benefit.",
      "difficulty": "Medium"
    }
  ],
  "practice_problems": [],
  "real_world_use_cases": [
    {
      "scenario": "Database Indexing",
      "description": "B-Trees used in DBs are a generalization of binary search.",
      "code": "SQL Index"
    }
  ],
  "exam_notes": [
    "Requires Sorted input.",
    "O(log n)."
  ],
  "summary": "Logarithmic time is extremely fast. 1 billion items takes ~30 steps.",
  "order": 32
}