{
  "title": "Backtracking",
  "slug": "backtracking",
  "subject": "Data Structures",
  "category": "Core Computer Science",
  "level": "Advanced",
  "estimated_read_time": "30 mins",
  "prerequisites": [
    "Recursion"
  ],
  "learning_objectives": [
    "Choice",
    "Constraint",
    "Goal",
    "Pruning"
  ],
  "theory": "Algorithmic-technique for solving constraint satisfaction problems. Build candidates incrementally, and abandon (**backtrack**) as soon as it determines the candidate cannot be valid.",
  "syntax": "def backtrack(path): if valid: res.add(path); for choice: backtrack...",
  "examples": [
    {
      "code": "N-Queens Problem",
      "output": "Board Config",
      "explanation": "Place queen. If safe, recurse. If stuck, remove queen and try next spot."
    }
  ],
  "common_mistakes": [],
  "interview_questions": [],
  "practice_problems": [],
  "real_world_use_cases": [
    {
      "scenario": "Sudoku Solver",
      "description": "Brute-force with intelligence.",
      "code": "Game"
    }
  ],
  "exam_notes": [
    "DFS on State Space Tree."
  ],
  "summary": "Systematic search of all possibilities.",
  "order": 10
}